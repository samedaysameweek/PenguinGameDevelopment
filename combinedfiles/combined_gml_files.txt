Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_battery
File: Create_0.gml
event_inherited();
item_name = "Battery";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_beta_hat
File: Create_0.gml
event_inherited();
item_name = "Beta Hat";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_big_bush
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_blackhoodie_item
File: Create_0.gml
event_inherited();
item_name = "Black Hoodie";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_blacksunglasses_item
File: Create_0.gml
event_inherited();
item_name = "Black Sun Glasses";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_boxpuffleo_item
File: Create_0.gml
event_inherited();
item_name = "Box Puffle O";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_box_decoration
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_broken_spyphone_item
File: Create_0.gml
event_inherited();
item_name = "Broken Spy Phone";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_bulletin_board
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Create_0.gml
// In obj_chat_window Create Event
dialog_data = [];        // Will be assigned by the NPC
dialog_index = 0;        // Current dialogue line
choice_selected = -1;    // Index of selected choice (-1 means none)
depth = -1001;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Draw_0.gml

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Draw_64.gml
// obj_chat_window: Draw GUI Event
if (global.chat_active && array_length(dialog_data) > 0 && global.chat_npc != noone) {
    // Get GUI dimensions (matches viewport: 288x216)
    var gui_width = display_get_gui_width();  // 288
    var gui_height = display_get_gui_height(); // 216

    // Get original window sprite size
    var orig_width = sprite_get_width(spr_npc_dialouge_full_window);
    var orig_height = sprite_get_height(spr_npc_dialouge_full_window);

    // Calculate scale to fill viewport width (288 pixels)
    var window_scale = gui_width / orig_width; // e.g., 288 / 100 = 2.88

    // Check height constraint (ensure it fits within 216 pixels)
    var scaled_height = orig_height * window_scale;
    if (scaled_height > gui_height) {
        window_scale = gui_height / orig_height;
    }

    // Recalculate scaled dimensions
    var scaled_width = orig_width * window_scale;
    scaled_height = orig_height * window_scale;

    // Calculate window position: centered horizontally, touching the bottom
    var window_x = (gui_width - scaled_width) / 2;
    var window_y = gui_height - scaled_height;

    // Draw the dialogue window (scaled to fill width)
    draw_sprite_ext(spr_npc_dialouge_full_window, 0, window_x, window_y, window_scale, window_scale, 0, c_white, 1);

    // Draw NPC portrait (shifted 2 units left and up, scaled)
    var portrait_x = window_x + 2 * window_scale;
    var portrait_y = window_y + 2 * window_scale;
    draw_sprite_ext(spr_npc_dialouge_full_colour_portrait, 0, portrait_x, portrait_y, window_scale, window_scale, 0, global.chat_npc.npc_color, 1);
    draw_sprite_ext(spr_npc_dialouge_full_outline_portrait, 0, portrait_x, portrait_y, window_scale, window_scale, 0, c_white, 1);

    // Set font
    draw_set_font(fnt_bonkfatty);

    // Draw dialogue text (scaled positions) with validation
    var text_x = window_x + 77 * window_scale;
    var text_y = window_y + 20 * window_scale;
    var max_text_width = (256 - 77) * window_scale;
    var separation = 20 * window_scale;

    if (dialog_data != undefined && dialog_index < array_length(dialog_data)) {
        var dialog_entry = dialog_data[dialog_index];

        if (is_struct(dialog_entry) && variable_struct_exists(dialog_entry, "text") && is_string(dialog_entry.text)) {
            // Draw the dialogue text
            draw_set_color(c_black);
            draw_text_ext(text_x, text_y, dialog_entry.text, separation, max_text_width);
        } else {
            // Log an error if the data is invalid
            show_debug_message("ERROR: Invalid dialog_data entry or missing 'text' property at index " + string(dialog_index));
        }

        // Draw dialogue choices if available
        if (is_struct(dialog_entry) && variable_struct_exists(dialog_entry, "choices") && array_length(dialog_entry.choices) > 0) {
            // Define button height before using it
            var button_height = sprite_get_height(spr_button) * window_scale;
            var choices_y = window_y - button_height - 10 * window_scale;

            // Button and chat sprite sizes
            var button_width = sprite_get_width(spr_button) * window_scale;
            var chat_width = sprite_get_width(spr_chat) * window_scale;
            var chat_height = sprite_get_height(spr_chat) * window_scale;
            var spacing = 10 * window_scale;

            var num_choices = array_length(dialog_entry.choices);
            var total_choices_width = (num_choices * button_width) + ((num_choices - 1) * spacing);
            var choices_start_x = window_x + (scaled_width - total_choices_width) / 2;

            for (var i = 0; i < num_choices; i++) {
                var button_x = choices_start_x + i * (button_width + spacing);
                // Draw spr_button as background
                draw_sprite_ext(spr_button, 0, button_x, choices_y, window_scale, window_scale, 0, c_white, 1);
                // Center spr_chat within spr_button
                var chat_x = button_x + (button_width - chat_width) / 2;
                var chat_y = choices_y + (button_height - chat_height) / 2;
                draw_sprite_ext(spr_chat, 0, chat_x, chat_y, window_scale, window_scale, 0, c_white, 1);
                // Draw choice text centered in spr_chat
                draw_set_color(i == choice_selected ? c_red : c_black);
                draw_set_halign(fa_center);
                draw_set_valign(fa_middle);
                draw_text(chat_x + chat_width / 2, chat_y + chat_height / 2, dialog_entry.choices[i]);
                draw_set_halign(fa_left);
                draw_set_valign(fa_top);
            }
        }
    } else {
        // Log an error if the index or data is invalid
        show_debug_message("ERROR: dialog_data is undefined or dialog_index out of bounds. Index: " + string(dialog_index));
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Mouse_4.gml
// obj_chat_window: Mouse Left Pressed Event
if (global.chat_active) {
    // Convert mouse coordinates to GUI coordinates
    var gui_mouse_x = device_mouse_x_to_gui(0);
    var gui_mouse_y = device_mouse_y_to_gui(0);

    // GUI dimensions
    var gui_width = display_get_gui_width();
    var gui_height = display_get_gui_height();
    var menu_width = 300;
    var menu_height = 150;
    var menu_x = (gui_width - menu_width) / 2;
    var menu_y = gui_height - menu_height - 50;

    // Close button logic
    var close_button_size = 20;
    var close_x = menu_x + menu_width - close_button_size - 20;
    var close_y = menu_y + 20;

    if (gui_mouse_x >= close_x && gui_mouse_x <= close_x + close_button_size &&
        gui_mouse_y >= close_y && gui_mouse_y <= close_y + close_button_size) {
        global.chat_active = false;
        global.chat_npc = noone;
        dialog_queue = [];
        show_debug_message("Close button clicked. Chat deactivated.");
        exit;
    }

    // Dialogue choice logic (example)
    if (dialog_index < array_length(dialog_data)) {
        var dialog_entry = dialog_data[dialog_index];
        if (is_struct(dialog_entry) && variable_struct_exists(dialog_entry, "choices") && array_length(dialog_entry.choices) > 0) {
            var button_width = 100;  // Adjust based on your button sprite/size
            var button_height = 30;  // Adjust based on your button sprite/size
            var spacing = 10;
            var choices_y = menu_y + menu_height - button_height - 10;  // Position below dialogue text
            var num_choices = array_length(dialog_entry.choices);
            var total_choices_width = (num_choices * button_width) + ((num_choices - 1) * spacing);
            var choices_start_x = menu_x + (menu_width - total_choices_width) / 2;

            for (var i = 0; i < num_choices; i++) {
                var button_x = choices_start_x + i * (button_width + spacing);
                if (gui_mouse_x >= button_x && gui_mouse_x <= button_x + button_width &&
                    gui_mouse_y >= choices_y && gui_mouse_y <= choices_y + button_height) {
                    choice_selected = i;
                    dialog_index++;  // Advance to next dialogue
                    show_debug_message("Choice " + string(i) + " selected: " + dialog_entry.choices[i]);
                    // Add your action logic here (e.g., start quest, update variables)
                    break;
                }
            }
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Step_0.gml
// In obj_chat_window Step Event
if (global.chat_active) {
    if (dialog_index < array_length(dialog_data)) {
        var current_dialog = dialog_data[dialog_index];
        
        // Check condition for dialogue (if it exists)
        if (variable_struct_exists(current_dialog, "condition")) {
            if (!current_dialog.condition()) {
                dialog_index++;  // Skip if condition fails
                exit;
            }
        }
        
        // Handle choices if they exist
        if (variable_struct_exists(current_dialog, "choices")) {
            if (keyboard_check_pressed(vk_up)) {
                choice_selected = max(choice_selected - 1, 0);
            }
            if (keyboard_check_pressed(vk_down)) {
                choice_selected = min(choice_selected + 1, array_length(current_dialog.choices) - 1);
            }
            if (keyboard_check_pressed(vk_space)) {
                if (choice_selected >= 0) {
                    // Handle quest actions
                    if (variable_struct_exists(current_dialog, "quest")) {
                        var quest = current_dialog.quest;
                        with (global.chat_npc) {
                            if (quest.action == "start") {
                                quest_stage = 1;  // Quest started
                            } else if (quest.action == "complete") {
                                // Add your inventory check here (e.g., player has quest_item)
                                quest_stage = 2;  // Quest completed
                                // Add reward logic here
                            }
                        }
                    }
                    dialog_index++;  // Move to next dialogue
                    choice_selected = -1;
                }
            }
        } else {
            if (keyboard_check_pressed(vk_space)) {
                dialog_index++;  // Advance to next line
            }
        }
    } else {
        // Dialogue ended
        global.chat_active = false;
        instance_destroy();
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_icon
File: Create_0.gml
// Initialize state
image_index = 0; // Default: not selected
is_selected = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_icon
File: Mouse_4.gml

// Deselect all other color icons
with (obj_color_icon) {
    image_index = 0; // Not selected
    is_selected = false;
}

// Select this icon
image_index = 1; // Selected
is_selected = true;

// Set global player color
global.player_color = icon_color;
global.last_player_color = global.player_color; // Save the choice persistently


// Ensure this icon is assigned a valid color
if (icon_color == undefined) {
    show_debug_message("ERROR: Icon color is undefined in obj_color_icon.");
    icon_color = c_white; // Default to white
}


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_picker_controller
File: Create_0.gml
// Define custom colors
var c_notblack = make_color_rgb(51, 51, 51);
var c_bluer = make_color_rgb(46, 71, 170);
var c_brown = make_color_rgb(153, 102, 0);
var c_cyan = make_color_rgb(7, 167, 163);
var c_emerald = make_color_rgb(7, 106, 68);
var c_greener = make_color_rgb(6, 155, 77);
var c_lavender = make_color_rgb(176, 126, 194);
var c_lightblue = make_color_rgb(8, 153, 211);
var c_mint = make_color_rgb(189, 252, 201);
var c_oranger = make_color_rgb(255, 102, 0);
var c_pink = make_color_rgb(255, 51, 153);
var c_purpler = make_color_rgb(102, 49, 158);
var c_reder = make_color_rgb(204, 0, 0);
var c_salmon = make_color_rgb(255, 67, 63);
var c_yellower = make_color_rgb(255, 204, 0);

// Colors array
var colors = [
    c_notblack, c_bluer, c_brown, c_cyan, c_emerald,
    c_greener, c_lavender, c_lightblue, c_mint, c_oranger,
    c_pink, c_purpler, c_reder, c_salmon, c_yellower
];

// Sprites for color icons
var sprites = [
    spr_colouricon_black, spr_colouricon_blue, spr_colouricon_brown, spr_colouricon_cyan, spr_colouricon_emerald,
    spr_colouricon_green, spr_colouricon_lavendar, spr_colouricon_lightblue, spr_colouricon_mint, spr_colouricon_orange,
    spr_colouricon_pink, spr_colouricon_purple, spr_colouricon_red, spr_colouricon_salmon, spr_colouricon_yellow
];

// Grid dimensions
var cols = 5;
var rows = 3;
var spacing = 70; // Distance between grid items
var start_x = room_width / 2.2 - ((cols - 1) * spacing) / 2;
var start_y = room_height / 2.2 - ((rows - 1) * spacing) / 2;

// Create the grid
for (var i = 0; i < array_length(colors); i++) { // Use array_length explicitly
    var x_pos = start_x + (i mod cols) * spacing;
    var y_pos = start_y + (i div cols) * spacing;

    // Create color icon instance
    var color_icon = instance_create_layer(x_pos, y_pos, "Instances", obj_color_icon);
    color_icon.icon_color = colors[i];       // Assign color
    color_icon.sprite_index = sprites[i];    // Assign corresponding sprite
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_wheel
File: Create_0.gml
depth = -1000;
// Menu dimensions
menu_width = 109;
menu_height = 72;

// Position the skin picker around the current player instance or center it in the view
if (instance_exists(global.player_instance)) {
    x = global.player_instance.x - menu_width / 2;
    y = global.player_instance.y - menu_height / 2;
} else {
    x = view_xview[0] + (view_wview[0] - menu_width) / 2;
    y = view_yview[0] + (view_hview[0] - menu_height) / 2;
}

// Initialize variables
selected_color = c_white;
global.player_color = c_white;

// Define selection areas
color_wheel_x = x + 31;
color_wheel_y = y + 19;
color_wheel_width = 46;
color_wheel_height = 46;

exit_x = x + 6;
exit_y = y + 6;
exit_width = 9;
exit_height = 9;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_wheel
File: Draw_0.gml
// Draw the background first
draw_sprite(spr_colorpicker_background, 0, x, y);

// Draw the color wheel directly without using the surface
draw_sprite(spr_color_bar, 0, x + 31, y + 19);

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_wheel
File: Mouse_4.gml
var mx = (device_mouse_x_to_gui(0) / display_get_gui_width()) * camera_get_view_width(global.camera) + camera_get_view_x(global.camera);
var my = (device_mouse_y_to_gui(0) / display_get_gui_height()) * camera_get_view_height(global.camera) + camera_get_view_y(global.camera);

// Check if the player clicked inside the exit button (6,6 to 14,14)
if (point_in_rectangle(mx, my, exit_x, exit_y, exit_x + exit_width, exit_y + exit_height)) {
    show_debug_message("Closing color wheel...");
    with (obj_pause_menu) instance_destroy();
    instance_destroy();
    return;
}

// Check if the click is inside the color wheel selection area
if (point_in_rectangle(mx, my, color_wheel_x, color_wheel_y, color_wheel_x + color_wheel_width, color_wheel_y + color_wheel_height)) {
    var sx = mx - color_wheel_x; // Convert to surface coordinates
	var sy = my - color_wheel_y;

	if (sx >= 0 && sy >= 0 && sx < sprite_get_width(spr_color_bar) && sy < sprite_get_height(spr_color_bar)) {
		selected_color = surface_getpixel(surf_color_wheel, sx, sy);
	}

   if (selected_color != c_black) { // Avoid selecting transparent areas
    global.player_color = selected_color;

    if (instance_exists(global.player_instance)) {
        global.player_instance.image_blend = global.player_color;
    }

    show_debug_message("Color selected: " + string(selected_color));
    
    // Close color wheel & pause menu
    with (obj_pause_menu) instance_destroy();
    instance_destroy();
	}
}

show_debug_message("Color picked: " + string(draw_getpixel(mx, my)));
show_debug_message("Fixed Mouse World X: " + string(mouse_world_x) + " | Y: " + string(mouse_world_y));
show_debug_message("View X: " + string(camera_get_view_x(global.camera)) + " | View Y: " + string(camera_get_view_y(global.camera)));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_wheel
File: Step_0.gml
// Handle mouse click for selecting a color
if (mouse_check_button_pressed(mb_left)) {
    var mx = device_mouse_x_to_gui(0);
    var my = device_mouse_y_to_gui(0);

    if (point_in_rectangle(mx, my, x, y, x + sprite_width, y + sprite_height)) {
        var sx = mx - x; // Convert to surface coordinates
        var sy = my - y;

        // Ensure the surface exists before sampling
        if (surface_exists(surf_color_wheel)) {
            selected_color = surface_getpixel(surf_color_wheel, sx, sy);
        } else {
            selected_color = c_black; // Fallback
        }

        // Apply color globally if valid
        if (selected_color != c_black) {
            global.player_color = selected_color;
            if (instance_exists(global.player_instance)) {
                global.player_instance.image_blend = global.player_color;
            }
            show_debug_message("Color selected: " + string(selected_color));
        }
        
        // Close the color wheel and return to previous room
        if (variable_global_exists("last_room") && global.last_room != noone) {
            room_goto(global.last_room);
        } else {
            room_goto(rm_town); // Default return room
        }
        instance_destroy();
    }
}


// Debug mouse position
show_debug_message("Mouse X: " + string(mouse_x) + " | Mouse Y: " + string(mouse_y));
show_debug_message("GUI Mouse X: " + string(device_mouse_x_to_gui(0)) + " | GUI Mouse Y: " + string(device_mouse_y_to_gui(0)));
show_debug_message("View X: " + string(camera_get_view_x(view_camera[0])) + " | View Y: " + string(camera_get_view_y(view_camera[0])));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_config_menu
File: Create_0.gml
// obj_config_menu: Create Event
depth = -10000; // Draw on top of other UI
item_scroll = 0; // Starting position for item list scrolling

// Center the panel
panel_width = sprite_get_width(spr_blue_square_panel);
panel_height = sprite_get_height(spr_blue_square_panel);
panel_x = (display_get_gui_width() - panel_width) / 2;
panel_y = (display_get_gui_height() - panel_height) / 2;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_config_menu
File: Draw_64.gml
//obj_config_menu Draw GUI event
// Draw background
draw_sprite(spr_blue_square_panel, 0, panel_x, panel_y);

// Skin buttons
var title = "Skins";
var title_width = string_width(title);
draw_text(panel_x + 20 + (100 - title_width) / 2, panel_y + 20, title);
var button_y = panel_y + 40;
for (var i = 0; i < array_length(global.skins); i++) {
    draw_set_color(c_white);
    draw_rectangle(panel_x + 20, button_y, panel_x + 120, button_y + 30, false); // 100x30 rectangle
    draw_set_color(c_black);
    var text = "Switch to " + global.skins[i].name;
    var text_width = string_width(text);
    var text_height = string_height(text);
    var text_x = panel_x + 20 + (100 - text_width) / 2; // Center horizontally
    var text_y = button_y + (30 - text_height) / 2; // Center vertically
    draw_text(text_x, text_y, text);
    button_y += 40;
}

// Item buttons with sprites
draw_set_color(c_black);
draw_text(panel_x + 170, panel_y + 20, "Items");
var items = ["Beta Hat", "Party Hat", "Wrench", "Tube", "Toboggan", "Battery", "Spy Phone", "Broken Spy Phone", "EPF Phone", "Fishing Rod", "Jackhammer", "Snow Shovel", "Pizza Slice", "Puffle O", "Box Puffle O", "Fish", "Mullet", "Wood", "Snow"];
var item_display_count = 5;
button_y = panel_y + 40;
for (var i = item_scroll; i < item_scroll + item_display_count && i < array_length(items); i++) {
    var square_x = panel_x + 150;
    var square_y = button_y;
    draw_set_color(c_white);
    draw_rectangle(square_x, square_y, square_x + 30, square_y + 30, false); // 30x30 square
    var item_index = ds_map_find_value(global.item_index_map, items[i]);
    if (!is_undefined(item_index)) {
        draw_sprite_part(spr_inventory_items, 0, item_index * 18, 0, 18, 18, square_x + 6, square_y + 6); // Centered sprite
    }
    button_y += 40;
}

// Scroll buttons
draw_set_color(c_white);
draw_rectangle(panel_x + 190, panel_y + 40, panel_x + 210, panel_y + 60, false); // Up button
draw_rectangle(panel_x + 190, panel_y + 60, panel_x + 210, panel_y + 80, false); // Down button
draw_set_color(c_black);
draw_text(panel_x + 200, panel_y + 45, "^");
draw_text(panel_x + 200, panel_y + 65, "v");

// Color picker buttons
draw_set_color(c_black);
draw_text(panel_x + 220, panel_y + 20, "Colors");
draw_set_color(c_white);
draw_rectangle(panel_x + 220, panel_y + 40, panel_x + 320, panel_y + 70, false);  // Player Color button
draw_set_color(c_black);
draw_set_halign(fa_center);
draw_text(panel_x + 270, panel_y + 55, "Player Color");
draw_set_color(c_white);
draw_rectangle(panel_x + 220, panel_y + 80, panel_x + 320, panel_y + 110, false); // Icetruck Color button
draw_set_color(c_black);
draw_text(panel_x + 270, panel_y + 95, "Icetruck Color");
draw_set_halign(fa_left);

// Close button
draw_set_color(c_red);
draw_rectangle(panel_x + panel_width - 30, panel_y + 10, panel_x + panel_width - 10, panel_y + 30, false);
draw_set_color(c_white);
draw_set_halign(fa_center);
draw_text(panel_x + panel_width - 20, panel_y + 12, "X"); // Center of 20x20 button
draw_set_halign(fa_left); // Reset to default


//npc dialouge code!!
if (global.chat_active && array_length(dialog_data) > 0 && variable_struct_exists(current_dialog, "choices") && array_length(current_dialog.choices) > 0) {
    var gui_width = display_get_gui_width();
    var gui_height = display_get_gui_height();
    
    // Determine inventory height based on HUD state
    var inventory_height;
    if (instance_exists(obj_hud_expanded) && global.is_expanded) {
        inventory_height = sprite_get_height(spr_hud_expanded) * 3; // Assuming ui_scale = 3
    } else {
        inventory_height = 50; // Default height for regular inventory
    }
    
    // Position choices above inventory
    var choices_y = gui_height - inventory_height - 20; // 20px buffer
    var num_choices = array_length(current_dialog.choices);
    var choice_width = 100; // Fixed width per choice
    var spacing = 10; // Space between choices
    var total_width = choice_width * num_choices + spacing * (num_choices - 1);
    var start_x = (gui_width - total_width) / 2; // Center horizontally

    // Draw each choice
    for (var i = 0; i < num_choices; i++) {
        var choice_x = start_x + i * (choice_width + spacing);
        draw_set_color(i == choice_selected ? c_red : c_black);
        draw_text(choice_x, choices_y, current_dialog.choices[i]);
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_config_menu
File: Step_0.gml
// obj_config_menu Step Event
if (mouse_check_button_pressed(mb_left)) {
    var mx = device_mouse_x_to_gui(0);
    var my = device_mouse_y_to_gui(0);
    
    // Skin buttons
    var button_y = panel_y + 40;
    for (var i = 0; i < array_length(global.skins); i++) {
        if (point_in_rectangle(mx, my, panel_x + 20, button_y, panel_x + 120, button_y + 30)) {
            obj_controller.switch_skin(global.skins[i].name);
            show_debug_message("Switched to skin: " + global.skins[i].name);
            global.ui_manager.close_ui();
            if (instance_exists(obj_inventory)) {
                obj_inventory.visible = true;  // Restore inventory
                show_debug_message("Inventory visibility set to true after skin switch.");
            }
            break;
        }
        button_y += 40;
    }
    
    // Item buttons
    var items = ["Beta Hat", "Party Hat", "Wrench", "Tube", "Toboggan", "Battery", "Spy Phone", "Broken Spy Phone", "EPF Phone", "Fishing Rod", "Jackhammer", "Snow Shovel", "Pizza Slice", "Puffle O", "Box Puffle O", "Fish", "Mullet", "Wood", "Snow"];
    var item_display_count = 5;
    button_y = panel_y + 40;
    var should_close = false;
    for (var i = item_scroll; i < item_scroll + item_display_count && i < array_length(items); i++) {
        if (point_in_rectangle(mx, my, panel_x + 150, button_y, panel_x + 180, button_y + 30)) {
            obj_inventory.add_to_inventory(items[i]);
            show_debug_message("Spawned item: " + items[i]);
            should_close = true;  // Flag to close after spawning
            break;
        }
        button_y += 40;
    }
    
    // Scroll buttons
    if (point_in_rectangle(mx, my, panel_x + 190, panel_y + 40, panel_x + 210, panel_y + 60)) {
        item_scroll = max(0, item_scroll - 1);
    } else if (point_in_rectangle(mx, my, panel_x + 190, panel_y + 60, panel_x + 210, panel_y + 80)) {
        item_scroll = min(array_length(items) - item_display_count, item_scroll + 1);
    }
    
    // Color picker buttons
    if (point_in_rectangle(mx, my, panel_x + 220, panel_y + 40, panel_x + 320, panel_y + 70)) {
    instance_create_layer(0, 0, "Instances", obj_player_colourpicker);
    global.ui_manager.close_ui(); // Only call this
	} else if (point_in_rectangle(mx, my, panel_x + 220, panel_y + 80, panel_x + 320, panel_y + 110)) {
        instance_create_layer(0, 0, "Instances", obj_icetruck_colourpicker);
        global.ui_manager.close_ui();
        if (instance_exists(obj_inventory)) {
            obj_inventory.visible = true;  // Restore inventory
            show_debug_message("Inventory visibility set to true after icetruck colour picker.");
        }
    }
    
    // Close button
    if (point_in_rectangle(mx, my, panel_x + panel_width - 30, panel_y + 10, panel_x + panel_width - 10, panel_y + 30)) {
        global.ui_manager.close_ui();
        if (instance_exists(obj_inventory)) {
            obj_inventory.visible = true;  // Restore inventory
            show_debug_message("Inventory visibility set to true after close button.");
        }
        show_debug_message("Configuration menu closed.");
    }
    
    // Close after spawning item
    if (should_close) {
        global.ui_manager.close_ui();
        if (instance_exists(obj_inventory)) {
            obj_inventory.visible = true;  // Restore inventory
            show_debug_message("Inventory visibility set to true after spawning item.");
        }
    }
}

if (keyboard_check_pressed(vk_escape)) {
    global.ui_manager.close_ui();
    if (instance_exists(obj_inventory)) {
        obj_inventory.visible = true;  // Restore inventory
        show_debug_message("Inventory visibility set to true after ESC.");
    }
    show_debug_message("Configuration menu closed via ESC.");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_continue_button
File: Create_0.gml
depth = -1000;
visible = file_exists("savegame.sav");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_continue_button
File: Mouse_4.gml
// Set the flag BEFORE loading starts
global.is_loading_game = true;
show_debug_message("Continue button pressed. Setting global.is_loading_game = true");

// Attempt to load the game
load_game();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Alarm_0.gml
// Ensure the new player instance is created after the previous one is destroyed
if (global.skin_to_spawn != noone) {
    var player_x = global.last_player_x;
    var player_y = global.last_player_y;

    // Create the new player instance
    global.player_instance = instance_create_layer(player_x, player_y, "Instances", global.skin_to_spawn);
    global.current_skin = global.skin_name_to_spawn;

    // Reset the temporary skin variables
    global.skin_to_spawn = noone;
    global.skin_name_to_spawn = "";

    // Ensure camera follows the new player
    if (instance_exists(global.player_instance)) {
        camera_set_view_target(global.camera, global.player_instance);
        show_debug_message("Skin switched to: " + global.current_skin + ". New instance ID: " + string(global.player_instance));
    } else {
        show_debug_message("ERROR: Failed to create player instance.");
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Alarm_1.gml
// obj_controller Alarm[1] Event
if (!global.is_pause_menu_active) { // Avoid saving during pause
    save_room_state(room);
    show_debug_message("Periodic save triggered for room: " + room_get_name(room));
}
alarm[1] = room_speed * 5; // Reset alarm
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Create_0.gml
/// Create Event for obj_controller

// --- ONE-TIME STATIC DATA INITIALIZATION ---
// Check if static data has already been initialized
if (!variable_global_exists("static_data_initialized") || global.static_data_initialized == false) {
    scr_initialize_item_data(); // Call the new script
    global.static_data_initialized = true; // Set flag to prevent re-running
    show_debug_message("obj_controller Create: Executed scr_initialize_item_data.");
} else {
    show_debug_message("obj_controller Create: Static item data already initialized, skipping scr_initialize_item_data.");
}
// --- END ONE-TIME STATIC DATA INITIALIZATION ---

/// @method switch_skin(new_skin_name)
/// @description Destroys current player instance and creates a new one based on skin name.
/// @param {string} new_skin_name The name of the skin to switch to (e.g., "player", "icetruck").
/// @returns {bool} True if switch was successful, false otherwise.
switch_skin = function(new_skin_name) {
    if (global.skin_switching) {
         show_debug_message("Skin Switch Denied: Switch already in progress.");
         return false; // Prevent overlapping switches
    }
    global.skin_switching = true;
    show_debug_message("Attempting to switch to skin: " + new_skin_name);

    // Store current player state safely
    var _x = (instance_exists(global.player_instance)) ? global.player_instance.x : global.player_x;
    var _y = (instance_exists(global.player_instance)) ? global.player_instance.y : global.player_y;
    var _face = DOWN; // Default facing
    if (instance_exists(global.player_instance) && variable_instance_exists(global.player_instance, "face")) {
        _face = global.player_instance.face;
    }

    // Store skin-specific state (Example: icetruck tint)
    var _icetruck_tint = c_yellow; // Default
    if (global.current_skin == "icetruck" && instance_exists(global.player_instance) && variable_instance_exists(global.player_instance, "icetruck_tint")) {
         _icetruck_tint = global.player_instance.icetruck_tint;
    }

    // Destroy old instance if it exists
    if (instance_exists(global.player_instance)) {
        show_debug_message("Destroying old player instance (" + string(global.player_instance) + ", skin: " + global.current_skin + ")");
        instance_destroy(global.player_instance);
        global.player_instance = noone; // Explicitly clear reference
    } else {
        show_debug_message("Warning: No existing player instance found to destroy during skin switch.");
    }


    // Find the object corresponding to the new skin name
    var new_player_obj = noone;
    var skin_found = false;
    if (variable_global_exists("skins") && is_array(global.skins)) {
         for (var i = 0; i < array_length(global.skins); i++) {
             if (global.skins[i].name == new_skin_name) {
                 if (object_exists(global.skins[i].object)) {
                    new_player_obj = global.skins[i].object;
                    skin_found = true;
                 } else {
                     show_debug_message("ERROR: Skin object for '" + new_skin_name + "' does not exist!");
                 }
                 break;
             }
         }
    } else {
         show_debug_message("ERROR: global.skins array not found or not an array!");
    }

    if (!skin_found) {
        show_debug_message("ERROR: Skin name '" + new_skin_name + "' not found in global.skins definition. Defaulting to 'player'.");
        new_skin_name = "player"; // Attempt to fallback
        new_player_obj = obj_player; // Assuming obj_player is default
        if (!object_exists(new_player_obj)) {
             show_debug_message("FATAL ERROR: Default skin obj_player doesn't exist!");
             global.skin_switching = false;
             return false; // Cannot continue
        }
    }

    // Create the new player instance
    global.player_instance = instance_create_layer(_x, _y, "Instances", new_player_obj);
    if (!instance_exists(global.player_instance)) {
          show_debug_message("FATAL ERROR: Failed to create new player instance for skin: " + new_skin_name);
          global.skin_switching = false;
          global.current_skin = "unknown"; // Reflect failed state
          return false; // Cannot continue
    }

    // Update global state and apply common properties
    global.current_skin = new_skin_name;
    global.player_instance.persistent = true; // Make sure new instance persists

    // Apply common state
    if (variable_instance_exists(global.player_instance, "face")) {
        global.player_instance.face = _face;
    }
    global.player_instance.image_blend = global.player_color;

     // Apply skin-specific state (Example: icetruck tint)
    if (new_skin_name == "icetruck" && variable_instance_exists(global.player_instance, "icetruck_tint")) {
        global.player_instance.icetruck_tint = _icetruck_tint; // Apply saved/default tint
        show_debug_message("Applied icetruck tint: " + string(_icetruck_tint));
    }

    // Update camera target
    camera_set_view_target(global.camera, global.player_instance);

    show_debug_message("Skin switched to: " + global.current_skin + ". New instance ID: " + string(global.player_instance));
    global.skin_switching = false; // Allow next switch
    return true; // Switch successful
} // End of switch_skin method definition

// --- Rest of obj_controller Create Event ---
init_globals(); // This now only ensures vars/DS and sets new game defaults

if (!variable_global_exists("colour_picker_active")) {
    global.colour_picker_active = false;
    show_debug_message("Initialized global.colour_picker_active in obj_controller Create.");
}

if (!variable_global_exists("is_game_paused")) {
         global.is_game_paused = false;
         show_debug_message("Initialized global.is_game_paused in obj_controller Create.");
    }
global.chat_active = false;
global.chat_npc = noone;
global.player_controls_enabled = true;

persistent = true; // Ensure persistence across rooms

// Initialize global variables early to avoid undefined references
global.dialogue_active = false; // Dialogue system starts inactive

// Track clicks processed by any UI elements
global.click_handled = false;
global.is_expanded = false;

// Get the FPS value for the room
var room_fps = game_get_speed(gamespeed_fps);

// Initialize countdown_timer with the desired duration in seconds multiplied by room_fps
global.countdown_timer = 1 * room_fps; // 1 second countdown 
global.is_pause_menu_active = false;
global.game_started = false; // Flag to check if the game has started
global.lives = 3; // Initialize player lives
game_timer = 0; // Initialize game timer
global.skin_switching = false; // Initialize the skin switching flag

// Initialize global variables
global.skins = [
    { name: "player", object: obj_player },
    { name: "icetruck", object: obj_player_icetruck },
    { name: "tube", object: obj_player_tube },
    { name: "toboggan", object: obj_player_toboggan },
    { name: "sled_player", object: obj_sled_player },
    { name: "ninja", object: obj_player_ninja }
];

global.current_skin = "player"; // Starting skin
global.player_instance = noone; // Initialize player instance
global.icetruck_destroyed = false; // Initialize icetruck_destroyed

// Define player colors globally
global.player_colors = [
    make_color_rgb(51, 51, 51),    // notblack
    make_color_rgb(46, 71, 170),   // bluer
    make_color_rgb(153, 102, 0),   // brown
    make_color_rgb(7, 167, 163),   // cyan
    make_color_rgb(7, 106, 68),    // emerald
    make_color_rgb(6, 155, 77),    // greener
    make_color_rgb(176, 126, 194), // lavender
    make_color_rgb(8, 153, 211),   // lightblue
    make_color_rgb(189, 252, 201), // mint
    make_color_rgb(255, 102, 0),   // oranger
    make_color_rgb(255, 51, 153),  // pink
    make_color_rgb(102, 49, 158),  // purpler
    make_color_rgb(204, 0, 0),     // reder
    make_color_rgb(255, 67, 63),   // salmon
    make_color_rgb(255, 204, 0)    // yellower
];

// Room state management
if (!variable_global_exists("room_states")) {
    global.room_states = ds_map_create();
}
global.current_room = room; // Track current room

// Ensure player instance exists
if (global.player_instance == noone) {
    if (global.current_skin == "player") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player);
    } else if (global.current_skin == "icetruck") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player_icetruck);
    } else if (global.current_skin == "tube") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player_tube);
    } else if (global.current_skin == "sled_player") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_sled_player);
    } else if (global.current_skin == "ninja") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player_ninja);
    } else if (global.current_skin == "toboggan") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player_toboggan);
    }
}

if (instance_exists(global.player_instance)) {
    global.player_instance.image_blend = global.player_color;
    show_debug_message("Restored player color: " + string(global.player_color));
} 

if (!variable_global_exists("following_puffles")) {
    global.following_puffles = ds_list_create();
}

// Quest management
global.active_quests = ds_list_create();
global.completed_quests = ds_list_create();
global.quest_progress = ds_map_create();
global.quest_definitions = ds_map_create();

// Define a sample quest
function create_quest(_id, _name, _description, _objectives, _rewards) {
    var quest = ds_map_create();
    ds_map_add(quest, "id", _id);
    ds_map_add(quest, "name", _name);
    ds_map_add(quest, "description", _description);
    ds_map_add(quest, "objectives", _objectives);
    ds_map_add(quest, "rewards", _rewards);
    return quest;
}

// Sample quest: Find the Missing Puffle
var quest1 = create_quest(
    1,
    "Find the Missing Puffle",
    "Help the NPC find their lost puffle.",
    [
        { "type": "collect", "item": "Puffle O", "amount": 1 },
        { "type": "talk", "npc": "NPC1" }
    ],
    { "coins": 100, "item": "Beta Hat" }
);
ds_map_add(global.quest_definitions, 1, quest1);

// Debugging
if (instance_exists(global.player_instance)) {
    show_debug_message("Player instance created: " + string(global.player_instance));
} else {
    show_debug_message("Error: Failed to create player instance.");
}

// Add debug message to confirm Create event runs
show_debug_message("obj_controller created with ID: " + string(id));
show_debug_message("obj_controller Create event executed");

//alarm[1] = room_speed * 5;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Other_3.gml
function cleanup_game() {
if (ds_exists(global.room_states, ds_type_map)) {
    ds_map_destroy(global.room_states);
}
if (ds_exists(global.following_puffles, ds_type_list)) {
    ds_list_destroy(global.following_puffles);
}
if (ds_exists(global.active_quests, ds_type_list)) {
    ds_list_destroy(global.active_quests);
}
if (ds_exists(global.completed_quests, ds_type_list)) {
    ds_list_destroy(global.completed_quests);
}
if (ds_exists(global.quest_progress, ds_type_map)) {
    ds_map_destroy(global.quest_progress);
}
if (ds_exists(global.quest_definitions, ds_type_map)) {
    ds_map_destroy(global.quest_definitions);
}
// Add destruction for other global data structures used in your project
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Other_4.gml
// --- obj_controller: Other Event: Room Start (Other_4) --- SAFER CLEANUP

   var _current_room_name = room_get_name(room);
   show_debug_message("CONTROLLER ROOM START: Entering room: " + _current_room_name);

   // --- Determine if this is a UI/Special Room ---
   var is_non_gameplay_room = (room == rm_init || room == rm_main_menu || room == rm_map ||
                               room == rm_pause_menu || room == rm_settings_menu || room == rm_saveload ||
                               room == rm_colorpicker_menu);
   var _is_fresh_load = (variable_global_exists("is_loading_game") && global.is_loading_game == true);
   if (is_non_gameplay_room) {
    // [...] (Non-gameplay room logic remains the same)
    show_debug_message("CONTROLLER ROOM START: Non-gameplay room detected...");
     if (!instance_exists(obj_ui_manager)) {
         instance_create_layer(0, 0, "UI", obj_ui_manager);
         show_debug_message("CONTROLLER ROOM START: Created obj_ui_manager in Non-Gameplay room.");
    }
    if (_is_fresh_load) {
        global.is_loading_game = false;
        show_debug_message("CONTROLLER ROOM START: Reset global.is_loading_game (in UI room).");
    }
    exit;
}

// --- Gameplay Room Logic ---

// --- 1. Determine Player Start Position & Facing ---
   var start_x, start_y, start_face;
   var _used_warp_coords = false;
   if (_is_fresh_load) { /* ... Load logic ... */
     start_x = global.player_x; start_y = global.player_y; start_face = global.last_player_face ?? DOWN;
     show_debug_message("CONTROLLER ROOM START (Load): Using saved player pos (" + string(start_x) + "," + string(start_y) + ").");
}    else if (variable_global_exists("warp_target_x") && !is_undefined(global.warp_target_x)) { /* ... Player Warp logic ... */
     start_x = global.warp_target_x; start_y = global.warp_target_y; start_face = global.warp_target_face ?? DOWN;
     _used_warp_coords = true;
     show_debug_message("CONTROLLER ROOM START (Warp): Using PLAYER warp target pos (" + string(start_x) + "," + string(start_y) + ").");
}	 else { /* ... Default/Spawn Point logic ... */
      show_debug_message("CONTROLLER ROOM START (Default): Not loading and warp_target_x is undefined. Setting defaults first...");
      start_x = room_width / 2; start_y = room_height / 2; start_face = DOWN;
      var default_spawn = instance_find(obj_spawn_point, 0);
      if (instance_exists(default_spawn)) { start_x = default_spawn.x; start_y = default_spawn.y; }
      show_debug_message("CONTROLLER ROOM START (Default): Final default/spawn pos (" + string(start_x) + "," + string(start_y) + ") Face: " + string(start_face));
 }

// --- Clear warp coordinates AFTER deciding start pos ---
if (variable_global_exists("warp_target_x")) { /* ... Clear warp vars ... */
     if (is_undefined(global.warp_target_x)) { show_debug_message("CONTROLLER ROOM START: Global warp targets were already undefined (Likely NPC warp)."); }
     else { show_debug_message("CONTROLLER ROOM START: Clearing player warp target variables."); }
     global.warp_target_x = undefined; global.warp_target_y = undefined; global.warp_target_face = undefined; global.warp_target_inst_id = noone;
}

global.player_instance = noone;
show_debug_message("CONTROLLER ROOM START: Explicitly set global.player_instance = noone before creation.");

// --- 3. Create Player Instance ---
 var player_obj = obj_player; // Default
if (variable_global_exists("current_skin")) { /* ... code to find player_obj based on skin ... */
    var found_skin = false;
     for (var i = 0; i < array_length(global.skins); i++) { if (global.skins[i].name == global.current_skin) { if (object_exists(global.skins[i].object)) { player_obj = global.skins[i].object; found_skin = true; } else { /*Log Error*/ } break; } }
     if (!found_skin) { /* Log Warning & Default */ global.current_skin = "player"; player_obj = obj_player; }
} else { /* Log Warning & Default */ global.current_skin = "player"; player_obj = obj_player; }
if (!object_exists(player_obj)) { /* ... error handling ... */ if (object_exists(obj_player)) { player_obj = obj_player; global.current_skin = "player"; } else { exit; } }
if (!layer_exists("Instances")) { layer_create(0, "Instances"); }

var _new_player = instance_create_layer(start_x, start_y, "Instances", player_obj);

// --- 4. Assign and Verify Global Player Instance ---
// Ensure global.player_instance *definitely* points to the new instance or noone.
if (instance_exists(_new_player)) {
     global.player_instance = _new_player; // Assign the new ID
     global.player_instance.persistent = true;
    if (variable_instance_exists(global.player_instance, "face")) { global.player_instance.face = start_face; }
    global.player_instance.image_blend = global.player_color;
    global.player_instance.visible = true;
     show_debug_message("Created player instance: " + string(global.player_instance) + " skin: " + global.current_skin + " at ("+string(start_x)+","+string(start_y)+")");
     // [...] Apply skin-specific state
} else {
     show_debug_message("CONTROLLER ROOM START FATAL ERROR: Failed to create player instance for skin: " + global.current_skin);
     global.player_instance = noone; // Ensure it's noone if creation failed
     exit;
}


// --- 5. Load Room State ---
show_debug_message("CONTROLLER ROOM START: Calling load_room_state for: " + _current_room_name + " (Is Fresh Load: " + string(_is_fresh_load) + ")");
load_room_state(room, _is_fresh_load);

// --- 6. Final Setup ---
if (_is_fresh_load) { /* ... Reset loading flag ... */
     show_debug_message("CONTROLLER ROOM START: Resetting global.is_loading_game flag.");
     global.is_loading_game = false;
}

// --- 7. CAMERA AND VIEW SETUP ---
 // [...] (Camera setup code remains the same)
 view_set_camera(0, global.camera); view_enabled = true; view_visible[0] = true;
 var intended_view_width = 288; var intended_view_height = 216; var view_width = min(intended_view_width, room_width); var view_height = min(intended_view_height, room_height); camera_set_view_size(global.camera, view_width, view_height); camera_set_view_border(global.camera, 0, 0); show_debug_message("Set camera view size to " + string(view_width) + "x" + string(view_height) + ", border (0,0)");
  if (room_width <= view_width && room_height <= view_height) { /* Fix camera */ camera_set_view_target(global.camera, noone); camera_set_view_speed(global.camera, -1, -1); camera_set_view_pos(global.camera, 0, 0); show_debug_message("Camera fixed at (0, 0)."); }
  else { /* Follow player */ if (instance_exists(global.player_instance)) { camera_set_view_target(global.camera, global.player_instance); camera_set_view_speed(global.camera, -1, -1); var cam_x = global.player_instance.x - (view_width / 2); var cam_y = global.player_instance.y - (view_height / 2); cam_x = clamp(cam_x, 0, max(0, room_width - view_width)); cam_y = clamp(cam_y, 0, max(0, room_height - view_height)); camera_set_view_pos(global.camera, cam_x, cam_y); show_debug_message("Camera follow player " + string(global.player_instance) + " INSTANT."); } else { /* Fallback fix camera */ camera_set_view_target(global.camera, noone); camera_set_view_speed(global.camera, -1, -1); camera_set_view_pos(global.camera, 0, 0); show_debug_message("WARNING: Player missing, Camera fixed."); } }

// --- 8. Ensure UI Layer and Manager ---
// [...] (UI layer/manager check remains the same)
if (!layer_exists("UI")) { layer_create(-10000, "UI"); }
if (!instance_exists(obj_ui_manager)) { instance_create_layer(0, 0, "UI", obj_ui_manager); }

show_debug_message("CONTROLLER ROOM START: Finished setup for room: " + _current_room_name);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Other_5.gml
// obj_controller -> Other Event: Room End (Other_5.gml) - REVISED v8 (Correct Array Push Scope)

var _leaving_room_name = room_get_name(room);
show_debug_message("obj_controller Room End: Transitioning from room: " + _leaving_room_name);

// --- Ensure global room_states map exists ---
if (!ds_exists(global.room_states, ds_type_map)) {
    show_debug_message("Room End WARN: global.room_states map missing! Creating it.");
    global.room_states = ds_map_create();
}

// --- Room State Saving Logic ---
var is_non_gameplay_room = (room == rm_init || room == rm_main_menu || room == rm_map ||
                            room == rm_pause_menu || room == rm_settings_menu || room == rm_saveload ||
                            room == rm_colorpicker_menu);
var _is_currently_loading = variable_global_exists("is_loading_game") && global.is_loading_game;

if (!_is_currently_loading && !is_non_gameplay_room) {
    show_debug_message("Saving runtime state for leaving room: " + _leaving_room_name);
    var _state_array = []; // <<< Declare the array in the main event scope

    show_debug_message("Room End WITH DEBUG: --- Start Instance Check ---");

    // --- Iterate using with(all) ---
    with (all) {
        // `self` now refers to the instance being iterated over
        var _inst_id = self.id;
        var _obj_index = object_index;
        var _dbg_obj_name = object_get_name(_obj_index);

        // --- Skip non-savable instances ---
        if (_inst_id == other.id) continue; // Skip controller
        if (variable_global_exists("player_instance") && instance_exists(global.player_instance) && _inst_id == global.player_instance) continue;
        if (variable_global_exists("ui_manager") && instance_exists(global.ui_manager) && _inst_id == global.ui_manager) continue;

        // --- SAVABLE CHECK ---
        var _is_instance_savable = false;
        var _parent_index = object_get_parent(_obj_index);
        if (_parent_index == obj_pickup_item) { // Check parent first
            _is_instance_savable = true;
        } else if ( // Check specific types if parent doesn't match
            _obj_index == obj_pickup_item || _obj_index == obj_toboggan || _obj_index == obj_tube ||
            _obj_index == obj_icetruck || _obj_index == obj_icetruck_broken || _obj_index == obj_puffle)
        {
             _is_instance_savable = true;
        }

        // Further exclusion (Puffles)
        if (_is_instance_savable && _obj_index == obj_puffle) {
            if (variable_global_exists("following_puffles") && ds_exists(global.following_puffles, ds_type_list) && ds_list_find_index(global.following_puffles, _inst_id) != -1) {
                _is_instance_savable = false;
            }
        }

        // --- If deemed savable, process it ---
        if (_is_instance_savable) {
            show_debug_message("Room End WITH DEBUG: >>> Preparing to save state for: " + string(_inst_id) + " (" + _dbg_obj_name + ")"); // Log BEFORE push
            try {
                 var _state_data = {
                     object_index_name: _dbg_obj_name,
                     x: x, y: y,
                     image_xscale: image_xscale ?? 1,
                     image_yscale: image_yscale ?? 1,
                     image_blend: image_blend ?? c_white,
                     image_alpha: image_alpha ?? 1,
                     face: variable_instance_exists(id, "face") ? face : undefined,
                     icetruck_tint: variable_instance_exists(id, "icetruck_tint") ? icetruck_tint : undefined,
                     is_driveable: variable_instance_exists(id, "is_driveable") ? is_driveable : undefined,
                     item_name: variable_instance_exists(id, "item_name") ? item_name : undefined,
                     following_player: variable_instance_exists(id, "following_player") ? following_player : undefined,
                     puffle_color: (_obj_index == obj_puffle && variable_instance_exists(id, "color")) ? color : undefined,
                     puffle_state: (_obj_index == obj_puffle && variable_instance_exists(id, "state")) ? state : undefined,
                 };
                 // *** THE FIX: Push directly to _state_array (NO `other`) ***
                 array_push(_state_array, _state_data);
                 show_debug_message("Room End WITH DEBUG: +++ Successfully pushed state for " + string(_inst_id)); // Log AFTER successful push
            } catch (_ex) {
                show_debug_message("Room End Save State ERROR: Failed during struct creation/push for " + string(_inst_id) + " (" + _dbg_obj_name + ") - " + string(_ex));
            }
        } else {
             // Log skipped instance (optional)
             // if (_obj_index != obj_controller && ...) { show_debug_message(...) }
        }
    } // --- End with(all) ---

    show_debug_message("Room End WITH DEBUG: --- End Instance Check ---");
    show_debug_message("Room End DEBUG: Finished checking instances. Collected " + string(array_length(_state_array)) + " savable states."); // Use the length of the array

    // --- Store the collected state array ---
    if (ds_map_exists(global.room_states, _leaving_room_name)) {
        show_debug_message("Replacing existing room state array for: " + _leaving_room_name + " with new array size: " + string(array_length(_state_array)));
        ds_map_replace(global.room_states, _leaving_room_name, _state_array);
    } else {
        show_debug_message("Adding new room state array for: " + _leaving_room_name + " with size: " + string(array_length(_state_array)));
        ds_map_add(global.room_states, _leaving_room_name, _state_array);
    }
     show_debug_message("Finished saving runtime state for room: " + _leaving_room_name);

} else {
    // Log reason for skipping save
    if (_is_currently_loading) show_debug_message("Skipping room state save: Currently loading game.");
    if (is_non_gameplay_room) show_debug_message("Skipping room state save: Non-gameplay room (" + _leaving_room_name + ").");
    // Ensure empty array is stored if room was visited but had no savable objects
    if (!_is_currently_loading && !is_non_gameplay_room && !ds_map_exists(global.room_states, _leaving_room_name)) {
         show_debug_message("Adding empty room state array for: " + _leaving_room_name + " (No savable objects found).");
         ds_map_add(global.room_states, _leaving_room_name, []);
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Step_0.gml
/// Step Event for obj_controller

if (instance_exists(global.player_instance)) {
    // Determine target camera position based on player instance
    var target_x = global.player_instance.x - (camera_get_view_width(global.camera) / 2);
    var target_y = global.player_instance.y - (camera_get_view_height(global.camera) / 2);

    // Clamp camera position to ensure it doesn't go out of room bounds
    target_x = clamp(target_x, 0, room_width - camera_get_view_width(global.camera));
    target_y = clamp(target_y, 0, room_height - camera_get_view_height(global.camera));

    // Smoothly transition the camera to the target position using linear interpolation
    camera_set_view_pos(
        global.camera,
        lerp(camera_get_view_x(global.camera), target_x, 0.1),
        lerp(camera_get_view_y(global.camera), target_y, 0.1)
    );
} else {
    // Log warning if no player instance exists
    show_debug_message("WARNING: Player instance not found. Camera cannot follow.");
}

global.click_handled = false;
// Toggle Pause Menu with ESC
if (keyboard_check_pressed(vk_escape) && !global.colour_picker_active) {
    global.is_pause_menu_active = !global.is_pause_menu_active;
    if (global.is_pause_menu_active) {
        global.player_controls_enabled = false;
        show_debug_message("Game Paused");
    } else {
        global.player_controls_enabled = true;
        if (instance_exists(obj_inventory)) {
            obj_inventory.visible = true;  // Restore inventory
        }
        show_debug_message("Game Resumed");
    }
}

// Toggle expanded inventory
if (keyboard_check_pressed(ord("I"))) {
    if (instance_exists(obj_inventory_expanded)) {
        with (obj_inventory_expanded) {
            instance_destroy();
        }
        global.game_paused = false;
    } else {
        instance_create_layer(0, 0, "Instances", obj_inventory_expanded);
        global.game_paused = true;
    }
}

// Toggle icetruck colour picker with "C" when skin is icetruck
if (keyboard_check_pressed(ord("C")) && global.current_skin == "icetruck") {
    if (instance_exists(obj_icetruck_colourpicker)) {
        with (obj_icetruck_colourpicker) instance_destroy();
    } else {
        instance_create_layer(0, 0, "Instances", obj_icetruck_colourpicker);
    }
}

var is_ui_room = (room == rm_init || room == rm_main_menu || room == rm_map || room == rm_pause_menu || room == rm_settings_menu);

// Hide or show the player in UI rooms
if (is_ui_room) {
    if (instance_exists(global.player_instance)) {
        global.player_instance.visible = false;
        show_debug_message("DEBUG: UI Room detected. Player instance hidden.");
    }
} else {
    if (!instance_exists(global.player_instance)) {
        show_debug_message("WARNING: No player instance found. Recreating...");
        var player_x = global.player_x;
        var player_y = global.player_y;
        var player_obj;
        switch (global.current_skin) {
            case "player":
                player_obj = obj_player;
                break;
            case "toboggan":
                player_obj = obj_player_toboggan;
                break;
            case "tube":
                player_obj = obj_player_tube;
                break;
            case "icetruck":
                player_obj = obj_player_icetruck;
                break;
            case "sled_player":
                player_obj = obj_sled_player;
                break;
            case "ninja":
                player_obj = obj_player_ninja;
                break;
            default:
                player_obj = obj_player;
        }
        global.player_instance = instance_create_layer(player_x, player_y, "Instances", player_obj);
        show_debug_message("DEBUG: Player recreated in Step event at (" + string(player_x) + ", " + string(player_y) + ") with skin: " + global.current_skin);
    } else {
        global.player_instance.visible = true;
    }
}

if (room == rm_sled_racing) {
    switch_skin("sled_player");
}

// Function to start a quest
function start_quest(quest_id) {
    if (!ds_list_find_index(global.active_quests, quest_id)) {
        ds_list_add(global.active_quests, quest_id);
        var quest = ds_map_find_value(global.quest_definitions, quest_id);
        var progress = ds_map_create();
        for (var i = 0; i < array_length(quest[?"objectives"]); i++) {
            ds_map_add(progress, i, false); // Not completed
        }
        ds_map_add(global.quest_progress, quest_id, progress);
        show_debug_message("Started quest: " + quest[?"name"]);
    }
}

// Function to check quest completion
function check_quest_completion(quest_id) {
    var progress = ds_map_find_value(global.quest_progress, quest_id);
    if (progress == undefined) return false;
    var quest = ds_map_find_value(global.quest_definitions, quest_id);
    var objectives = quest[?"objectives"];
    for (var i = 0; i < array_length(objectives); i++) {
        var obj = objectives[i];
        if (obj.type == "collect") {
            var item_count = obj_inventory.get_inventory_item_count(obj.item);
            if (item_count < obj.amount) return false;
        } else if (obj.type == "talk") {
            if (!ds_map_find_value(progress, i)) return false;
        }
    }
    return true;
}

// Function to complete a quest
function complete_quest(quest_id) {
    var index = ds_list_find_index(global.active_quests, quest_id);
    if (index != -1) {
        ds_list_delete(global.active_quests, index);
        ds_list_add(global.completed_quests, quest_id);
        var quest = ds_map_find_value(global.quest_definitions, quest_id);
        var rewards = quest[?"rewards"];
        if (variable_struct_exists(rewards, "coins")) {
            global.coins = variable_global_exists("coins") ? global.coins + rewards.coins : rewards.coins;
        }
        if (variable_struct_exists(rewards, "item")) {
            obj_inventory.add_to_inventory(rewards.item);
        }
        var progress = ds_map_find_value(global.quest_progress, quest_id);
        ds_map_destroy(progress);
        ds_map_delete(global.quest_progress, quest_id);
        show_debug_message("Completed quest: " + quest[?"name"]);
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_crates
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_dock
File: Step_0.gml
set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_dropped_item
File: Create_0.gml
// Set item properties
item_type = ""; // Set when the object is created
sprite_index = spr_inventory_items;
is_savable = true; // Mark as savable
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_dropped_item
File: Draw_0.gml
// Draw the dropped item
draw_sprite(sprite_index, 0, x, y);

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_dropped_item
File: Step_0.gml
// Check if player picks up the item
if (distance_to_object(global.player_instance) < 16 && keyboard_check_pressed(ord("E"))) {
    obj_inventory.add_to_inventory(item_type);
    instance_destroy();
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_epfphone_item
File: Create_0.gml
event_inherited();
item_name = "EPF Phone";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishbarrel1
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishbarrel2
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishbarrel3
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishbarrel4
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishing_rod
File: Create_0.gml
event_inherited();
item_name = "Fishing Rod";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ghostcostume_item
File: Create_0.gml
event_inherited();
item_name = "Ghost Costume";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_hud_expanded
File: Create_0.gml
// obj_hud_expanded: Create Event
depth = -10000;
inventory = obj_inventory.inventory;
inventory_size = obj_inventory.inventory_size;
active_slot = obj_inventory.active_slot;
global.active_item_index = active_slot;
global.is_special_actions_open = false
is_active = true;
global.expanded_hud_instance = id;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_hud_expanded
File: Draw_64.gml
// obj_hud_expanded: Draw GUI Event
if (is_active) {
if (global.is_expanded) {
    var ui_scale = 3;
    var gui_width = display_get_gui_width();
    var gui_height = display_get_gui_height();
    var inv_width = sprite_get_width(spr_hud_expanded) * ui_scale;
    var inv_height = sprite_get_height(spr_hud_expanded) * ui_scale;
    var inv_x = (gui_width - inv_width) / 2;
    var inv_y = gui_height - inv_height;
    draw_sprite_ext(spr_hud_expanded, 0, inv_x, inv_y, ui_scale, ui_scale, 0, c_white, 1);

    // Draw inventory items
    var slot_positions = [
        [inv_x + 5 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 25 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 45 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 65 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 85 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 105 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 125 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 145 * ui_scale, inv_y + 14 * ui_scale]
    ];

    for (var i = 0; i < 8; i++) {
                if (!is_undefined(inventory[i]) && inventory[i] != -1) { // Skip empty slots
                    var slot_x = slot_positions[i][0];
                    var slot_y = slot_positions[i][1];
                    var item_index = inventory[i];
                    var x_offset, y_offset;
                    if (item_index < 21) { // First row: items 0–20
                        x_offset = item_index * 18;
                        y_offset = 0;
                    } else { // Second row: items 21–24
                        x_offset = (item_index - 21) * 18;
                        y_offset = 18;
                    }
                    draw_sprite_part_ext(spr_inventory_items, 0, x_offset, y_offset, 18, 18, slot_x, slot_y, ui_scale, ui_scale, c_white, 1);
                    if (i == active_slot) {
                        draw_sprite_ext(spr_inventory_highlight, 0, slot_x - 1 * ui_scale, slot_y - 1 * ui_scale, ui_scale, ui_scale, 0, c_white, 1);
                    }
                }
            }

    // Draw special actions menu
    if (global.is_special_actions_open) {
        var special_x = inv_x + 85 * ui_scale;
        var special_y = inv_y + 37 * ui_scale - sprite_get_height(spr_hud_special_actions) * ui_scale;
        draw_sprite_ext(spr_hud_special_actions, 0, special_x, special_y, ui_scale, ui_scale, 0, c_white, 1);
    }
	update_equipped_items_display();
}
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_hud_expanded
File: Step_0.gml
// obj_hud_expanded Step event
if (global.chat_active) exit;
// Handle mouse clicks
if (is_active) {
    if (mouse_check_button_pressed(mb_left)) {
        var mx = device_mouse_x_to_gui(0);
        var my = device_mouse_y_to_gui(0);
	
    var ui_scale = 3;
    var gui_width = display_get_gui_width();
    var gui_height = display_get_gui_height();
    var inv_width = sprite_get_width(spr_hud_expanded) * ui_scale;
    var inv_x = (gui_width - inv_width) / 2;
    var inv_y = gui_height - sprite_get_height(spr_hud_expanded) * ui_scale;
    var close_area_left = inv_x + 54 * ui_scale;
    var close_area_top = inv_y + 2 * ui_scale;
    var close_area_right = inv_x + 112 * ui_scale;
    var close_area_bottom = inv_y + 9 * ui_scale;
	// Define the special actions button area
    var special_area_left = inv_x + 85 * ui_scale;
    var special_area_top = inv_y + 37 * ui_scale;
    var special_area_right = inv_x + 102 * ui_scale;
    var special_area_bottom = inv_y + 54 * ui_scale;

	if (point_in_rectangle(mx, my, close_area_left, close_area_top, close_area_right, close_area_bottom)) {
	    global.expanded_hud_open = false; // Add this line
	    global.is_expanded = false;
	    instance_destroy();
	    global.expanded_hud_instance = noone;
	    show_debug_message("Expanded HUD closed successfully.");
	    global.click_handled = true;
	    return;
	}
		// Open expanded inventory menu
        else if (point_in_rectangle(mx, my, inv_x + 65 * ui_scale, inv_y + 37 * ui_scale, inv_x + 82 * ui_scale, inv_y + 54 * ui_scale)) {
            instance_create_layer(0, 0, "Instances", obj_inventory_expanded);
            show_debug_message("Expanded inventory menu opened.");
        }
        // Open special actions menu
        else if (point_in_rectangle(mx, my, special_area_left, special_area_top, special_area_right, special_area_bottom)) {
        global.is_special_actions_open = !global.is_special_actions_open;
        show_debug_message("Special actions menu toggled: " + (global.is_special_actions_open ? "open" : "closed"));
        return;
		}
        // Throw a snowball (placeholder)
        else if (point_in_rectangle(mx, my, inv_x + 105 * ui_scale, inv_y + 37 * ui_scale, inv_x + 122 * ui_scale, inv_y + 54 * ui_scale)) {
            global.is_expanded = false;
            show_debug_message("Throw snowball clicked - to be implemented.");
            // Add snowball logic here later
        }
        // Go to igloo (placeholder)
        else if (point_in_rectangle(mx, my, inv_x + 125 * ui_scale, inv_y + 37 * ui_scale, inv_x + 142 * ui_scale, inv_y + 54 * ui_scale)) {
            global.is_expanded = false;
            show_debug_message("Go to igloo clicked - to be implemented.");
            // Add igloo room transition here later
        }
        // Open configuration menu
        else if (point_in_rectangle(mx, my, inv_x + 145 * ui_scale, inv_y + 37 * ui_scale, inv_x + 162 * ui_scale, inv_y + 54 * ui_scale)) {
            global.ui_manager.open_ui(obj_config_menu);
            show_debug_message("Configuration menu opened.");
            is_active = false; // Deactivate the expanded HUD
            return;
        }
        
         // Handle special actions menu clicks
    if (global.is_special_actions_open) {
        var special_x = inv_x + 85 * ui_scale;
        var special_y = inv_y + 37 * ui_scale - sprite_get_height(spr_hud_special_actions) * ui_scale;
        
        // Wave action (coordinates: adjust as per your sprite layout)
        if (point_in_rectangle(mx, my, special_x + 1 * ui_scale, special_y + 41 * ui_scale, special_x + 16 * ui_scale, special_y + 55 * ui_scale)) {
            obj_player.action_state = "wave";
            obj_player.action_timer = 0;
            obj_player.action_duration = 80; // 16 frames * 5 steps (0.2 speed)
            obj_player.image_index = 0;
            show_debug_message("Wave action triggered");
            global.is_special_actions_open = false;
            global.is_expanded = false;
            instance_destroy();
        }
        // Sit action
        else if (point_in_rectangle(mx, my, inv_x + 145 * ui_scale, inv_y + 37 * ui_scale, inv_x + 162 * ui_scale, inv_y + 54 * ui_scale)) {
        if (instance_exists(global.player_instance)) {
            if (global.player_instance.action_state == "sit") {
                global.player_instance.action_state = "none";
                show_debug_message("Stopped sitting via HUD.");
            } else {
                global.player_instance.action_state = "sit";
                global.player_instance.action_timer = 0;
                global.player_instance.action_duration = -1;
                global.player_instance.image_index = 0;
                show_debug_message("Started sitting via HUD.");
            }
        }
        global.click_handled = true;
    }
        // Dance action
        else if (point_in_rectangle(mx, my, special_x + 1 * ui_scale, special_y + 1 * ui_scale, special_x + 16 * ui_scale, special_y + 24 * ui_scale)) {
            obj_player.action_state = "dance";
            obj_player.action_timer = 0;
            obj_player.action_duration = 224; // 56 frames * 4 steps (0.25 speed)
            obj_player.image_index = 0;
            show_debug_message("Dance action triggered");
            global.is_special_actions_open = false;
            global.is_expanded = false;
            instance_destroy();
        }
    }
}
}

//show_debug_message("obj_hud_expanded is_active = " + string(is_active));
//show_debug_message("obj_hud_expanded exists: " + string(instance_exists(obj_hud_expanded)));
// Keep existing depth setting
depth = -1000;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck
File: Create_0.gml
// Sprite definitions
sprite_base = spr_icetruck_base_empty;
sprite_colour = spr_icetruck_colour;
sprite_window = spr_icetruck_window;
icetruck_tint = c_yellow; // Default tint
mask_index = spr_icetruck_down; // For collision detection

// Existing state variables
repair_required = false;
is_driveable = true;
is_savable = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck
File: Destroy_0.gml
instance_destroy(); // Destroy the current ice truck instance
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck
File: Draw_0.gml
// Define drawing position and frame (static, facing DOWN)
var draw_x = x;
var draw_y = y;
var frame_x = 0; // Assuming DOWN direction
var frame_y = 0;
var frame_width = 48;
var frame_height = 48;

depth = -1000; // Maintain existing depth

// Draw layered sprites
draw_sprite_part(sprite_base, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y);
draw_sprite_part_ext(sprite_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, icetruck_tint, 1);
draw_sprite_part(sprite_window, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y);

// Display interaction prompt when player is close
if (distance_to_object(global.player_instance) < 16 && global.current_skin == "player") {
    var text = "Press 'E' to drive";
    var text_width = string_width(text);
    draw_set_font(fnt_earlygb);
    draw_set_color(c_black);
    draw_text(x + (sprite_width / 2) - (text_width / 2), y - 20, text);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck
File: Step_0.gml
// Ensure the truck is repaired before allowing entry
if (!repair_required) { 
    if (keyboard_check_pressed(ord("E")) && distance_to_object(global.player_instance) < 32) {
        if (global.current_skin == "player") {
            // Enter the ice truck
            var player_x = global.player_instance.x;
            var player_y = global.player_instance.y;

            instance_destroy(global.player_instance); // Remove player
            instance_destroy(id); // Remove icetruck

            global.player_instance = instance_create_layer(player_x, player_y, "Instances", obj_player_icetruck);
            global.current_skin = "icetruck";

            show_debug_message("Entered ice truck. Current skin: " + global.current_skin);
        }
    }
} else {
    show_debug_message("The truck is still broken! Repair it first.");
}

// Ensure correct depth
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Alarm_0.gml
global.repair_cooldown = false;
show_debug_message("Repair cooldown ended. You can now enter the truck.");

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Alarm_1.gml
show_debug_message("DEBUG: Resetting repair flag...");
global.repair_complete = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Create_0.gml
// Sprite definitions
sprite_base = spr_icetruck_base_empty_repairable;
sprite_colour = spr_icetruck_colour;
sprite_window = spr_icetruck_window;
icetruck_tint = c_yellow; // Default tint, consistent with obj_player_icetruck
mask_index = spr_icetruck_facedown; // For collision detection

// Existing state variables
repair_required = true;
repair_complete = false;
global.repair_complete = false;
is_driveable = false;

alarm[1] = 5; // Keep the repair flag active for 5 frames
is_savable = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Destroy_0.gml
instance_destroy(); // Destroy the current ice truck instance
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Draw_0.gml
// Define drawing position and frame (static, facing DOWN)
var draw_x = x;
var draw_y = y;
var frame_x = 0; // Assuming frame 0 is the DOWN direction
var frame_y = 0;
var frame_width = 48; // Match sprite sheet dimensions
var frame_height = 48;

depth = -1000; // Maintain existing depth

// Draw layered sprites
draw_sprite_part(sprite_base, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y);
draw_sprite_part_ext(sprite_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, icetruck_tint, 1);
draw_sprite_part(sprite_window, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y);

// Display repair prompt if player is near
if (distance_to_object(obj_player) < 24) {
    draw_set_font(fnt_earlygb);
    draw_set_color(c_black);
    draw_text(x - 20, y - 20, "Press 'R' to repair");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Step_0.gml
// Ensure player is near and pressing "R" to repair
if (keyboard_check_pressed(ord("R")) && instance_exists(obj_player) && distance_to_object(obj_player) < 16) {
    // Check inventory using the centralized method
    if (instance_exists(obj_inventory) && (obj_inventory.inventory_has("Wrench") || obj_inventory.inventory_has("Battery"))) {

        show_debug_message("Repairing ice truck...");

        // NOTE: Item removal should ideally happen *here* or be triggered by the truck becoming obj_icetruck
        // We'll leave the removal logic in obj_inventory's Step for now based on global.repair_complete,
        // but ideally, the truck itself should signal which item was consumed.
        // For now, we set the flag that obj_inventory looks for.
        global.repair_complete = true;
         show_debug_message("DEBUG: Setting global.repair_complete = true in obj_icetruck_broken");


        // Destroy the broken truck
        instance_destroy();

        // Replace with repaired version
        var new_truck = instance_create_layer(x, y, "Instances", obj_icetruck);
        new_truck.repair_required = false;
        // new_truck.repair_complete = true; // Redundant if global flag is used
        new_truck.is_driveable = true;

        // Prevent instant entry
        // global.repair_cooldown = true; // Manage cooldown if needed
        // alarm[0] = 30;

        show_debug_message("Ice truck repaired! It is now driveable.");

    } else {
        show_debug_message("You need a Wrench or a Battery to repair this!");
        if (instance_exists(obj_inventory)) {
            show_debug_message("Has Wrench: " + string(obj_inventory.inventory_has("Wrench"))); // Use new method
            show_debug_message("Has Battery: " + string(obj_inventory.inventory_has("Battery"))); // Use new method
        } else {
             show_debug_message("ERROR: obj_inventory instance not found for repair check!");
        }
    }
}
// Ensure correct depth
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Create_0.gml
// Create Event
scale = 2; // Adjust as needed
panel_width = sprite_get_width(spr_colourpicker_panel) * scale;
panel_height = sprite_get_height(spr_colourpicker_panel) * scale;
x = (display_get_gui_width() - panel_width) / 2;
y = (display_get_gui_height() - panel_height) / 2;
depth = -10000;

// Define colors (unchanged)
var c_notblack = make_color_rgb(51, 59, 70);
var c_bluer = make_color_rgb(41, 82, 172);
var c_brown = make_color_rgb(150, 102, 36);
var c_cyan = make_color_rgb(7, 167, 163);
var c_emerald = make_color_rgb(7, 106, 68);
var c_greener = make_color_rgb(6, 155, 77);
var c_lavender = make_color_rgb(176, 126, 194);
var c_lightblue = make_color_rgb(8, 153, 211);
var c_mint = make_color_rgb(189, 252, 201);
var c_oranger = make_color_rgb(232, 94, 28);
var c_pink = make_color_rgb(234, 20, 160);
var c_purpler = make_color_rgb(102, 49, 158);
var c_reder = make_color_rgb(210, 13, 48);
var c_salmon = make_color_rgb(233, 98, 110);
var c_yellower = make_color_rgb(234, 194, 25);

colors = [
    c_notblack, c_bluer, c_brown, c_cyan, c_emerald,
    c_greener, c_lavender, c_lightblue, c_mint, c_oranger,
    c_pink, c_purpler, c_reder, c_salmon, c_yellower
];

// Grid positioning
var grid_width = (5 * 20 + 4 * 5) * scale;
var grid_height = (3 * 20 + 2 * 5) * scale;
start_x = x + 108 * scale + (135 * scale - grid_width) / 2;
start_y = y + 35 * scale + (115 * scale - grid_height) / 2;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Destroy_0.gml
// Destroy Event for obj_icetruck_colourpicker
show_debug_message("Icetruck colourpicker destroyed.");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Draw_64.gml
// Draw GUI Event
draw_sprite_ext(spr_colourpicker_panel, 0, x, y, scale, scale, 0, c_white, 1);

// Viewer
var viewer_x = x + 9 * scale;
var viewer_y = y + 35 * scale;
var viewer_width = (83 - 9) * scale;
var viewer_height = (150 - 35) * scale;
var scale_preview = min(viewer_width / 48, viewer_height / 48) * scale;
var tint = instance_exists(obj_player_icetruck) ? obj_player_icetruck.icetruck_tint : c_white;
draw_sprite_part_ext(spr_icetruck_base, 0, 48, 48, 48, 48, viewer_x + viewer_width / 2 - 24 * scale_preview, viewer_y + viewer_height / 2 - 24 * scale_preview, scale_preview, scale_preview, c_white, 1);
draw_sprite_part_ext(spr_icetruck_colour, 0, 48, 48, 48, 48, viewer_x + viewer_width / 2 - 24 * scale_preview, viewer_y + viewer_height / 2 - 24 * scale_preview, scale_preview, scale_preview, tint, 1);

// Color previews
var scale_icon = (20 * scale) / 48;
for (var i = 0; i < 15; i++) {
    var col = i mod 5;
    var row = i div 5;
    var icon_x = start_x + col * 25 * scale;
    var icon_y = start_y + row * 25 * scale;
    draw_sprite_part_ext(spr_icetruck_base, 0, 48, 48, 48, 48, icon_x, icon_y, scale_icon, scale_icon, c_white, 1);
    draw_sprite_part_ext(spr_icetruck_colour, 0, 48, 48, 48, 48, icon_x, icon_y, scale_icon, scale_icon, colors[i], 1);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Mouse_4.gml
// Mouse Pressed Event for obj_icetruck_colourpicker
var mx = device_mouse_x_to_gui(0);
var my = device_mouse_y_to_gui(0);

for (var i = 0; i < array_length(colour_slots[i]); i++) {
    var slot_x = x + slot_positions[i][0];
    var slot_y = y + slot_positions[i][1];
    if (point_in_rectangle(mx, my, slot_x, slot_y, slot_x + 17, slot_y + 17)) {
        if (instance_exists(obj_player_icetruck)) {
            obj_player_icetruck.icetruck_tint = color_options[i];
            show_debug_message("Ice truck color changed to: " + string(color_options[i]));
        }
        break;
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Step_0.gml
// Step Event
if (mouse_check_button_pressed(mb_left)) {
    var mx = device_mouse_x_to_gui(0);
    var my = device_mouse_y_to_gui(0);
    
    // Close area
    if (point_in_rectangle(mx, my, x + 98 * scale, y + 1 * scale, x + 156 * scale, y + 11 * scale)) {
        instance_destroy();
        show_debug_message("Icetruck color picker closed.");
        global.ui_manager.close_ui();
        global.click_handled = true;
        return;
    }
    
    // Color selection
    for (var i = 0; i < 15; i++) {
        var col = i mod 5;
        var row = i div 5;
        var icon_x = start_x + col * 25;
        var icon_y = start_y + row * 25;
        if (point_in_rectangle(mx, my, icon_x, icon_y, icon_x + 20, icon_y + 20)) {
            if (instance_exists(obj_player_icetruck)) {
                obj_player_icetruck.icetruck_tint = colors[i];
                show_debug_message("Icetruck tint set to: " + string(colors[i]));
            } else {
                show_debug_message("No icetruck instance found to set tint.");
            }
            instance_destroy();
            global.ui_manager.close_ui();
            global.click_handled = true;
            break;
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_initializer
File: Create_0.gml
/// Create Event for obj_initializer
show_debug_message("DEBUG: obj_initializer Create Event START");

// Prevent running initialization if we are loading a game
if (variable_global_exists("is_loading_game") && global.is_loading_game == true) {
    show_debug_message("Skipping obj_initializer Create Event during game load.");
    exit; // Stop the event here
}

// Initialize following_puffles
if (!variable_global_exists("following_puffles") || !ds_exists(global.following_puffles, ds_type_list)) {
    global.following_puffles = ds_list_create();
    show_debug_message("DEBUG: global.following_puffles initialized.");
} else {
     show_debug_message("DEBUG: global.following_puffles already exists.");
}

// Initialize equipped_items map
if (!variable_global_exists("equipped_items") || !ds_exists(global.equipped_items, ds_type_map)) {
    global.equipped_items = ds_map_create();
    ds_map_add(global.equipped_items, "head", -1); // -1 indicates empty slot
    ds_map_add(global.equipped_items, "face", -1);
    ds_map_add(global.equipped_items, "neck", -1); // Added neck slot for completeness
    ds_map_add(global.equipped_items, "body", -1);
    ds_map_add(global.equipped_items, "hand", -1); // Added hand slot for completeness
    ds_map_add(global.equipped_items, "feet", -1); // Added feet slot for completeness
show_debug_message("DEBUG: global.equipped_items initialized in obj_initializer."); // Adjust message if moved
} else {
    show_debug_message("DEBUG: global.equipped_items already exists.");
}
if (!variable_global_exists("inventory_expanded")) {
    global.inventory_expanded = false;
    show_debug_message("DEBUG: global.inventory_expanded initialized.");
}
if (!instance_exists(obj_inventory)) {
    instance_create_layer(0, 0, "Instances", obj_inventory);
    show_debug_message("DEBUG: obj_inventory created.");
}
if (!instance_exists(obj_map_icon)) {
    instance_create_layer(0, 0, "Instances", obj_map_icon);
    show_debug_message("DEBUG: obj_map_icon created.");
}

// Initialize game_paused flag
if (!variable_global_exists("game_paused")) {
    global.game_paused = false;
    show_debug_message("DEBUG: global.game_paused initialized.");
}

// Initialize player visibility flags for hats (might be obsolete if using equipped_items map properly)
if (!variable_global_exists("party_hat_visible")) {
    global.party_hat_visible = false;
    show_debug_message("DEBUG: global.party_hat_visible initialized.");
}
if (!variable_global_exists("beta_hat_visible")) {
    global.beta_hat_visible = false;
    show_debug_message("DEBUG: global.beta_hat_visible initialized.");
}

// Initialize the global camera
if (!variable_global_exists("camera") || !is_real(global.camera)) {
    global.camera = camera_create();
    // Set initial camera properties if needed, e.g., size
    camera_set_view_size(global.camera, 288, 216); // Example size
    camera_set_view_pos(global.camera, 0, 0);
    show_debug_message("DEBUG: New global camera created.");
}
// Always ensure the view uses the global camera
if (view_get_camera(0) != global.camera) {
     view_set_camera(0, global.camera);
     show_debug_message("DEBUG: View 0 assigned to global camera.");
}


// Ensure global player instance reference is managed (best handled by obj_controller)
if (!variable_global_exists("player_instance")) {
    global.player_instance = noone;
    show_debug_message("DEBUG: global.player_instance initialized to noone.");
}

// Initialize icetruck colour picker flag
if (!variable_global_exists("colour_picker_active")) {
    global.colour_picker_active = false;
    show_debug_message("DEBUG: global.colour_picker_active initialized.");
}

show_debug_message("DEBUG: obj_initializer Create Event FINISHED");

// (Self-destruct or deactivate after initialization if desired)
// instance_destroy();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_initializer
File: Other_2.gml
// Initialize all required global variables
global.player_instance = noone;
global.player_instance_initialized = false;
global.camera = noone;
global.current_skin = "player"; // Default skin
global.initialized = false; // To track overall initialization

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_initializer
File: Step_0.gml

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory
File: Create_0.gml
// --- obj_inventory: Create Event ---
inventory_size = INVENTORY_SIZE; // Use the macro instead of hardcoded 42
inventory = array_create(inventory_size, -1); // Uses the variable set above
active_slot = 0;
global.active_item_index = active_slot; // Consider if this global is still needed or if obj_inventory should manage it
persistent = true;
global.is_expanded = false;             // Track expanded state (might move to UI manager later)
global.is_special_actions_open = false; // Track special actions state (might move to UI manager later)

show_debug_message("obj_inventory Create: Initialized with size " + string(inventory_size));

// --- NEW: Inventory Management Methods ---

/// @function inventory_has(item_name)
/// @description Checks if the inventory contains the specified item.
/// @param {string} item_name The name of the item to check for.
/// @returns {bool} True if the item exists, false otherwise.
inventory_has = function(item_name) {
    // Safety check for item data maps
    if (!ds_exists(global.item_index_map, ds_type_map)) {
        show_debug_message("ERROR (inventory_has): global.item_index_map missing!");
        return false;
    }
    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index) || item_index == -1) {
        // show_debug_message("DEBUG (inventory_has): Item '" + item_name + "' not found in index map.");
        return false; // Item name doesn't exist in our known items
    }
    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == item_index) {
            return true;
        }
    }
    return false;
}

/// @function inventory_add(item_name)
/// @description Adds an item to the first available inventory slot.
/// @param {string} item_name The name of the item to add.
/// @returns {bool} True if added successfully, false otherwise (e.g., full or invalid item).
inventory_add = function(item_name) {
    // Safety check for item data maps
    if (!ds_exists(global.item_index_map, ds_type_map)) {
        show_debug_message("ERROR (inventory_add): global.item_index_map missing!");
        return false;
    }

    // Don't add if already present (optional, based on your game design)
    // if (inventory_has(item_name)) {
    //     show_debug_message("INFO (inventory_add): Item '" + item_name + "' already in inventory.");
    //     return false; // Or maybe return true if stacking is allowed later
    // }

    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index) || item_index == -1) {
        show_debug_message("ERROR (inventory_add): Invalid item name '" + item_name + "'");
        return false;
    }

    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == -1) { // Find first empty slot (-1)
            inventory[i] = item_index;
            show_debug_message("Inventory: Added '" + item_name + "' (Index: " + string(item_index) + ") to slot " + string(i));
            // Optional: Update active item if needed
            // global.active_item_index = inventory[active_slot];
            // Quest System Notification (Example - refine later)
            event_user(0); // Trigger User Event 0 for quest checks
            return true;
        }
    }

    show_debug_message("Inventory: Full. Cannot add '" + item_name + "'.");
    return false;
}

/// @function inventory_remove(item_name)
/// @description Removes the first instance of an item from the inventory.
/// @param {string} item_name The name of the item to remove.
/// @returns {bool} True if removed successfully, false otherwise (e.g., not found or invalid item).
inventory_remove = function(item_name) {
    // Safety check for item data maps
    if (!ds_exists(global.item_index_map, ds_type_map)) {
        show_debug_message("ERROR (inventory_remove): global.item_index_map missing!");
        return false;
    }

    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index) || item_index == -1) {
        show_debug_message("ERROR (inventory_remove): Invalid item name '" + item_name + "'");
        return false;
    }

    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == item_index) {
            var removed_from_slot = i;
            inventory[i] = -1; // Mark slot as empty
            show_debug_message("Inventory: Removed '" + item_name + "' (Index: " + string(item_index) + ") from slot " + string(removed_from_slot));
            // Optional: Update active item if the removed item was active
            if (removed_from_slot == active_slot) {
                global.active_item_index = -1; // Or inventory[active_slot] which is now -1
            }
             // Quest System Notification (Example - refine later)
            event_user(0); // Trigger User Event 0 for quest checks
            return true;
        }
    }

    show_debug_message("Inventory: Item '" + item_name + "' not found for removal.");
    return false;
}

/// @function inventory_get_item_count(item_name)
/// @description Counts how many of a specific item are in the inventory.
/// @param {string} item_name The name of the item to count.
/// @returns {int} The number of instances of the item found.
inventory_get_item_count = function(item_name) {
    if (!ds_exists(global.item_index_map, ds_type_map)) {
        show_debug_message("ERROR (inventory_get_item_count): global.item_index_map missing!");
        return 0;
    }
    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index) || item_index == -1) return 0;

    var count = 0;
    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == item_index) {
            count++;
        }
    }
    return count;
}


/// @function inventory_drop_active_item()
/// @description Drops the item currently in the active slot into the game world.
inventory_drop_active_item = function() {
    var item_index_to_drop = inventory[active_slot];
    if (item_index_to_drop == -1) {
        show_debug_message("Inventory: No item in active slot (" + string(active_slot) + ") to drop.");
        return;
    }

    // Safety check for item data maps
    if (!ds_exists(global.item_index_map, ds_type_map) || !ds_exists(global.item_object_map, ds_type_map)) {
         show_debug_message("ERROR (inventory_drop_active_item): Item data maps missing!");
         return;
    }

    // Find the item name from the index value
    var item_name = "";
    var map_keys = ds_map_keys_to_array(global.item_index_map);
    for (var k = 0; k < array_length(map_keys); k++) {
        if (ds_map_find_value(global.item_index_map, map_keys[k]) == item_index_to_drop) {
            item_name = map_keys[k];
            break;
        }
    }

    if (item_name == "") {
        show_debug_message("ERROR (inventory_drop_active_item): Could not find item name for index " + string(item_index_to_drop));
        return;
    }

    // Find the corresponding object to create
    var dropped_object = ds_map_find_value(global.item_object_map, item_name);

    // Find the player instance safely
    var _player = global.player_instance;
    if (!instance_exists(_player)) {
        show_debug_message("ERROR (inventory_drop_active_item): Player instance not found. Cannot drop item.");
        return; // Cannot drop if player doesn't exist
    }

    // Create the dropped item instance
    var drop_x = _player.x;
    var drop_y = _player.y;

    if (!is_undefined(dropped_object) && object_exists(dropped_object)) {
        var dropped_item = instance_create_layer(drop_x, drop_y, "Instances", dropped_object);
        // dropped_item.item_name = item_name; // Item object should set its own name in Create event
        show_debug_message("Inventory: Dropped '" + item_name + "' as " + object_get_name(dropped_object) + " at (" + string(drop_x) + ", " + string(drop_y) + ")");
    } else {
        show_debug_message("WARNING (inventory_drop_active_item): No valid object mapped for '" + item_name + "'. Dropping generic obj_dropped_item.");
        // Fallback to generic dropped item if specific object is missing
        var dropped_item = instance_create_layer(drop_x, drop_y, "Instances", obj_dropped_item);
        // We need to tell the generic item *what* it is
        if (variable_instance_exists(dropped_item, "item_type")) { // Assuming obj_dropped_item uses 'item_type'
             dropped_item.item_type = item_name;
        } else {
             show_debug_message("ERROR: obj_dropped_item has no 'item_type' variable!");
        }
    }

    // Remove the item from the inventory slot
    inventory[active_slot] = -1;
    show_debug_message("Inventory: Removed '" + item_name + "' from slot " + string(active_slot) + " after dropping.");
    global.active_item_index = -1; // Update active item index
}

// REMOVE the old get_item_type function, it's not needed directly by inventory anymore
// get_item_type = function(item_name) { ... }


// --- Initialize Example Item ---
// inventory_add("Beta Hat"); // Example: Add beta hat on creation for testing
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory
File: Draw_64.gml
// In obj_inventory Draw GUI Event
if (instance_exists(id)) {
    if (visible) {
        var ui_scale = 3;
        var gui_width = display_get_gui_width();
        var gui_height = display_get_gui_height();
        var inv_width = sprite_get_width(spr_inventory_ui) * ui_scale;
        var inv_height = sprite_get_height(spr_inventory_ui) * ui_scale;
        var inv_x = (gui_width - inv_width) / 2;
        var inv_y = gui_height - inv_height + 0 * ui_scale;

        if (!global.is_expanded) {
            draw_sprite_ext(spr_inventory_ui, 0, inv_x, inv_y, ui_scale, ui_scale, 0, c_white, 1);

            // Update slot positions
            var slot_positions = [
                [inv_x + 5 * ui_scale, inv_y + 14 * ui_scale],
                [inv_x + 25 * ui_scale, inv_y + 14 * ui_scale],
                [inv_x + 45 * ui_scale, inv_y + 14 * ui_scale],
                [inv_x + 65 * ui_scale, inv_y + 14 * ui_scale],
                [inv_x + 85 * ui_scale, inv_y + 14 * ui_scale],
                [inv_x + 105 * ui_scale, inv_y + 14 * ui_scale],
                [inv_x + 125 * ui_scale, inv_y + 14 * ui_scale],
                [inv_x + 145 * ui_scale, inv_y + 14 * ui_scale]
            ];

            // Draw inventory items
            for (var i = 0; i < 8; i++) {
                if (!is_undefined(inventory[i]) && inventory[i] != -1) { // Skip empty slots
                    var slot_x = slot_positions[i][0];
                    var slot_y = slot_positions[i][1];
                    var item_index = inventory[i];
                    var x_offset, y_offset;
                    if (item_index < 21) { // First row: items 0–20
                        x_offset = item_index * 18;
                        y_offset = 0;
                    } else { // Second row: items 21–24
                        x_offset = (item_index - 21) * 18;
                        y_offset = 18;
                    }
                    draw_sprite_part_ext(spr_inventory_items, 0, x_offset, y_offset, 18, 18, slot_x, slot_y, ui_scale, ui_scale, c_white, 1);
                    if (i == active_slot) {
                        draw_sprite_ext(spr_inventory_highlight, 0, slot_x - 1 * ui_scale, slot_y - 1 * ui_scale, ui_scale, ui_scale, 0, c_white, 1);
                    }
                }
            }
        }

        // Click detection to open expanded HUD
        if (mouse_check_button_pressed(mb_left) && !instance_exists(obj_hud_expanded)) {
            var click_area_left = inv_x + 54 * ui_scale;
            var click_area_top = inv_y + 2 * ui_scale;
            var click_area_right = inv_x + 112 * ui_scale;
            var click_area_bottom = inv_y + 9 * ui_scale;
            var gui_mouse_x = device_mouse_x_to_gui(0);
            var gui_mouse_y = device_mouse_y_to_gui(0);
            if (gui_mouse_x >= click_area_left && gui_mouse_x <= click_area_right &&
                gui_mouse_y >= click_area_top && gui_mouse_y <= click_area_bottom) {
                global.is_expanded = true;
                instance_create_layer(0, 0, "Instances", obj_hud_expanded);
                show_debug_message("Expanded HUD opened - global.is_expanded set to true");
            }
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory
File: Other_10.gml
// --- obj_inventory: User Event 0 ---
// This event is triggered when inventory changes (add/remove).
// Quest system or other listeners can check inventory state here.
// show_debug_message("Inventory User Event 0 Triggered: Inventory Changed.");

// Example: Notify a Quest Manager (if one exists)
// if (instance_exists(obj_quest_manager)) {
//     obj_quest_manager.check_collect_objectives();
// }
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory
File: Step_0.gml
// --- obj_inventory: Step Event ---
if (global.chat_active || global.is_pause_menu_active || global.game_paused) exit;

// --- Handle Input ---
// Scroll through inventory slots (QoL Update: Skip Empty Slots)
var scroll = mouse_wheel_down() - mouse_wheel_up(); // 1 for down, -1 for up, 0 for none

if (scroll != 0) {
    var original_slot = active_slot;
    var current_check_slot = active_slot;
    var max_slots = 8; // Number of slots in the quick bar
    var attempts = 0; // Prevent infinite loop if inventory is empty

    // Loop to find the next/previous non-empty slot
    repeat (max_slots) { // Check each slot at most once
        current_check_slot = (current_check_slot - scroll + max_slots) % max_slots; // Move in scroll direction, wrap around

        // Check if the slot index is valid for the underlying inventory array
        // And if the slot is not empty (-1)
        if (current_check_slot < inventory_size && inventory[current_check_slot] != -1) {
            active_slot = current_check_slot; // Found a valid slot
            break; // Exit the loop
        }

         attempts++;
         if(attempts >= max_slots) break; // Stop if we checked all slots (likely all empty)

    } // End repeat loop

    // Update global tracker only if the slot actually changed
    if (active_slot != original_slot) {
        global.active_item_index = inventory[active_slot];
        show_debug_message("Inventory QoL Scroll: Active slot changed to " + string(active_slot) + ", Item Index: " + string(global.active_item_index));
    } else {
         // Optional: Add a small sound or visual feedback if no other item found?
         // show_debug_message("Inventory QoL Scroll: No other items found.");
    }
} // End if (scroll != 0)

// Drop item
if (keyboard_check_pressed(ord("F"))) {
    inventory_drop_active_item();
}

// --- Item Usage Logic ---
// Remove the used item from inventory (Example: Repair Truck)
// NOTE: The condition `global.repair_complete` should be set by the truck object itself when repair happens.
// This logic might be better placed in the truck's interaction code.
if (keyboard_check_pressed(ord("R")) && variable_global_exists("repair_complete") && global.repair_complete) {
    show_debug_message("Inventory Check: Repair triggered ('R' pressed and repair_complete=true)");
    if (inventory_has("Battery")) { // Use new method
        show_debug_message("Inventory: Attempting to remove Battery for repair...");
        inventory_remove("Battery"); // Use new method
    } else if (inventory_has("Wrench")) { // Example if Wrench was used
         show_debug_message("Inventory: Attempting to remove Wrench for repair...");
         inventory_remove("Wrench"); // Use new method
    } else {
        show_debug_message("Inventory: Neither Battery nor Wrench found for repair completion.");
    }
    global.repair_complete = false; // Consume the flag? Decide where this flag is best managed.
}

// Enter/Exit Tube
if (keyboard_check_pressed(ord("T")) && instance_exists(obj_controller)) {
     if (global.current_skin == "player" && inventory_has("Tube")) { // Use new method
         if (obj_controller.switch_skin("tube")) { // Check if switch was successful
             inventory_remove("Tube"); // Use new method
             show_debug_message("Inventory: Removed Tube after switching to tube skin.");
         }
     } else if (global.current_skin == "tube") {
          if (obj_controller.switch_skin("player")) { // Check if switch was successful
              inventory_add("Tube"); // Add it back - Use new method
              show_debug_message("Inventory: Added Tube back after switching to player skin.");
          }
     }
}

// Enter/Exit Toboggan (Similar logic to Tube)
if (keyboard_check_pressed(ord("T")) && instance_exists(obj_controller)) { // Using 'T' again might conflict, consider different key
    if (global.current_skin == "player" && inventory_has("Toboggan")) { // Use new method
        if (obj_controller.switch_skin("toboggan")) {
             inventory_remove("Toboggan"); // Use new method
             show_debug_message("Inventory: Removed Toboggan after switching to toboggan skin.");
        }
    } else if (global.current_skin == "toboggan") {
         if (obj_controller.switch_skin("player")) {
             inventory_add("Toboggan"); // Use new method
             show_debug_message("Inventory: Added Toboggan back after switching to player skin.");
         }
    }
}


// --- Depth Setting ---
depth = -1000; // Ensure UI layering

// --- Quest Notification Trigger (User Event 0) ---
// Call this if any inventory change might affect quest objectives
// Example: event_user(0);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Create_0.gml
// obj_inventory_expanded: Create Event
global.game_paused = true;
depth = -10000;

// Default inventory states
global.inventory_open_state = "closed"; // Inventory starts in the closed state
global.inventory_visible = true; // Both sprites are visible by default

// Character variables
character_face = DOWN; // Default direction
character_action = "none"; // Default no action
character_image_index = 0; // Default animation frame

// Inventory grid specifications
var grid_start = [3, 6];
var grid_size = [7, 6];
var slot_width = 20;
var slot_height = 20;

// Create a 2D array to hold the inventory slots
inventory_slots = array_create(grid_size[1], array_create(grid_size[0], -1));

// Populate the inventory_slots with coordinates and slot indices
for (var row = 0; row < grid_size[1]; row++) {
    for (var col = 0; col < grid_size[0]; col++) {
        var slot_index = row * grid_size[0] + col + 1; // Slot indices start from 1
        var x1 = grid_start[0] + col * slot_width;
        var y1 = grid_start[1] + row * slot_height;
        var x2 = x1 + slot_width;
        var y2 = y1 + slot_height;
        
        inventory_slots[row][col] = {
            index: slot_index,
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
        };
        
        show_debug_message("Slot " + string(slot_index) + ": (" + string(x1) + ", " + string(y1) + ") to (" + string(x2) + ", " + string(y2) + ")");
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Destroy_0.gml
// obj_inventory_expanded: Destroy Event
global.game_paused = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Draw_64.gml
// obj_inventory_expanded Draw GUI
var ui_scale = 2.2;

// GUI dimensions
var gui_width = display_get_gui_width();
var gui_height = display_get_gui_height();

// Closed inventory positioning
var closed_width = sprite_get_width(spr_inventory_closed) * ui_scale;
var closed_height = sprite_get_height(spr_inventory_closed) * ui_scale;
var closed_x = (gui_width / 2) - closed_width - 0; // Adjust X position if needed
var closed_y = (gui_height - closed_height) / 2;

// Open inventory positioning
var open_width = sprite_get_width(spr_inventory_open) * ui_scale;
var open_height = sprite_get_height(spr_inventory_open) * ui_scale;
var open_x = closed_x + closed_width - 35; // Adjust X based on sprite overlap/origin
var open_y = closed_y + 21; // Align vertically with closed part

// Draw sprites based on inventory state
if (global.inventory_visible) {
    // --- Draw Closed Panel ---
    draw_sprite_ext(spr_inventory_closed, 0, closed_x, closed_y, ui_scale, ui_scale, 0, c_white, 1);

    // --- Draw Equipped Item Icons in Clothing Slots (on Closed Panel) ---
    var clothing_slots_rel = [[9, 20], [9, 40], [9, 60], [9, 80], [9, 100], [9, 120]]; // Relative positions
    var slot_types = ["head", "face", "neck", "body", "hand", "feet"];
    var slot_pixel_size = 18 * ui_scale; // Visual size of the slot

    // Safety check for maps
    var equipped_map_exists = ds_exists(global.equipped_items, ds_type_map);
    var index_map_exists = ds_exists(global.item_index_map, ds_type_map);

    if (!equipped_map_exists) { show_debug_message("Draw GUI Error: global.equipped_items missing!"); }
    if (!index_map_exists) { show_debug_message("Draw GUI Error: global.item_index_map missing!"); }

    //show_debug_message("--- Drawing Equipped Slots ---"); // Log start of drawing equipped slots

    for (var i = 0; i < array_length(slot_types); i++) {
        var current_slot_type = slot_types[i];
        var slot_screen_x = closed_x + clothing_slots_rel[i][0] * ui_scale;
        var slot_screen_y = closed_y + clothing_slots_rel[i][1] * ui_scale;
        var item_name = -1; // Default to empty

        // Safely get item name from the map
        if (equipped_map_exists && ds_map_exists(global.equipped_items, current_slot_type)) {
             item_name = global.equipped_items[? current_slot_type];
        } else if (equipped_map_exists) {
             // This case means the slot itself doesn't exist in the map, which is an init error
             show_debug_message("Draw GUI Warning: Slot '" + current_slot_type + "' not found in global.equipped_items map!");
        }

        // ** ADDED DEBUGGING **
        //show_debug_message("Draw GUI: Checking slot '" + current_slot_type + "'. Found item name: " + string(item_name));

        if (!is_undefined(item_name) && item_name != -1) { // Check if slot has an item name
            var item_index_val = -1;
            // Safely get item index from name
            if (index_map_exists && ds_map_exists(global.item_index_map, item_name)) {
                 item_index_val = ds_map_find_value(global.item_index_map, item_name);
            } else if (index_map_exists) {
                 show_debug_message("Draw GUI Warning: Item name '" + item_name + "' not found in global.item_index_map!");
            }

             // ** ADDED DEBUGGING **
             show_debug_message("Draw GUI: Item '" + item_name + "' corresponds to index value: " + string(item_index_val));

            if (!is_undefined(item_index_val) && item_index_val != -1) {
                // Calculate sprite sheet offsets for spr_inventory_items
                var x_offset = (item_index_val < 21) ? item_index_val * 18 : (item_index_val - 21) * 18;
                var y_offset = (item_index_val < 21) ? 0 : 18; // Assuming second row starts at index 21
                var item_icon_width = 18;
                var item_icon_height = 18;

                 // ** ADDED DEBUGGING **
                 show_debug_message("Draw GUI: Drawing icon for '" + item_name + "' (Index: " + string(item_index_val) + ") at slot '" + current_slot_type + "'");

                // Draw the item icon using sprite part
                draw_sprite_part_ext(spr_inventory_items, 0,
                                     x_offset, y_offset, item_icon_width, item_icon_height,
                                     slot_screen_x, slot_screen_y,
                                     ui_scale, ui_scale, // Apply scale to the drawn part
                                     c_white, 1);
            } else {
                // This else block was previously inside the item_name != -1 check, moved out
                // show_debug_message("Draw GUI: No valid item index for name '" + string(item_name) + "' in slot: " + current_slot_type);
            }
        } else {
             // ** ADDED DEBUGGING ** (This message confirms the slot is seen as empty by Draw GUI)
             // show_debug_message("Draw GUI: No item equipped or name is invalid (-1 or undefined) in slot: " + current_slot_type);
        }
    }
     //show_debug_message("--- Finished Drawing Equipped Slots ---"); // Log end

    // --- Draw Character Viewer (Keep as is) ---
    var viewer_left = closed_x + 31 * ui_scale;
    var viewer_top = closed_y + 21 * ui_scale;
    var viewer_width = (105 - 31) * ui_scale;
    var viewer_height = (135 - 21) * ui_scale;
    var char_scale = 3; // Adjusted scale for better visibility in viewer
    var frame_width = 24;
    var frame_height = 24;
    var scaled_width = frame_width * char_scale;
    var scaled_height = frame_height * char_scale;
    var draw_char_x = viewer_left + (viewer_width - scaled_width) / 2;
    var draw_char_y = viewer_top + (viewer_height - scaled_height) / 2;
    var frame_x = 0; // Default DOWN frame for preview
    var frame_y = 0;

    // Simplified preview drawing logic
     if (global.current_skin == "player" || global.current_skin == "tube" || global.current_skin == "toboggan") {
         var body_spr = spr_player_body;
         var color_spr = spr_player_colour;
         if (global.current_skin == "tube" || global.current_skin == "toboggan") {
             frame_y = 72; // Sitting pose Y offset
             var vehicle_spr = (global.current_skin == "tube") ? spr_tube_sheet : spr_toboggan_sheet;
             var vehicle_frame_x = (global.current_skin == "tube") ? 24 : 48; // Example frame for tube/toboggan facing down
             draw_sprite_part_ext(vehicle_spr, 0, vehicle_frame_x, 0, frame_width, frame_height, draw_char_x, draw_char_y, char_scale, char_scale, c_white, 1);
         }
         draw_sprite_part_ext(body_spr, 0, frame_x, frame_y, frame_width, frame_height, draw_char_x, draw_char_y, char_scale, char_scale, c_white, 1);
         draw_sprite_part_ext(color_spr, 0, frame_x, frame_y, frame_width, frame_height, draw_char_x, draw_char_y, char_scale, char_scale, global.player_color, 1);
     } else if (global.current_skin == "icetruck" && instance_exists(obj_player_icetruck)) {
         frame_width = 48; frame_height = 48; // Icetruck sprite size
         scaled_width = frame_width * char_scale; scaled_height = frame_height * char_scale;
         draw_char_x = viewer_left + (viewer_width - scaled_width) / 2;
         draw_char_y = viewer_top + (viewer_height - scaled_height) / 2;
         draw_sprite_part_ext(spr_icetruck_base, 0, frame_x, frame_y, frame_width, frame_height, draw_char_x, draw_char_y, char_scale, char_scale, c_white, 1);
         draw_sprite_part_ext(spr_icetruck_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_char_x, draw_char_y, char_scale, char_scale, obj_player_icetruck.icetruck_tint, 1);
         draw_sprite_part_ext(spr_icetruck_penguin_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_char_x, draw_char_y, char_scale, char_scale, global.player_color, 1);
         draw_sprite_part_ext(spr_icetruck_window, 0, frame_x, frame_y, frame_width, frame_height, draw_char_x, draw_char_y, char_scale, char_scale, c_white, 1);
     }
     // --- Add Drawing for Equipped Items on Preview Character ---
     // Similar logic to obj_player Draw event, but drawing relative to draw_char_x, draw_char_y and using char_scale
     if (ds_exists(global.item_sprite_map, ds_type_map)) {
        var preview_slots = ["body", "face", "head"]; // Slots to show on preview
        for (var j = 0; j < array_length(preview_slots); j++) {
            var slot = preview_slots[j];
            var item_name = global.equipped_items[? slot];
             if (!is_undefined(item_name) && item_name != -1) {
                var item_sprite = ds_map_find_value(global.item_sprite_map, item_name);
                 if (!is_undefined(item_sprite) && sprite_exists(item_sprite)) {
                     // Use simplified drawing for preview - assuming item sprites match player frame structure for DOWN pose
                     var item_frame_x = 0; // Down pose X
                     var item_frame_y = 0; // Down pose Y
                     var item_frame_width = 24; // Assuming 24x24 base
                     var item_frame_height = 24;
                     var item_draw_x = draw_char_x; // Adjust offsets as needed
                     var item_draw_y = draw_char_y;
                      if (slot == "head") item_draw_y -= 0 * char_scale; // Example offset
                      if (slot == "face") item_draw_y -= 0 * char_scale; // Example offset

                     draw_sprite_part_ext(item_sprite, 0, item_frame_x, item_frame_y, item_frame_width, item_frame_height, item_draw_x, item_draw_y, char_scale, char_scale, c_white, 1);
                 }
             }
        }
     }


    // --- Draw Open Panel and Inventory Grid ---
    if (global.inventory_open_state == "open") {
        draw_sprite_ext(spr_inventory_open, 0, open_x, open_y, ui_scale, ui_scale, 0, c_white, 1);

        // Inventory grid parameters
        var grid_start_x_rel = 3;
        var grid_start_y_rel = 6;
        var slot_pixel_width = 20 * ui_scale;
        var slot_pixel_height = 20 * ui_scale;
        var grid_cols = 7;
        var grid_rows = 6;
        var item_icon_width = 18; // Original size in spr_inventory_items
        var item_icon_height = 18;
        var item_scale = ui_scale; // Scale item icons same as UI

        // Draw inventory grid items
        for (var row = 0; row < grid_rows; row++) {
            for (var col = 0; col < grid_cols; col++) {
                var inventory_index = row * grid_cols + col;
                if (inventory_index < array_length(obj_inventory.inventory)) { // Ensure index is within bounds
                    var item_index_val = obj_inventory.inventory[inventory_index]; // Get item numerical index

                    if (item_index_val != -1) { // Check if slot is not empty
                        // Calculate sprite sheet offsets for spr_inventory_items
                        var x_offset = (item_index_val < 21) ? item_index_val * item_icon_width : (item_index_val - 21) * item_icon_width;
                        var y_offset = (item_index_val < 21) ? 0 : item_icon_height; // Assuming second row starts at index 21

                        // Calculate draw position for the item icon
                        var item_draw_x = open_x + grid_start_x_rel * ui_scale + col * slot_pixel_width + (slot_pixel_width - item_icon_width * item_scale) / 2; // Center icon in slot
                        var item_draw_y = open_y + grid_start_y_rel * ui_scale + row * slot_pixel_height + (slot_pixel_height - item_icon_height * item_scale) / 2; // Center icon in slot

                        // Draw the item icon sprite part
                        draw_sprite_part_ext(
                            spr_inventory_items, 0,
                            x_offset, y_offset, item_icon_width, item_icon_height,
                            item_draw_x, item_draw_y,
                            item_scale, item_scale, // Apply scale
                            c_white, 1
                        );
                    }
                }
            }
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Mouse_4.gml
/// Mouse Left Pressed Event for obj_inventory_expanded
/// @function Mouse Left Pressed Event for obj_inventory
var item_index = get_item_index_from_mouse_position(mouse_x, mouse_y);
if (item_index != -1) {
    inventory_click_handler(item_index);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Step_0.gml
// obj_inventory_expanded: Step Event
var ui_scale = 2.2;
var gui_mouse_x = device_mouse_x_to_gui(0);
var gui_mouse_y = device_mouse_y_to_gui(0);

// Positioning Calculations (Keep consistent with Draw Event)
var closed_width = sprite_get_width(spr_inventory_closed) * ui_scale;
var closed_height = sprite_get_height(spr_inventory_closed) * ui_scale;
var closed_x = (display_get_gui_width() / 2) - closed_width - 0;
var closed_y = (display_get_gui_height() - closed_height) / 2;

var open_width = sprite_get_width(spr_inventory_open) * ui_scale;
var open_height = sprite_get_height(spr_inventory_open) * ui_scale;
var open_x = closed_x + closed_width - 35;
var open_y = closed_y;

// Button Click Handling
if (global.inventory_visible && mouse_check_button_pressed(mb_left)) {

    // Open/Close Expanded Inventory Logic (Same as before)
    if (global.inventory_open_state == "closed") {
        var open_left = closed_x + 117 * ui_scale;
        var open_top = closed_y + 61 * ui_scale;
        var open_right = closed_x + 125 * ui_scale;
        var open_bottom = closed_y + 93 * ui_scale;
        if (point_in_rectangle(gui_mouse_x, gui_mouse_y, open_left, open_top, open_right, open_bottom)) {
            show_debug_message("DEBUG: Opening expanded inventory pane.");
            global.inventory_open_state = "open";
            global.click_handled = true;
            exit;
        }
    } else if (global.inventory_open_state == "open") {
        var close_left = open_x + 144 * ui_scale;
        var close_top = open_y + 47 * ui_scale;
        var close_right = open_x + 152 * ui_scale;
        var close_bottom = open_y + 79 * ui_scale;
        if (point_in_rectangle(gui_mouse_x, gui_mouse_y, close_left, close_top, close_right, close_bottom)) {
            show_debug_message("DEBUG: Closing expanded inventory pane.");
            global.inventory_open_state = "closed";
            global.click_handled = true;
            exit;
        }
    }

    // Close All Inventory Button (Same as before)
    var close_all_left = closed_x + 47 * ui_scale;
    var close_all_top = closed_y + 3 * ui_scale;
    var close_all_right = closed_x + 89 * ui_scale;
    var close_all_bottom = closed_y + 11 * ui_scale;
    if (point_in_rectangle(gui_mouse_x, gui_mouse_y, close_all_left, close_all_top, close_all_right, close_all_bottom)) {
        show_debug_message("DEBUG: Closing inventory UI completely.");
        global.inventory_visible = false;
        global.inventory_open_state = "closed";
        global.game_paused = false;
        instance_destroy();
        global.click_handled = true;
        exit;
    }

    // Equip item by clicking on inventory slot (in the OPEN pane)
    if (global.inventory_open_state == "open") {
        var grid_start_x_rel = 3;
        var grid_start_y_rel = 6;
        var slot_pixel_width = 20 * ui_scale;
        var slot_pixel_height = 20 * ui_scale;
        var grid_cols = 7;
        var grid_rows = 6;

        for (var row = 0; row < grid_rows; row++) {
            for (var col = 0; col < grid_cols; col++) {
                var slot_screen_x1 = open_x + grid_start_x_rel * ui_scale + col * slot_pixel_width;
                var slot_screen_y1 = open_y + grid_start_y_rel * ui_scale + row * slot_pixel_height;
                var slot_screen_x2 = slot_screen_x1 + slot_pixel_width;
                var slot_screen_y2 = slot_screen_y1 + slot_pixel_height;

                if (point_in_rectangle(gui_mouse_x, gui_mouse_y, slot_screen_x1, slot_screen_y1, slot_screen_x2, slot_screen_y2)) {
                    show_debug_message("Clicked grid slot (" + string(col) + ", " + string(row) + ")");
                    var inventory_index = row * grid_cols + col;

                    if (inventory_index < array_length(obj_inventory.inventory)) {
                        var item_index_val = obj_inventory.inventory[inventory_index];
                        show_debug_message("Slot " + string(inventory_index) + " contains item index value: " + string(item_index_val));

                        if (item_index_val != -1) {
                            var item_name = "";
                            var map_keys = ds_map_keys_to_array(global.item_index_map);
                            for (var k = 0; k < array_length(map_keys); k++) {
                                if (ds_map_find_value(global.item_index_map, map_keys[k]) == item_index_val) {
                                    item_name = map_keys[k];
                                    break;
                                }
                            }

                            if (item_name != "") {
                                show_debug_message("Item name found: '" + item_name + "'");
                                var item_type = ds_map_find_value(global.item_type_map, item_name);

                                if (!is_undefined(item_type)) {
                                    show_debug_message("Item type: '" + item_type + "'");
                                    if (ds_map_exists(global.equipped_items, item_type)) {
                                        show_debug_message("Attempting to equip '" + item_name + "' to slot '" + item_type + "'");

                                        // 1. Check if something is already equipped
                                        var current_equipped_name = global.equipped_items[? item_type];
                                        if (current_equipped_name != -1 && !is_undefined(current_equipped_name)) {
                                            unequip_item(item_type); // Unequip visually/logically

                                            // *** CRASH FIX HERE ***
                                            // Add the unequipped item back using the CORRECT function
                                            if (instance_exists(obj_inventory)) {
                                                var added_back = obj_inventory.inventory_add(current_equipped_name); // Use inventory_add
                                                if (added_back) {
                                                     show_debug_message("Unequipped '" + current_equipped_name + "' and returned to inventory via obj_inventory.");
                                                } else {
                                                     show_debug_message("Failed to return '" + current_equipped_name + "' to inventory (maybe full?). Equipping anyway.");
                                                }
                                            } else {
                                                show_debug_message("ERROR: obj_inventory not found during equip->unequip step!");
                                            }
                                        }

                                        // 2. Equip the new item
                                        equip_item(item_type, item_name);

                                        // 3. Remove the newly equipped item from inventory
                                        if (instance_exists(obj_inventory)) {
                                            obj_inventory.inventory[inventory_index] = -1; // Direct removal since we know the index
                                            show_debug_message("Removed '" + item_name + "' directly from inventory array slot " + string(inventory_index));
                                            // Trigger inventory update event if needed
                                            event_perform(ev_other, ev_user0); // Optional: notify systems of change
                                        } else {
                                            show_debug_message("ERROR: obj_inventory not found during equip->remove step!");
                                        }

                                        global.click_handled = true;
                                        exit;

                                    } else {
                                        show_debug_message("Cannot equip '" + item_name + "': Slot type '" + item_type + "' does not exist in equipped_items map.");
                                    }
                                } else {
                                    show_debug_message("Item '" + item_name + "' is not equippable (no type found).");
                                }
                            } else {
                                show_debug_message("Error: Could not find item name for index value: " + string(item_index_val));
                            }
                        } else {
                            show_debug_message("Clicked empty inventory slot " + string(inventory_index));
                        }
                    }
                    global.click_handled = true;
                    exit;
                }
            }
        }
    } // End of open state check for equipping

    // Unequip item by clicking on equipped slot (on the CLOSED pane)
    var clothing_slots_rel = [[9, 20], [9, 40], [9, 60], [9, 80], [9, 100], [9, 120]];
    var slot_types = ["head", "face", "neck", "body", "hand", "feet"];
    var slot_pixel_size = 18 * ui_scale;

    for (var i = 0; i < array_length(slot_types); i++) {
        var slot_screen_x = closed_x + clothing_slots_rel[i][0] * ui_scale;
        var slot_screen_y = closed_y + clothing_slots_rel[i][1] * ui_scale;

        if (point_in_rectangle(gui_mouse_x, gui_mouse_y, slot_screen_x, slot_screen_y, slot_screen_x + slot_pixel_size, slot_screen_y + slot_pixel_size)) {
            var slot_to_unequip = slot_types[i];
            var equipped_item_name = global.equipped_items[? slot_to_unequip];

            if (equipped_item_name != -1 && !is_undefined(equipped_item_name)) {
                show_debug_message("Clicked equipped slot: '" + slot_to_unequip + "', Item: '" + equipped_item_name + "'");

                unequip_item(slot_to_unequip); // Unequip visually/logically

                // *** CRASH FIX HERE ***
                // Add the unequipped item back using the CORRECT function
                if (instance_exists(obj_inventory)) {
                    var added_back = obj_inventory.inventory_add(equipped_item_name); // Use inventory_add
                    if (added_back) {
                         show_debug_message("Returned '" + equipped_item_name + "' to inventory via obj_inventory.");
                    } else {
                         show_debug_message("Inventory full! Failed to return '" + equipped_item_name + "'. Item lost.");
                    }
                } else {
                    show_debug_message("ERROR: obj_inventory not found during unequip!");
                }

                global.click_handled = true;
                exit;
            } else {
                show_debug_message("Clicked empty equipped slot: '" + slot_to_unequip + "'");
            }
            global.click_handled = true;
            exit;
        }
    }
} // End of mouse_check_button_pressed

// Close inventory with "I" key (Same as before)
if (keyboard_check_pressed(ord("I"))) {
    show_debug_message("DEBUG: Closing inventory UI with 'I' key.");
    global.inventory_visible = false;
    global.inventory_open_state = "closed";
    global.game_paused = false;
    instance_destroy();
}

// Special actions and animation logic (Unchanged)
if (keyboard_check_pressed(ord("H"))) {
    character_action = "dance";
    character_image_index = 0;
} else if (keyboard_check_pressed(ord("J"))) {
    character_action = "wave";
    character_image_index = 0;
} else if (keyboard_check_pressed(ord("K"))) {
    character_action = "none";
    character_image_index = 0;
} else if (keyboard_check_pressed(ord("B")) && instance_exists(obj_inventory) && obj_inventory.inventory_has("Jackhammer")) {
    character_action = "jackhammer";
    character_image_index = 0;
} else if (keyboard_check_pressed(ord("N")) && instance_exists(obj_inventory) && obj_inventory.inventory_has("Snow Shovel")) {
    character_action = "snowshovel";
    character_image_index = 0;
}

// Animate the character in the preview (Unchanged)
if (character_action != "none") {
    if (ds_map_exists(global.player_instance.action_anim_speed, character_action)){
        var anim_speed = ds_map_find_value(global.player_instance.action_anim_speed, character_action);
        character_image_index += anim_speed;
         if (ds_map_exists(global.player_instance.action_frame_data, character_action)){
            var frames = ds_map_find_value(global.player_instance.action_frame_data, character_action);
            if (is_array(frames) && array_length(frames) > 0 && character_image_index >= array_length(frames)) {
                character_image_index = 0;
            }
         }
    }
} else {
    character_image_index += 0.15; // Idle animation speed
    if (character_image_index >= 3) character_image_index = 0; // Assuming 3 idle frames
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_Jackhammer_item
File: Create_0.gml
event_inherited();
item_name = "Jackhammer";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_lamp
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_long_bush
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_lrg_boat
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_menu
File: Create_0.gml
if (!instance_exists(obj_new_game_button)) {
    instance_create_layer(room_width / 2, room_height / 2, "Instances", obj_new_game_button);
}
if (!instance_exists(obj_continue_button) && file_exists("savegame.sav")) {
    instance_create_layer(room_width / 2, room_height / 2 + 40, "Instances", obj_continue_button);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_menu
File: Step_0.gml
if (room == rm_main_menu) {
    if (!instance_exists(obj_new_game_button)) {
        instance_create_layer(room_width / 2, room_height / 2, "Instances", obj_new_game_button);
    }
    if (!instance_exists(obj_continue_button)) {
        if (file_exists("savegame.sav")) {
            instance_create_layer(room_width / 2, room_height / 2 + 40, "Instances", obj_continue_button);
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_settings
File: Create_0.gml
// obj_pause_menu create event
depth = -99990; // Ensure it's drawn above all other objects

// Disable player controls
global.player_controls_enabled = false;

width = display_get_width();
height = display_get_height();
op_border = 8;
op_space = 16;
pos = 0;

// Settings menu options
option[0, 0] = "Window Size";
option[0, 1] = "Brightness";
option[0, 2] = "Controls";
option[0, 3] = "Back";

menu_level = 0;
// Ensure menu_level is valid
if (menu_level < 0 || menu_level >= array_length(option)) {
    show_debug_message("ERROR: Invalid initial menu_level " + string(menu_level));
    menu_level = 0; // Reset to default
}
op_length = array_length(option[menu_level]); // Dynamically set op_length

// Pause the game
game_paused = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_settings
File: Draw_0.gml
draw_set_font(fnt_bumbastika_sml);

// Ensure menu_level is valid
if (menu_level < 0 || menu_level >= array_length(option)) {
    show_debug_message("ERROR: Invalid menu_level " + string(menu_level));
    return; // Exit the Draw Event
}

// Dynamically get width and height of menu
var _new_w = 0;
for (var i = 0; i < op_length; i++) {
    if (i < array_length(option[menu_level])) { // Check that index is within bounds
        var _op_w = string_width(option[menu_level][i]);
        _new_w = max(_new_w, _op_w);
    }
}
width = _new_w + op_border * 2;
height = op_border * 4.5 + string_height(option[menu_level][0]) * op_length;

// Center menu
x = camera_get_view_x(view_camera[0]) + (camera_get_view_width(view_camera[0]) - width) / 2;
y = camera_get_view_y(view_camera[0]) + (camera_get_view_height(view_camera[0]) - height) / 2;

// Draw the menu background
draw_sprite_ext(
    spr_pause_menu, 
    0, 
    x, 
    y, 
    width / sprite_get_width(spr_pause_menu), 
    height / sprite_get_height(spr_pause_menu), 
    0, 
    c_white, 
    1
);

// Draw the options
draw_set_valign(fa_top);
draw_set_halign(fa_center);
for (var i = 0; i < op_length; i++) {
    if (i < array_length(option[menu_level])) { // Check bounds again
        var _c = c_white;
        if (pos == i) { 
            _c = c_yellow; // Highlight the option being hovered over
        }
        draw_text_color(
            x + width / 2, 
            y + op_border + op_space * i, 
            option[menu_level][i], // Access using nested arrays
            _c, 
            _c, 
            _c, 
            _c, 
            1
        );
    } else {
        show_debug_message("ERROR: Invalid option index " + string(i) + " for menu_level " + string(menu_level));
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_settings
File: Step_0.gml
// Update op_length dynamically based on menu_level
op_length = array_length(option[menu_level]);

// Menu navigation using the mouse
var mouse_x_pos = device_mouse_x(0); // Get mouse x-coordinate
var mouse_y_pos = device_mouse_y(0); // Get mouse y-coordinate

var menu_width = 300; // Width of the menu
var menu_height = 40 * op_length + 20; // Height of the menu
var menu_top = y - menu_height / 2 + 20; // Top of the menu options
var menu_left = x - menu_width / 2; // Left of the menu

if (mouse_x_pos > menu_left && mouse_x_pos < menu_left + menu_width) {
    pos = floor((mouse_y_pos - menu_top) / 40); // Calculate option index
} else {
    pos = -1; // Mouse is not over the menu
}

// Ensure pos stays within bounds
if (pos < 0 || pos >= op_length) {
    pos = -1;
}

// Handle selection with mouse click
if (mouse_check_button_pressed(mb_left) && pos >= 0) {
    switch (menu_level) {
        case 0: // Main settings menu
             switch (pos) {
                case 0: 
                    break; // Window Size (placeholder)
                case 1: 
                    break; // Brightness (placeholder)
                case 2: 
                    break; // Controls (placeholder)
				case 3:	
					room_goto(rm_main_menu);
					break;
            }
            break;
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: Create_0.gml
// obj_map Create Event
depth = -9998; // Ensure it's drawn above all other objects

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: Draw_0.gml
// obj_map Draw Event
draw_self(); // Draw the full map sprite

// Draw markers or labels for clickable regions (halved size)
draw_set_color(c_red);
draw_rectangle(185 - 25, 228 - 25, 185 + 25, 228 + 25, false); // Town
draw_rectangle(55 - 25, 190 - 25, 55 + 25, 190 + 25, false); // Beach
draw_rectangle(155 - 25, 128 - 25, 155 + 25, 128 + 25, false); // Ski village
draw_rectangle(280 - 25, 250 - 25, 280 + 25, 250 + 25, false); // Snow fort
draw_rectangle(410 - 25, 277 - 25, 410 + 25, 277 + 25, false); // Welcome room
draw_rectangle(380 - 25, 230 - 25, 380 + 25, 230 + 25, false); // Plaza
draw_rectangle(395 - 25, 170 - 25, 395 + 25, 170 + 25, false); // Forest
draw_rectangle(400 - 25, 130 - 25, 400 + 25, 130 + 25, false); // Cove
draw_rectangle(135 - 25, 60 - 25, 135 + 25, 60 + 25, false); // Mountain top

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: KeyPress_27.gml
if (global.chat_active) {
    show_debug_message("Map interaction blocked: Chat is active.");
    exit; // Prevent interaction when the chat window is open
}

camera_set_view_size(global.camera, global.camera_width, global.camera_height); // Restore original camera view size
instance_destroy(id);
show_debug_message("Map closed.");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: KeyPress_77.gml
if (global.chat_active) {
    show_debug_message("Map interaction blocked: Chat is active.");
    exit;
}

if (variable_global_exists("last_room") && global.last_room != noone) {
    show_debug_message("Returning to previous room: " + string(global.last_room));
    var target_room = global.last_room;
    global.last_room = noone; // Reset after use

    // Ensure the player instance is recreated when switching back
    room_goto(target_room);
} else {
    show_debug_message("No previous room recorded. Returning to default.");
    room_goto(rm_welcome_room);
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: Mouse_4.gml
if (global.chat_active) {
    show_debug_message("Map interaction blocked: Chat is active.");
    exit; // Prevent interaction when the chat window is open
}

// obj_map Mouse Left Pressed Event
var click_x = device_mouse_x_to_gui(0);
var click_y = device_mouse_y_to_gui(0);

show_debug_message("Mouse clicked at: " + string(click_x) + ", " + string(click_y));

// Define clickable regions for different rooms (halved size)
if (click_x > 87 - 25 && click_x < 87 + 25 && click_y > 283 - 25 && click_y < 283 + 25) {
    // Move to Beach
    show_debug_message("Beach region clicked");
    room_goto(rm_beach);
} else if (click_x > 185 - 25 && click_x < 185 + 25 && click_y > 228 - 25 && click_y < 228 + 25) {
    // Move to town
    show_debug_message("Town region clicked");
    room_goto(rm_town);
} else if (click_x > 55 - 25 && click_x < 55 + 25 && click_y > 190 - 25 && click_y < 190 + 25) {
    // Move to beach
    show_debug_message("Beach region clicked");
    room_goto(rm_beach);
} else if (click_x > 155 - 25 && click_x < 155 + 25 && click_y > 128 - 25 && click_y < 128 + 25) {
    // Move to ski village
    show_debug_message("Ski village region clicked");
    room_goto(rm_ski_village);
} else if (click_x > 280 - 25 && click_x < 280 + 25 && click_y > 250 - 25 && click_y < 250 + 25) {
    // Move to snow fort
    show_debug_message("Snow fort region clicked");
    room_goto(rm_snow_fort);
} else if (click_x > 410 - 25 && click_x < 410 + 25 && click_y > 277 - 25 && click_y < 277 + 25) {
    // Move to welcome room
    show_debug_message("Welcome room region clicked");
    room_goto(rm_welcome_room);
} else if (click_x > 380 - 25 && click_x < 380 + 25 && click_y > 230 - 25 && click_y < 230 + 25) {
    // Move to plaza
    show_debug_message("Plaza region clicked");
    room_goto(rm_plaza);
} else if (click_x > 395 - 25 && click_x < 395 + 25 && click_y > 170 - 25 && click_y < 170 + 25) {
    // Move to forest
    show_debug_message("Forest region clicked");
    room_goto(rm_forest);
} else if (click_x > 400 - 25 && click_x < 400 + 25 && click_y > 130 - 25 && click_y < 130 + 25) {
    // Move to cove
    show_debug_message("Cove region clicked");
    room_goto(rm_cove);
} else if (click_x > 135 - 25 && click_x < 135 + 25 && click_y > 60 - 25 && click_y < 60 + 25) {
    // Move to mountain top
    show_debug_message("Mountain top region clicked");
    room_goto(rm_ski_mountaintop);
} else {
    show_debug_message("No region matched. Click ignored.");
}

function create_warp_instance(target_room) {
    // Create a warp instance at the correct position
    var inst = instance_create_depth(0, 0, -9999, obj_warp);

    // Ensure the player warps to a valid position
    if (instance_exists(global.player_instance)) {
        inst.target_x = global.player_instance.x;
        inst.target_y = global.player_instance.y;
    } else {
        inst.target_x = 320; // Default center of the room (fallback)
        inst.target_y = 240;
    }

    inst.target_rm = target_room;
    inst.target_face = 0; // Set default direction
    inst.target_instance = global.player_instance;

    show_debug_message("DEBUG: Creating warp to " + string(target_room) + 
        " at (" + string(inst.target_x) + ", " + string(inst.target_y) + ")");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: Mouse_5.gml
if (global.chat_active) {
    show_debug_message("Map interaction blocked: Chat is active.");
    exit;
}

if (variable_global_exists("last_room") && global.last_room != noone) {
    show_debug_message("Returning to previous room: " + string(global.last_room));
    var target_room = global.last_room;
    global.last_room = noone; // Reset after use
	room_goto(target_room);
} else {
    show_debug_message("No previous room recorded. Returning to default.");
    room_goto(rm_welcome_room);
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map_icon
File: Draw_64.gml
/// Draw GUI Event for obj_map_icon
draw_sprite_ext(
    sprite_index, image_index,
    10, display_get_height() - sprite_height - 10, // Fixed GUI position
    1, 1, 0, c_white, 1
);

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map_icon
File: Mouse_4.gml
if (room != rm_map) {
    if (instance_exists(global.player_instance)) {
        global.player_x = global.player_instance.x;
        global.player_y = global.player_instance.y;

        show_debug_message("DEBUG: Stored player position: (" + string(global.player_x) + ", " + string(global.player_y) + ")");
        
        // Hide the player instead of destroying
        global.player_instance.visible = false;
    } else {
        show_debug_message("WARNING: No player instance found before switching rooms! Using default coordinates.");
        
        // Set default safe position
        global.player_x = 170;
        global.player_y = 154;
    }

    show_debug_message("Switching to map room...");
    global.last_room = room;
    room_goto(rm_map);
}
else if (variable_global_exists("last_room") && global.last_room != noone) {
    show_debug_message("Returning to previous room: " + string(global.last_room));
    room_goto(global.last_room);

}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map_icon
File: Step_0.gml
//Step event
if (global.chat_active) exit;
depth = -1000;

// Position map icon in the corner of the screen
x = camera_get_view_x(global.camera);
y = camera_get_view_y(global.camera) + camera_get_view_height(global.camera) - sprite_height;

// Check if the mouse is hovering over the icon
if (position_meeting(mouse_x, mouse_y, id)) {
    image_index = 1; // Change to highlighted sprite
} else {
    image_index = 0; // Revert to normal sprite
}

// Hide player instead of destroying in UI rooms
var is_ui_room = (room == rm_init || room == rm_main_menu || room == rm_map || room == rm_sled_racing || room == rm_pause_menu || room == rm_settings_menu);

if (is_ui_room) {
    if (instance_exists(obj_map_icon)) {
        obj_map_icon.visible = false;
        show_debug_message("DEBUG: UI Room detected. Player instance hidden.");
    }
} else {
    if (instance_exists(obj_map_icon)) {
       obj_map_icon.visible = true;
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map_item
File: Create_0.gml
event_inherited();
item_name = "Map";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_animation
File: Create_0.gml
offset_y = 0;
scroll_distance = sprite_get_height(spr_main_menu) - room_height;
move_speed = 2;
animation_complete = false;
button_alpha = 0;
fade_speed = 0.02;
button_ids = [];
delay_timer = 120;
jetpack_y = 80;
puffle_y = 80;
jetpack_frame_speed = 0.5;
puffle_frame_speed = 0.5;
jetpack_image_index = 0;
puffle_image_index = 0;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_animation
File: Draw_0.gml
// Draw main menu sprite
draw_sprite(spr_main_menu, 0, 0, offset_y);
draw_sprite_ext(spr_menu_puffle, floor(puffle_image_index), 120, puffle_y, 1, 1, 0, c_white, 1);
draw_sprite_ext(spr_menu_jetpackguy, floor(jetpack_image_index), 60, jetpack_y, 1, 1, 0, c_white, 1);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_animation
File: Other_4.gml
button_ids = [];
var num_buttons = instance_number(obj_menu_button);
for (var i = 0; i < num_buttons; i++) {
    var btn = instance_find(obj_menu_button, i);
    if (btn != noone) {
        button_ids[i] = btn;
    }
}
show_debug_message("Number of buttons found: " + string(array_length(button_ids)));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_animation
File: Step_0.gml
// Existing logic for delay and scrolling
if (delay_timer > 0) {
    delay_timer -= 1;  // Countdown the delay timer
} else if (!animation_complete) {
    offset_y -= move_speed;  // Start scrolling after delay
    if (offset_y <= -scroll_distance) {
        offset_y = -scroll_distance;
        animation_complete = true;
    }
} else {
    if (button_alpha < 1) {
        button_alpha += fade_speed;  // Fade in buttons after animation
        if (button_alpha > 1) button_alpha = 1;
        
        for (var i = 0; i < array_length(button_ids); i++) {
            var btn_id = button_ids[i];
            if (instance_exists(btn_id)) {
                with (btn_id) {
                    image_alpha = other.button_alpha;
                }
            }
        }
    }
}

// Jetpack Guy Movement Logic
if (!animation_complete) {
    // Move `spr_menu_jetpackguy` upward as `offset_y` decreases
    jetpack_y = 80 - (offset_y * -1);
}

// Puffle Movement Logic
if (!animation_complete) {
    // Move `spr_menu_puffle` upward as `offset_y` decreases
    puffle_y = 80 - (offset_y * -1);
}

// Jetpack Guy Animation Logic
jetpack_image_index += jetpack_frame_speed;
if (jetpack_image_index >= sprite_get_number(spr_menu_jetpackguy)) {
    jetpack_image_index = 0;
}

// Puffle Animation Logic
puffle_image_index += puffle_frame_speed;
if (puffle_image_index >= sprite_get_number(spr_menu_puffle)) {
    puffle_image_index = 0;
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Create_0.gml
// Create Event in obj_menu_button
btn_action = "";             // Action to perform (set via creation code)
btn_text = "";               // Text to display (set via creation code)
btn_font = fnt_bonkfatty;    // Font for button text
text_color = c_black;        // Text color
image_speed = 0;             // Prevent automatic frame switching
image_index = 0;             // Start on frame 0 (normal state)

// Set initial alpha based on room
if (room == rm_main_menu) {
    image_alpha = 0;         // Start invisible for fade-in
} else {
    image_alpha = 1;         // Visible in other rooms
}

// Show "Continue" button only if save file exists
if (btn_action == "continue") {
    visible = file_exists("savegame.sav");
} else {
    visible = true;          // Other buttons are visible by default
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Draw_0.gml
if (mouse_check_button(mb_left) && position_meeting(mouse_x, mouse_y, id)) {
    image_index = 1;  // Show frame 1 when clicked
} else {
    image_index = 0;  // Revert to frame 0 when not clicked
}
draw_self();

// Set alpha for text to match button
draw_set_alpha(image_alpha);

// Set text alignment
draw_set_halign(fa_center);
draw_set_valign(fa_middle);

// Calculate text position
var text_x = x + sprite_width / 2;
var text_y = y + sprite_height / 2;

// Draw the button text
draw_set_color(text_color);
draw_set_font(btn_font);
draw_text_ext(text_x, text_y, btn_text, -1, sprite_width - 100);

// Reset alpha and alignment
draw_set_alpha(1);
draw_set_halign(fa_left);
draw_set_valign(fa_top);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Mouse_10.gml
hover = true;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Mouse_11.gml
hover = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Mouse_4.gml
// Mouse Left Pressed Event in obj_menu_button

// --- New Game Actions ---
if (btn_action == "new_game") {
    // Set loading flag to false explicitly for a new game start
    global.is_loading_game = false;
    show_debug_message("obj_menu_button: New Game selected. Setting is_loading_game=false.");
    // Go to the first step of new game (e.g., color picker or init room)
    room_goto(rm_colorpicker_menu); // Or potentially rm_init if color picker is skipped
    exit; // Exit event after handling action
}
else if (btn_action == "start") { // Assuming 'start' is also a new game variant
    global.is_loading_game = false;
    show_debug_message("obj_menu_button: Start button selected. Setting is_loading_game=false.");
    room_goto(rm_saveload); // Go to init room directly
    exit; // Exit event after handling action
}

// --- Continue Game Action ---
else if (btn_action == "continue") {
    // Ensure loading flag is set *before* calling load_game
    global.is_loading_game = true;
    show_debug_message("obj_menu_button: Continue selected. Setting is_loading_game=true.");

    var _load_result = load_game(); // Call the load_game function

    // *** ADDED TRANSITION LOGIC ***
    if (_load_result == true) {
        // If loading succeeded, go to rm_init which will handle the actual room jump
        show_debug_message("obj_menu_button: load_game successful. Transitioning to rm_init...");
        room_goto(rm_init);
    } else {
        // If loading failed, show a message and reset the flag
        show_debug_message("obj_menu_button: load_game failed. Staying in current room.");
        // CORRECTED LINE BELOW: Removed the second argument
        show_message_async("Failed to load save game."); // User feedback
        global.is_loading_game = false; // Reset flag if load failed
    }
    exit; // Exit event after handling action
}

// --- Other Menu Actions ---
else if (btn_action == "play") { // This might be obsolete if "start" or "new_game" are used
    global.is_loading_game = false;
     show_debug_message("obj_menu_button: Play button selected. Setting is_loading_game=false.");
    room_goto(rm_init);
    exit; // Exit event after handling action
}
else if (btn_action == "settings") {
    room_goto(rm_settings_menu);
    exit; // Exit event after handling action
}
else if (btn_action == "exit") {
    game_end();
    exit; // Exit event after handling action
}

// Fallback if btn_action isn't recognized (shouldn't happen ideally)
show_debug_message("obj_menu_button: Unrecognized action: " + string(btn_action));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_controller
File: Create_0.gml
global.menu_state = "none"; // Possible values: "none", "puffle_menu", "name_puffle"
global.selected_puffle = noone;
global.menu_index = 0; // Selected option
name = "";
owner = noone;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_controller
File: Draw_64.gml
if (global.menu_state == "puffle_menu") {
    draw_set_color(c_black);
    draw_rectangle(100, 100, 300, 200, false); // Menu background
    draw_set_color(c_white);
    draw_text(150, 120, "Adopt");
    draw_text(150, 140, "Cancel");
    draw_text(130, 120 + global.menu_index * 20, ">"); // Cursor
}

if (global.menu_state == "name_puffle") {
    draw_set_color(c_black);
    draw_rectangle(100, 100, 300, 200, false);
    draw_set_color(c_white);
    draw_text(150, 140, "Press Enter to name your puffle");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_controller
File: Step_0.gml
if (global.menu_state == "puffle_menu") {
    // Menu options
    var options = ["Adopt", "Cancel"];
    var choice = -1;
    
    // Simple keyboard navigation (expand for mouse if needed)
    if (keyboard_check_pressed(vk_down)) global.menu_index = min(global.menu_index + 1, 1);
    if (keyboard_check_pressed(vk_up)) global.menu_index = max(global.menu_index - 1, 0);
    if (keyboard_check_pressed(vk_enter)) choice = global.menu_index;
    
    // Handle choice
    if (choice == 0) { // Adopt
        global.menu_state = "name_puffle";
        global.menu_index = 0; // Reset for next menu
    } else if (choice == 1) { // Cancel
        global.menu_state = "none";
        global.selected_puffle = noone;
    }
}

if (global.menu_state == "name_puffle") {
    if (keyboard_check_pressed(vk_enter)) {
        var puffle_name = get_string("Enter a name for your puffle:", "Puffle");
        if (puffle_name != "") {
            with (global.selected_puffle) {
                name = puffle_name;
                owner = obj_player; // Mark as adopted
            }
            obj_player.puffle_os -= 1; // Consume one Puffle-O
            global.menu_state = "none";
            global.selected_puffle = noone;
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_minershardhat_item
File: Create_0.gml
event_inherited();
item_name = "Miners Hard Hat";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_musicmanager
File: Create_0.gml
//global volume control
global.masterVolume = 1;
global.musicVolume = 1;

//info for the song that we are currently playing / trying to play
songInstance = noone;
songAsset = noone;
targetSongAsset = noone;
endFadeOutTime = 0;//how many frames to fade out the song currently playing
startFadeInTime = 0;//how many frames to fade in the new song
fadeInInstVol = 1;//the volume of songInstance

//for fading music out and stopping songs that are no longer playing
fadeOutInstances = array_create(0);//audio instances to fade out
fadeOutInstVol = array_create(0);//the volume of each indiviual audio instance
fadeOutInstTime = array_create(0);//how fast the fadeout should happen
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_musicmanager
File: Other_4.gml
// Play the correct music

if room == rm_welcome_room
|| room == rm_plaza
|| room == rm_shore
{
	set_song_ingame( bg_music, 60, 0 );
}

//For other rooms that require different music
//if room == rm_template
//{
//	set_song_ingame( bg_music, 3*60 );
//}

//if room == rm_template
//{
//	set_song_ingame( bg_music, 2*60, 2*60 );
//}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_musicmanager
File: Step_0.gml
var _finalVol = global.musicVolume*global.masterVolume;

//Play the target song
if songAsset != targetSongAsset
{
	//Tell the old song to fade out
	if audio_is_playing( songInstance )
	{
		//add out songInstance to our array of songs to fade out
		array_push( fadeOutInstances, songInstance );
		//add the songInstance's starting volume (so theres no adrupt change in volume)
		array_push( fadeOutInstVol, fadeInInstVol );
		//add the fadeOutInstance's fade out frames
		array_push( fadeOutInstTime, endFadeOutTime );
		
		//reset the songInstance and songAsset variables
		songInstance = noone;
		songAsset = noone;
	}
	
	
	//Play the song if the old song has faded out
	if array_length( fadeOutInstances) == 0
	{
		if audio_exists( targetSongAsset)
		{
			//Play the song and store its instance in a variable
			songInstance = audio_play_sound( targetSongAsset, 4, true );
	
			//Start the song's volume at 0
			audio_sound_gain( songInstance, 0, 0 );
			fadeInInstVol = 0;
		}
	
	//Set the songAssest to match the targetSongAsset
	songAsset = targetSongAsset;
	}
}


//Volume Control
	//Main song volume
	if audio_is_playing( songInstance )
	{
		//Fade the song in
		if startFadeInTime > 0
		{
			if fadeInInstVol < 1 { fadeInInstVol += 1/startFadeInTime; } else fadeInInstVol = 1
		}
		//Immediately start the song if the fade in time is 0 framces
		else
		{
			fadeInInstVol = 1;
		}
	
		//Actually set the gain
		audio_sound_gain( songInstance, fadeInInstVol*_finalVol, 0 )
	}
	
	//Fading songs out
	for(var i = 0; i < array_length(fadeOutInstances); i++ )
	{
		//Fade the volume
		if fadeOutInstTime[i] > 0
		{
			if	fadeOutInstVol[i] > 0 {fadeOutInstVol[i] -= 1/fadeOutInstTime[i]; }
		}
		//Immediately cut volume to 0 otherwuse
		else
		{
			fadeOutInstVol[i] = 0;
		}
		
		//Actually set the gain
		audio_sound_gain( fadeOutInstances[i], fadeOutInstVol[i]*_finalVol, 0 );
		
		//Stop the song when it's volume is at 0 and remove it from ALL arrays
		if fadeOutInstVol[i] <= 0
		{
			//stop the song	
			if audio_is_playing( fadeOutInstances[i] ) { audio_stop_sound( fadeOutInstances[i] ); };
			//remove it from the arrays
			array_delete( fadeOutInstances, i, 1);
			array_delete( fadeOutInstVol, i, 1);
			array_delete( fadeOutInstTime, i, 1);
			//set the loop back 1 since we just deleted an entry
			i--;
		}
	}
	
	
	
	
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_new_game_button
File: Create_0.gml
depth = -1000;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_new_game_button
File: Mouse_4.gml
room_goto(rm_colour_picker);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc
File: Alarm_0.gml
if (npc_portrait != "") {
    sprite_index = npc_portrait;
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc
File: Create_0.gml
// Movement settings
xspd = 0;
yspd = 0;
move_spd = 0;
move_x = 0;
move_y = 0;
is_moving = false;
collision_delay = 0;
stuck_timer = 0;
wait_timer = 3;
last_x = x;
last_y = y;
face = DOWN;


// NPC Settings
npc_name = "NPC";  // Default name
if (variable_global_exists("player_colors") && array_length(global.player_colors) > 0) {
    npc_color = global.player_colors[irandom(array_length(global.player_colors) - 1)];
} else {
    npc_color = c_white; // Fallback to white if colors are not defined
}
is_static = true;  // If true, NPC doesn't move

// Dialogue and quest-related variables
quest_active = false;
quest_complete = false;
current_dialogue_index = -1;
dialogue = ["Hello there!", "I have nothing to say."];
player_interacting = false;

// Quest System
is_quest_giver = false;
quest_given = false;
quest_item = "";
quest_quantity = 0;  // Default to 0, set in creation code if needed
quest_stage = 0;  // 0 = not started, 1 = completed
reward_item = "";

// Sprite setup (mirroring obj_player)
sprite_body = spr_player_body;
sprite_color = spr_player_colour;
mask_index = spr_player_down;
image_speed = 0;
image_index = 0;

// Frame data for walking (same as obj_player)
frame_data = array_create(8);
frame_data[DOWN] = [0, 0, 24, 24, 0, 24, 24, 24, 0, 48, 24, 24];
frame_data[UP] = [24, 0, 24, 24, 24, 24, 24, 24, 24, 48, 24, 24];
frame_data[DOWN_LEFT] = [48, 0, 24, 24, 48, 24, 24, 24, 48, 48, 24, 24];
frame_data[DOWN_RIGHT] = [72, 0, 24, 24, 72, 24, 24, 24, 72, 48, 24, 24];
frame_data[LEFT] = [96, 0, 24, 24, 96, 24, 24, 24, 96, 48, 24, 24];
frame_data[RIGHT] = [120, 0, 24, 24, 120, 24, 24, 24, 120, 48, 24, 24];
frame_data[UP_RIGHT] = [144, 0, 24, 24, 144, 24, 24, 24, 144, 48, 24, 24];
frame_data[UP_LEFT] = [168, 0, 24, 24, 168, 24, 24, 24, 168, 48, 24, 24];

// Depth sorting
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc
File: Draw_0.gml
// Calculate drawing position
var draw_x = x - 12;  // Center 24x24 sprite
var draw_y = y - 12;
var frame_index = floor(image_index) mod 3;  // 3 frames per direction
var frame_x = frame_data[face][frame_index * 4];
var frame_y = frame_data[face][frame_index * 4 + 1];
var frame_width = frame_data[face][frame_index * 4 + 2];
var frame_height = frame_data[face][frame_index * 4 + 3];

// Draw body and colored overlay
draw_sprite_part_ext(sprite_body, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, c_white, 1);
draw_sprite_part_ext(sprite_color, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, npc_color, 1);

// Depth sorting
depth = -y;  // Consistent with set_depth()

// Draw the dialogue box if active
if (current_dialogue_index >= 0) {
    // Text and box parameters
    var margin = 8; // Padding around the text
    var max_width = 200; // Maximum width for the dialogue box
    var text_scale = 0.50; // Scale the text smaller

    // Calculate text dimensions
	draw_set_font(fnt_acme_secretagent_bold);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    var text_width = string_width(dialogue[current_dialogue_index]) * text_scale;
    var text_height = string_height(dialogue[current_dialogue_index]) * text_scale;

    // Calculate box dimensions (add padding around the text)
    var box_width = min(max_width, text_width + margin * 2);
    var box_height = text_height + margin * 2;

    // Position the box
    var box_x = x - box_width / 2;
    var box_y = y - sprite_height - box_height - 0.5;

    // Draw 9-slice sprite background
    draw_sprite_stretched(
        spr_chat,     // Sprite
        0,                       // Sub-image index
        box_x,                   // X position
        box_y,                   // Y position
        box_width,               // Scaled width
        box_height               // Scaled height
    );

    // Draw the scaled text
    var text_x = box_x + box_width / 2;
    var text_y = box_y + box_height / 2;
    draw_set_color(c_black);
    draw_text_transformed(text_x, text_y, dialogue[current_dialogue_index], text_scale, text_scale, 0);
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc
File: Step_0.gml
// In obj_npc Step Event
if (place_meeting(x, y, global.player_instance)) {
    if (keyboard_check_pressed(ord("E"))) {
        if (!instance_exists(obj_chat_window)) {
            var chat = instance_create_layer(0, 0, "UI", obj_chat_window);
            chat.dialog_data = dialog_data;  // Assign this NPC's unique dialog_data
            global.chat_npc = id;            // Set this NPC as the chat target
            global.chat_active = true;       // Make the chat window visible
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc_old
File: Alarm_0.gml
// Alarm[0] Event
// Reset moving state to allow the NPC to pick a new target
is_moving = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc_old
File: Create_0.gml
xspd = 0;
yspd = 0;

move_spd = 0.5; // Lower speed for smoother movement
move_x = 0;
move_y = 0;
is_moving = false;
collision_delay = 0; // Timer for delaying after a collision
stuck_timer = 0; // Timer to handle stuck state
wait_timer = 3; //Timer to handle how long to pause before walking
last_x = x;      // Tracks previous position for stuck detection
last_y = y;      // Tracks previous position for stuck detection

// Initialize movement variables
target_x = x; // Default to current position
target_y = y; // Default to current position
is_moving = false;
move_speed = 1; // Default movement speed

sprite[RIGHT] = spr_player_right;
sprite[UP] = spr_player_up;
sprite[LEFT] = spr_player_left;
sprite[DOWN] = spr_player_down;
sprite[UP_RIGHT] = spr_player_up_right;
sprite[UP_LEFT] = spr_player_up_left;
sprite[DOWN_RIGHT] = spr_player_down_right;
sprite[DOWN_LEFT] = spr_player_down_left;

face = DOWN;

sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;

// Random initial direction
direction = choose(0, 45, 90, 135, 180, 225, 270, 315);
change_direction_timer = fps * 2; // Change direction every 2 seconds

phrases = ["Hello there!", "Nice to meet you!", "What brings you here?", "Have a great day!", "Stay safe!"];
current_phrase = ""; // Will hold the currently displayed phrase
talk_timer = 0; // Timer for how long the phrase is displayed
interact_pause = 0; // Timer to pause movement after interaction


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc_old
File: Draw_0.gml
// Draw NPC as usual
draw_self();

// Ensure chat box is drawn above everything
if (talk_timer > 0) {
    // Text setup
    var text = current_phrase;
    var text_scale = 0.5; // Scale factor for text
    var text_padding = 10; // Padding around the text

    // Calculate text dimensions
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    var text_width = string_width(text) * text_scale; // Scaled width of the text
    var text_height = string_height(text) * text_scale; // Scaled height of the text

    // Calculate box dimensions (add padding around the text)
    var box_width = max(64, text_width + text_padding * 2); // Minimum width for aesthetics
    var box_height = text_height + text_padding * 2;

    // Position the box
    var box_x = x - box_width / 2;
    var box_y = y - sprite_height - box_height - 10;

    // Draw 9-slice sprite background
    draw_sprite_stretched(
        spr_menu,     // Sprite
        0,                       // Sub-image index
        box_x,                   // X position
        box_y,                   // Y position
        box_width,               // Scaled width
        box_height               // Scaled height
    );

    // Draw the scaled text
    var text_x = box_x + box_width / 2;
    var text_y = box_y + box_height / 2;
    draw_set_color(c_black);
    draw_text_transformed(text_x, text_y, text, text_scale, text_scale, 0);
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc_old
File: Step_0.gml
// Step Event for obj_npc
if (!sliding) {
    // Normal movement logic
    var move_x = lengthdir_x(move_spd, direction);
    var move_y = lengthdir_y(move_spd, direction);

    // Handle collisions with walls
    if (place_meeting(x + move_x, y, obj_wall)) {
        direction = 360 - direction; // Reverse direction on x-axis
    }
    if (place_meeting(x, y + move_y, obj_wall)) {
        direction = 180 - direction; // Reverse direction on y-axis
    }

    // Check for collision with obj_slippery to start sliding
    if (place_meeting(x + move_x, y, obj_slippery) || place_meeting(x, y + move_y, obj_slippery)) {
        sliding = true;
        slide_dir_x = sign(move_x);
        slide_dir_y = sign(move_y);
        slide_speed = move_spd * 1.5; // Initial slide speed, adjust as necessary
    } else {
        // Move the NPC normally
        x += move_x;
        y += move_y;
    }

    // Decrease the timer for changing direction
    change_direction_timer--;
    if (change_direction_timer <= 0) {
        direction = choose(0, 45, 90, 135, 180, 225, 270, 315);
        change_direction_timer = fps * 2; // Reset the timer
    }
} else {
    // Sliding logic
    var slide_move_x = slide_dir_x * slide_speed;
    var slide_move_y = slide_dir_y * slide_speed;

    // Decelerate slide over time
    slide_speed *= 0.98; // Adjust this value to control sliding deceleration

    // Stop sliding if speed is low enough
    if (abs(slide_speed) < 0.1) {
        sliding = false;
        slide_move_x = 0;
        slide_move_y = 0;
    }

    // Move the NPC while sliding
    x += slide_move_x;
    y += slide_move_y;
}

// Update the sprite based on direction
if (slide_speed > 0) {
    if (slide_dir_y < 0) {
        if (slide_dir_x < 0) { face = UP_LEFT; }
        if (slide_dir_x > 0) { face = UP_RIGHT; }
        if (slide_dir_x == 0) { face = UP; }
    }
    if (slide_dir_y > 0) {
        if (slide_dir_x < 0) { face = DOWN_LEFT; }
        if (slide_dir_x > 0) { face = DOWN_RIGHT; }
        if (slide_dir_x == 0) { face = DOWN; }
    }
    if (slide_dir_y == 0) {
        if (slide_dir_x > 0) { face = RIGHT; }
        if (slide_dir_x < 0) { face = LEFT; }
    }
} else {
    if (direction == 0) face = RIGHT;
    else if (direction == 45) face = UP_RIGHT;
    else if (direction == 90) face = UP;
    else if (direction == 135) face = UP_LEFT;
    else if (direction == 180) face = LEFT;
    else if (direction == 225) face = DOWN_LEFT;
    else if (direction == 270) face = DOWN;
    else if (direction == 315) face = DOWN_RIGHT;
}
sprite_index = sprite[face];

// Depth
depth = -bbox_bottom;

// Debugging logs

show_debug_message("NPC Direction: " + string(direction));
show_debug_message("NPC Face: " + string(face));
show_debug_message("NPC Position: " + string(x) + ", " + string(y));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_obstacle
File: Create_0.gml
// Create Event for obj_obstacle
move_speed = 5; // Speed at which obstacles move upwards

// Step Event for obj_obstacle
y += move_speed;

// Destroy the obstacle if it goes off the top of the screen
if (y < -sprite_height) {
    instance_destroy();
}

//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_obstacle
File: Step_0.gml
if (global.game_started) {
    y -= move_speed; // Move upwards

    // Reset position if off-screen
    if (y < -sprite_height) {
        y = room_height + sprite_height; // Reset to below the room
        x = irandom_range(0, room_width - sprite_width); // Randomize horizontal position
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_obstacle_controller
File: Alarm_0.gml
instance_create_layer(irandom_range(0, room_width - sprite_get_width(spr_long_bush)), room_height, "Instances", obj_obstacle);
alarm[0] = 30; // Reset alarm
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_obstacle_controller
File: Create_0.gml
alarm[0] = 30; // Spawn obstacle every 30 steps (adjust for difficulty)
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_parallax_background
File: Create_0.gml
depth = 10000;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_parallax_background
File: Draw_0.gml
var _camx = camera_get_view_x(global.camera);  // Use global.camera explicitly
var _camy = camera_get_view_y(global.camera);

var _p = 0.5;  // Parallax factor (adjust as needed)

if (sprite_exists(bg_sky)) {
    draw_sprite(bg_sky, 0, _camx * _p, _camy * _p);
} else {
    show_debug_message("ERROR: bg_sky sprite does not exist!");
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_party_hat
File: Create_0.gml
event_inherited();
item_name = "Party Hat";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pause_menu
File: Create_0.gml
// Create Event in obj_pause_menu
depth = -99990; // Ensure pause menu is drawn on top
global.is_pause_menu_active = false;
global.inventory_visible = false; 

image_speed = 0.5; // Menu animation speed

op_border = 8;
op_space = 16;
pos = 0;

// Pause menu options
option[0, 0] = "Back to Game";
option[0, 1] = "Settings";
option[0, 2] = "Quit Game";
option[0, 3] = "Save Game"; // Added "Save Game" option

// Settings menu options
option[1, 0] = "Window Size";
option[1, 1] = "Brightness";
option[1, 2] = "Controls";
option[1, 3] = "Back";

menu_level = 0; 
op_length = array_length(option[menu_level]); // Set initial length dynamically
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pause_menu
File: Draw_0.gml
// Only draw when the pause menu is active
if (!global.is_pause_menu_active) {
    exit;
}

draw_set_font(fnt_bumbastika_sml);

// Ensure menu_level is valid
// Ensure menu_level is valid
if (menu_level < 0 || menu_level >= array_length(option)) return;

// Dynamically calculate menu width
var _new_w = 0;
for (var i = 0; i < op_length; i++) {
    if (i < array_length(option[menu_level])) {
        _new_w = max(_new_w, string_width(option[menu_level][i]));
    }
}
width = _new_w + op_border * 2;
height = op_border * 4 + string_height(option[menu_level][0]) * op_length;

// Center menu
x = camera_get_view_x(view_camera[0]) + (camera_get_view_width(view_camera[0]) - width) / 2;
y = camera_get_view_y(view_camera[0]) + (camera_get_view_height(view_camera[0]) - height) / 2;

// Draw the menu background
draw_sprite_ext(
    spr_pause_menu, 
    floor(image_index), // Use image_index for animation
    x, 
    y, 
    width / sprite_get_width(spr_pause_menu), 
    height / sprite_get_height(spr_pause_menu), 
    0, 
    c_white, 
    1
);

// Draw menu options
draw_set_valign(fa_top);
draw_set_halign(fa_center);
for (var i = 0; i < op_length; i++) {
    if (i < array_length(option[menu_level])) {
        var color = (pos == i) ? c_yellow : c_white; // Highlight selection
        draw_text_color(x + width / 2, y + op_border + op_space * i, option[menu_level][i], color, color, color, color, 1);
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pause_menu
File: Step_0.gml

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pause_menu
File: Step_2.gml
// End Step Event in obj_pause_menu
// Only process inputs when the pause menu is active
if (!global.is_pause_menu_active) exit;
if (global.click_handled) exit;
if (global.inventory_visible || global.is_expanded) exit;

op_length = array_length(option[menu_level]);

// Mouse Position Adjusted to GUI Coordinates
var menu_width = 300;
var menu_height = op_length * 40 + 20;
var menu_top = y - menu_height / 2 + 20;
var menu_left = x - menu_width / 2;

if (mouse_x > menu_left && mouse_x < menu_left + menu_width) {
    pos = floor((mouse_y - menu_top) / 40);
} else {
    pos = -1;
}

// Ensure pos is within valid bounds
if (pos < 0 || pos >= op_length) pos = -1;

// Handle menu selection with mouse click
if (mouse_check_button_pressed(mb_left) && pos >= 0) {
	     // *** ADD DEBUG LOGGING BEFORE SAVE ***
     if (menu_level == 0 && pos == 3) { // IF "Save Game" is about to be chosen
         var _inv_debug_str = "Pause Menu DEBUG: Inventory state JUST BEFORE save call: [";
         if (variable_global_exists("inventory") && is_array(global.inventory)) {
            for(var i=0; i<min(10, array_length(global.inventory)); i++) { _inv_debug_str += string(global.inventory[i]) + ","; }
            if(array_length(global.inventory) > 10) _inv_debug_str += "...";
         } else { _inv_debug_str += "ERROR: global.inventory missing or not array!"; }
         _inv_debug_str += "]";
         show_debug_message(_inv_debug_str);
     }
     // *** END DEBUG LOGGING ***
    switch (menu_level) {
        case 0: // Main Pause Menu
            switch (pos) {
                case 0: // Resume Game
                    global.is_pause_menu_active = false;
                    global.player_controls_enabled = true;
                    show_debug_message("Game Resumed");
                    break;
                case 1: // Go to Settings
                    menu_level = 1;
                    break;
                case 2: // Quit Game
                    show_debug_message("Calling game_end from obj_pause_menu Quit Game button");
                    game_end();
                    break;
                case 3: // Save Game
                    save_game(); // Call the save function
                    break;
            }
            break;
        case 1: // Settings Menu
            switch (pos) {
                case 0: 
                    break; // Window Size (placeholder)
                case 1: 
                    break; // Brightness (placeholder)
                case 2: 
                    break; // Controls (placeholder)
                case 3: // Back to Pause Menu
                    menu_level = 0;
                    break;
            }
            break;
    }
	     global.click_handled = true;
}

//show_debug_message("Pause menu active: " + string(global.is_pause_menu_active) + ", Click handled: " + string(global.click_handled));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_penguinstylestore
File: Create_0.gml
// obj_penguinstylestore: Create Event
depth = -10000; // Draw above everything

// Default state
current_page = 0; // 0 = cover, 1 = page1, 2 = page2

// Area for turning pages
turn_left_area = [4, 120, 20, 156];
turn_right_area = [258, 120, 274, 156];

// Area for choosing colors
color_picker_area = [21, 21, 120, 148];
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_penguinstylestore
File: Draw_0.gml
// obj_penguinstylestore: Draw Event
var camera_x = camera_get_view_x(view_camera[0]);
var camera_y = camera_get_view_y(view_camera[0]);
var viewport_width = camera_get_view_width(view_camera[0]);
var viewport_height = camera_get_view_height(view_camera[0]);

var center_x = camera_x + (viewport_width / 2);
var center_y = camera_y + (viewport_height / 2);

switch (current_page) {
    case 0:
        draw_sprite(spr_penguinstyle_cover, 0, center_x - sprite_get_width(spr_penguinstyle_cover) / 2, center_y - sprite_get_height(spr_penguinstyle_cover) / 2);
        break;
    case 1:
        draw_sprite(spr_penguinstyle_page2_3, 0, center_x - sprite_get_width(spr_penguinstyle_page2_3) / 2, center_y - sprite_get_height(spr_penguinstyle_page2_3) / 2);
        draw_sprite(spr_penguinstyle_page12_13_colour, 0, center_x + color_picker_area[0], center_y + color_picker_area[1]);
        break;
    case 2:
        draw_sprite(spr_penguinstyle_page12_13, 0, center_x - sprite_get_width(spr_penguinstyle_page12_13) / 2, center_y - sprite_get_height(spr_penguinstyle_page12_13) / 2);
        break;
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_penguinstylestore
File: Mouse_4.gml
// obj_penguinstylestore: Mouse Left Pressed Event
var camera_x = camera_get_view_x(view_camera[0]);
var camera_y = camera_get_view_y(view_camera[0]);
var viewport_width = camera_get_view_width(view_camera[0]);
var viewport_height = camera_get_view_height(view_camera[0]);

var center_x = camera_x + (viewport_width / 2);
var center_y = camera_y + (viewport_height / 2);

var clicked_inside = false;

switch (current_page) {
    case 0:
        if (mouse_x >= center_x + turn_right_area[0] && mouse_x <= center_x + turn_right_area[2] &&
            mouse_y >= center_y + turn_right_area[1] && mouse_y <= center_y + turn_right_area[3]) {
            current_page = 1;
            clicked_inside = true;
        }
        break;
    case 1:
        if (mouse_x >= center_x + turn_left_area[0] && mouse_x <= center_x + turn_left_area[2] &&
            mouse_y >= center_y + turn_left_area[1] && mouse_y <= center_y + turn_left_area[3]) {
            current_page = 0;
            clicked_inside = true;
        }
        if (mouse_x >= center_x + turn_right_area[0] && mouse_x <= center_x + turn_right_area[2] &&
            mouse_y >= center_y + turn_right_area[1] && mouse_y <= center_y + turn_right_area[3]) {
            current_page = 2;
            clicked_inside = true;
        }
        // Handle color picker interaction
        if (mouse_x >= center_x + color_picker_area[0] && mouse_x <= center_x + color_picker_area[2] &&
            mouse_y >= center_y + color_picker_area[1] && mouse_y <= center_y + color_picker_area[3]) {
            instance_create_layer(mouse_x, mouse_y, "Instances", obj_color_picker_controller);
            clicked_inside = true;
        }
        break;
    case 2:
        if (mouse_x >= center_x + turn_left_area[0] && mouse_x <= center_x + turn_left_area[2] &&
            mouse_y >= center_y + turn_left_area[1] && mouse_y <= center_y + turn_left_area[3]) {
            current_page = 1;
            clicked_inside = true;
        }
        break;
}

// Close the store if clicked outside of the interactable areas
if (!clicked_inside) {
    instance_destroy();
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_penguinstyle_icon
File: Create_0.gml
depth = -1000; // Ensure it draws above most objects
visible = true; // Only visible in rm_giftshop
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_penguinstyle_icon
File: Draw_0.gml
// obj_penguinstyle_icon: Draw Event

    var camera_x = camera_get_view_x(view_camera[0]);
    var camera_y = camera_get_view_y(view_camera[0]);
    var viewport_width = camera_get_view_width(view_camera[0]);
    var viewport_height = camera_get_view_height(view_camera[0]);

    var icon_x = camera_x + viewport_width - 60; // Adjust position
    var icon_y = camera_y + viewport_height - 60;

    draw_sprite(spr_penguinstyle_icon, 0, icon_x, icon_y);
    show_debug_message("Drawing obj_penguinstyle_icon at (" + string(icon_x) + ", " + string(icon_y) + ")");

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_penguinstyle_icon
File: Mouse_4.gml
// obj_penguinstyle_icon: Mouse Left Pressed Event
if (room == rm_giftshop) {
    var camera_x = camera_get_view_x(view_camera[0]);
    var camera_y = camera_get_view_y(view_camera[0]);
    var viewport_width = camera_get_view_width(view_camera[0]);
    var viewport_height = camera_get_view_height(view_camera[0]);
    
    var icon_x = camera_x + viewport_width - 60;
    var icon_y = camera_y + viewport_height - 60;

    if (mouse_x >= icon_x && mouse_x <= icon_x + sprite_get_width(spr_penguinstyle_icon) &&
        mouse_y >= icon_y && mouse_y <= icon_y + sprite_get_height(spr_penguinstyle_icon)) {
        instance_create_layer(0, 0, "Instances", obj_penguinstylestore);
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pickup_item
File: Create_0.gml
// obj_pickup_item Create Event
is_savable = true;
item_name = ""; // Set in creation code or instance variables

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pickup_item
File: Step_0.gml
// obj_pickup_item Step Event
if (keyboard_check_pressed(ord("E")) && instance_exists(global.player_instance) && distance_to_object(global.player_instance) < 16) {
    // Check if the inventory object exists before calling its methods
    if (instance_exists(obj_inventory)) {
        // Use the centralized method
        var added = obj_inventory.inventory_add(item_name);
        if (added) {
            show_debug_message("'" + item_name + "' added to inventory via obj_inventory.");
            instance_destroy(); // Destroy AFTER successfully adding
        } else {
            show_debug_message("Inventory full or item invalid. Cannot pick up '" + item_name + "'.");
            // Optionally provide feedback to the player (e.g., text popup)
        }
    } else {
        show_debug_message("ERROR: obj_inventory instance not found!");
    }
}
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pizzaslice_item
File: Create_0.gml
event_inherited();
item_name = "Pizza Slice";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player
File: Create_0.gml
// Core variables
xspd = 0;
yspd = 0;
move_spd = 1;
state = "walking";
if (!variable_global_exists("player_color")) { global.player_color = c_white; }
if (variable_global_exists("last_player_color")) { global.player_color = global.last_player_color; } else { global.player_color = c_white; }

// Sliding variables
sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;

// Driving variables
driving = false;
original_sprite = sprite_index;

// Set direction and sprites
face = DOWN;
sprite_body = spr_player_body; // Default sprite
sprite_color = spr_player_colour;
if (!global.is_loading_game) {
    image_blend = global.player_color;
    show_debug_message("obj_player Create: Applying initial player color: " + string(global.player_color));
} else {
    image_blend = global.player_color;
    show_debug_message("obj_player Create: Applying loaded player color: " + string(global.player_color));
}
mask_index = spr_player_down;
throw_anim_base = "";  // "down_right" or "up_right"
throw_flip = false;    // Whether to flip the sprite horizontally

// Frame data for walking (192x72 sprite sheet: 3 frames per direction)
frame_data = array_create(8);
frame_data[DOWN] = [0, 0, 24, 24, 0, 24, 24, 24, 0, 48, 24, 24];
frame_data[UP] = [24, 0, 24, 24, 24, 24, 24, 24, 24, 48, 24, 24];
frame_data[DOWN_LEFT] = [48, 0, 24, 24, 48, 24, 24, 24, 48, 48, 24, 24];
frame_data[DOWN_RIGHT] = [72, 0, 24, 24, 72, 24, 24, 24, 72, 48, 24, 24];
frame_data[LEFT] = [96, 0, 24, 24, 96, 24, 24, 24, 96, 48, 24, 24];
frame_data[RIGHT] = [120, 0, 24, 24, 120, 24, 24, 24, 120, 48, 24, 24];
frame_data[UP_RIGHT] = [144, 0, 24, 24, 144, 24, 24, 24, 144, 48, 24, 24];
frame_data[UP_LEFT] = [168, 0, 24, 24, 168, 24, 24, 24, 168, 48, 24, 24];

// Special actions system
action_state = "none";  // "none", "dance", "wave", "sit", "jackhammer", "snowshovel", "throw"
action_timer = 0;
action_duration = 0;
sit_delay = 0;
image_index = 0;              // Current animation frame
image_speed = 0;              // Animation speed


// Frame data and sprite maps for special actions
action_frame_data = ds_map_create();
action_sprite_body = ds_map_create();
action_sprite_color = ds_map_create();
action_anim_speed = ds_map_create();

// Sit (8 frames, 24x24, y=72 in spr_player_body)
ds_map_add(action_frame_data, "sit", [
    [0, 72, 24, 24], [24, 72, 24, 24], [48, 72, 24, 24], [72, 72, 24, 24],
    [96, 72, 24, 24], [120, 72, 24, 24], [144, 72, 24, 24], [168, 72, 24, 24]
]);
ds_map_add(action_sprite_body, "sit", spr_player_body);
ds_map_add(action_sprite_color, "sit", spr_player_colour);
ds_map_add(action_anim_speed, "sit", 0); // Static

// Wave (16 frames, 24x24, y=96-120 in spr_player_body)
ds_map_add(action_frame_data, "wave", [
    [0, 96, 24, 24], [24, 96, 24, 24], [48, 96, 24, 24], [72, 96, 24, 24],
    [96, 96, 24, 24], [120, 96, 24, 24], [144, 96, 24, 24], [168, 96, 24, 24],
    [0, 120, 24, 24], [24, 120, 24, 24], [48, 120, 24, 24], [72, 120, 24, 24],
    [96, 120, 24, 24], [120, 120, 24, 24], [144, 120, 24, 24], [168, 120, 24, 24]
]);
ds_map_add(action_sprite_body, "wave", spr_player_body);
ds_map_add(action_sprite_color, "wave", spr_player_colour);
ds_map_add(action_anim_speed, "wave", 0.1); // ~5 FPS

// Dance (56 frames, 24x24, y=144-288 in spr_player_body)
ds_map_add(action_frame_data, "dance", [
    [0, 144, 24, 24], [24, 144, 24, 24], [48, 144, 24, 24], [72, 144, 24, 24], [96, 144, 24, 24], [120, 144, 24, 24], [144, 144, 24, 24], [168, 144, 24, 24],
    [0, 168, 24, 24], [24, 168, 24, 24], [48, 168, 24, 24], [72, 168, 24, 24], [96, 168, 24, 24], [120, 168, 24, 24], [144, 168, 24, 24], [168, 168, 24, 24],
    [0, 192, 24, 24], [24, 192, 24, 24], [48, 192, 24, 24], [72, 192, 24, 24], [96, 192, 24, 24], [120, 192, 24, 24], [144, 192, 24, 24], [168, 192, 24, 24],
    [0, 216, 24, 24], [24, 216, 24, 24], [48, 216, 24, 24], [72, 216, 24, 24], [96, 216, 24, 24], [120, 216, 24, 24], [144, 216, 24, 24], [168, 216, 24, 24],
    [0, 240, 24, 24], [24, 240, 24, 24], [48, 240, 24, 24], [72, 240, 24, 24], [96, 240, 24, 24], [120, 240, 24, 24], [144, 240, 24, 24], [168, 240, 24, 24],
    [0, 264, 24, 24], [24, 264, 24, 24], [48, 264, 24, 24], [72, 264, 24, 24], [96, 264, 24, 24], [120, 264, 24, 24], [144, 264, 24, 24], [168, 264, 24, 24],
    [0, 288, 24, 24], [24, 288, 24, 24], [48, 288, 24, 24], [72, 288, 24, 24], [96, 288, 24, 24], [120, 288, 24, 24], [144, 288, 24, 24], [168, 288, 24, 24]
]);
ds_map_add(action_sprite_body, "dance", spr_player_body);
ds_map_add(action_sprite_color, "dance", spr_player_colour);
ds_map_add(action_anim_speed, "dance", 0.125); // ~4 FPS

// Jackhammer (50 frames, 32x24, spr_player_body_jackhammer)
ds_map_add(action_frame_data, "jackhammer", [
    [0, 0, 32, 24], [32, 0, 32, 24], [64, 0, 32, 24], [96, 0, 32, 24], [128, 0, 32, 24], [160, 0, 32, 24],
    [0, 24, 32, 24], [32, 24, 32, 24], [64, 24, 32, 24], [96, 24, 32, 24], [128, 24, 32, 24], [160, 24, 32, 24],
    [0, 48, 32, 24], [32, 48, 32, 24], [64, 48, 32, 24], [96, 48, 32, 24], [128, 48, 32, 24], [160, 48, 32, 24],
    [0, 72, 32, 24], [32, 72, 32, 24], [64, 72, 32, 24], [96, 72, 32, 24], [128, 72, 32, 24], [160, 72, 32, 24],
    [0, 96, 32, 24], [32, 96, 32, 24], [64, 96, 32, 24], [96, 96, 32, 24], [128, 96, 32, 24], [160, 96, 32, 24],
    [0, 120, 32, 24], [32, 120, 32, 24], [64, 120, 32, 24], [96, 120, 32, 24], [128, 120, 32, 24], [160, 120, 32, 24],
    [0, 144, 32, 24], [32, 144, 32, 24], [64, 144, 32, 24], [96, 144, 32, 24], [128, 144, 32, 24], [160, 144, 32, 24],
    [0, 168, 32, 24], [32, 168, 32, 24], [64, 168, 32, 24], [96, 168, 32, 24], [128, 168, 32, 24], [160, 168, 32, 24],
    [0, 192, 32, 24], [32, 192, 32, 24], [64, 192, 32, 24], [96, 192, 32, 24], [128, 192, 32, 24], [160, 192, 32, 24]
]);
ds_map_add(action_sprite_body, "jackhammer", spr_player_body_jackhammer);
ds_map_add(action_sprite_color, "jackhammer", spr_player_colour_jackhammer);
ds_map_add(action_anim_speed, "jackhammer", 0.15); // ~3.33 FPS

// Snow Shovel (16 frames, 24x48, spr_player_body_snowshovel)
ds_map_add(action_frame_data, "snowshovel", [
    [0, 0, 24, 48], [24, 0, 24, 48], [48, 0, 24, 48], [72, 0, 24, 48], [96, 0, 24, 48], [120, 0, 24, 48], [144, 0, 24, 48], [168, 0, 24, 48],
    [0, 48, 24, 48], [24, 48, 24, 48], [48, 48, 24, 48], [72, 48, 24, 48], [96, 48, 24, 48], [120, 48, 24, 48], [144, 48, 24, 48], [168, 48, 24, 48]
]);
ds_map_add(action_sprite_body, "snowshovel", spr_player_body_snowshovel);
ds_map_add(action_sprite_color, "snowshovel", spr_player_colour_snowshovel);
ds_map_add(action_anim_speed, "snowshovel", 0.1); // ~5 FPS

// Throw (8 frames, 24x24, y=312 in spr_player_body - adjust if needed)
ds_map_add(action_frame_data, "throw", [
    [0, 0, 24, 24], [24, 0, 24, 24], [48, 0, 24, 24], [72, 0, 24, 24],
    [96, 0, 24, 24], [120, 0, 24, 24], [144, 0, 24, 24], [168, 0, 24, 24]
]);
ds_map_add(action_sprite_body, "throw", spr_throwsnowball_body);
ds_map_add(action_sprite_color, "throw", spr_throwsnowball_colour);
ds_map_add(action_anim_speed, "throw", 0.25); // ~2 FPS

// Debugging
show_debug_message("obj_player: Initialized. Driving state: " + string(driving));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player
File: Draw_0.gml
/// Draw Event for obj_player

// Safety check for required global maps
if (!variable_global_exists("equipped_items") || !ds_exists(global.equipped_items, ds_type_map)) {
    show_debug_message("CRITICAL WARNING: global.equipped_items missing! Reinitializing.");
    exit;
}
if (!variable_global_exists("item_sprite_map") || !ds_exists(global.item_sprite_map, ds_type_map)) {
    show_debug_message("CRITICAL WARNING: global.item_sprite_map missing! Reinitializing.");
    exit;
}

// Common drawing variables
var draw_origin_x = x;
var draw_origin_y = y;
var frame_x, frame_y, frame_width, frame_height;
var final_draw_x, final_draw_y;
var current_sprite_body, current_sprite_color;
var draw_xscale = 1; // Default xscale for drawing

// --- State-Based Drawing Logic ---
if (action_state == "none") {
    // --- Walking/Idle State ---
    current_sprite_body = sprite_body;
    current_sprite_color = sprite_color;
    var frame_index = floor(image_index) mod 3; // 3 frames per direction

    // Validate frame data access for walking
    if (face >= 0 && face < array_length(frame_data) && is_array(frame_data[face]) && array_length(frame_data[face]) > (frame_index * 4 + 3)) {
        // Get the correct frame coordinates DIRECTLY from frame_data based on face
        // This selects the pre-drawn left or right facing frame section
        frame_x = frame_data[face][frame_index * 4];
        frame_y = frame_data[face][frame_index * 4 + 1];
        frame_width = frame_data[face][frame_index * 4 + 2];
        frame_height = frame_data[face][frame_index * 4 + 3];
    } else {
        show_debug_message("Warning: Invalid face/frame_data for walking.");
        frame_x = 0; frame_y = 0; frame_width = 24; frame_height = 24; // Fallback
    }

    // Calculate final drawing position (centering based on frame dimensions)
    // Since frame_data selects the correct L/R frame, xscale is always 1 here.
    final_draw_x = draw_origin_x - (frame_width / 2);
    final_draw_y = draw_origin_y - frame_height / 2;
    draw_xscale = 1; // Explicitly set to 1 for walking state draw calls

    // Draw Base Player (Walking) - Using draw_xscale = 1
    draw_sprite_part_ext(current_sprite_body, 0, frame_x, frame_y, frame_width, frame_height, final_draw_x, final_draw_y, draw_xscale, 1, c_white, 1);
    draw_sprite_part_ext(current_sprite_color, 0, frame_x, frame_y, frame_width, frame_height, final_draw_x, final_draw_y, draw_xscale, 1, global.player_color, 1);

    // Draw Equipped Items (Walking) - Using draw_xscale = 1
    var slots_to_draw = ["body", "face", "head", "neck", "hand", "feet"];
    for (var i = 0; i < array_length(slots_to_draw); i++) {
        var slot = slots_to_draw[i];
        var item_name = global.equipped_items[? slot];
        if (!is_undefined(item_name) && item_name != -1) {
            var item_sprite = ds_map_find_value(global.item_sprite_map, item_name);
            if (!is_undefined(item_sprite) && sprite_exists(item_sprite)) {
                var item_draw_x = final_draw_x;
                var item_draw_y = final_draw_y;
                 if (slot == "head") item_draw_y -= 0; // Adjust offsets as needed
                 if (slot == "face") item_draw_y -= 0;

                // Draw item using the SAME frame coordinates and draw_xscale=1
                draw_sprite_part_ext(item_sprite, 0, frame_x, frame_y, frame_width, frame_height, item_draw_x, item_draw_y, draw_xscale, 1, c_white, 1);
            }
        }
    }

} else {
    // --- Special Action State ---
    // Determine flipping for actions (may differ from walking)
    var action_xscale = (face == LEFT || face == UP_LEFT || face == DOWN_LEFT) ? -1 : 1;

    if (ds_map_exists(action_frame_data, action_state)) {
        var frames = ds_map_find_value(action_frame_data, action_state);
        var frame_count = array_length(frames);
        var frame_index = floor(image_index) mod frame_count;

        if (action_state == "sit") { // Static sit pose needs special frame mapping
            var sit_frame_map = [6, 4, 2, 0, 7, 5, 1, 3]; // Map RIGHT=0 to frame 6, etc.
            if (face >= 0 && face < array_length(sit_frame_map)) {
                 frame_index = clamp(sit_frame_map[face], 0, frame_count - 1);
                 // Sitting doesn't typically flip, override action_xscale
                 action_xscale = 1;
                 // Use frame_data to get sit coords, NOT action_frame_data for sit
                  if (frame_index < array_length(frames) && is_array(frames[frame_index]) && array_length(frames[frame_index]) >= 4) {
                       var frame_data_array = frames[frame_index];
                       frame_x = frame_data_array[0];
                       frame_y = frame_data_array[1];
                       frame_width = frame_data_array[2];
                       frame_height = frame_data_array[3];
                  } else { frame_x = 0; frame_y = 72; frame_width = 24; frame_height = 24; } // Fallback sit frame

            } else {
                 frame_index = 0; // Default sit frame
                 show_debug_message("Warning: Invalid face (" + string(face) + ") for sit animation.");
                 // Use default sit frame data
                 frame_x = 0; frame_y = 72; frame_width = 24; frame_height = 24;
                 action_xscale = 1;
            }
        } else { // Other animated actions
             if (frame_index < array_length(frames) && is_array(frames[frame_index]) && array_length(frames[frame_index]) >= 4) {
                 var frame_data_array = frames[frame_index];
                 frame_x = frame_data_array[0];
                 frame_y = frame_data_array[1];
                 frame_width = frame_data_array[2];
                 frame_height = frame_data_array[3];
             } else {
                  show_debug_message("Warning: Invalid frame_index/data for action '" + action_state + "'.");
                  frame_x = 0; frame_y = 0; frame_width = 24; frame_height = 24; // Fallback
             }
        }

        current_sprite_body = ds_map_find_value(action_sprite_body, action_state);
        current_sprite_color = ds_map_find_value(action_sprite_color, action_state);

        // Calculate final drawing position for action state, considering potential flipping
        final_draw_x = draw_origin_x - (frame_width / 2) * action_xscale; // Use action_xscale
        final_draw_y = draw_origin_y - frame_height / 2;
        draw_xscale = action_xscale; // Use the calculated scale for actions

        // Draw Base Player (Action)
        draw_sprite_part_ext(current_sprite_body, 0, frame_x, frame_y, frame_width, frame_height, final_draw_x, final_draw_y, draw_xscale, 1, c_white, 1);
        draw_sprite_part_ext(current_sprite_color, 0, frame_x, frame_y, frame_width, frame_height, final_draw_x, final_draw_y, draw_xscale, 1, global.player_color, 1);

        // Draw Equipped Items (Action)
        var slots_to_draw = ["body", "face", "head", "neck", "hand", "feet"];
        for (var i = 0; i < array_length(slots_to_draw); i++) {
            var slot = slots_to_draw[i];
            var item_name = global.equipped_items[? slot];
            if (!is_undefined(item_name) && item_name != -1) {
                var item_sprite = ds_map_find_value(global.item_sprite_map, item_name);
                if (!is_undefined(item_sprite) && sprite_exists(item_sprite)) {
                    var item_draw_x = final_draw_x;
                    var item_draw_y = final_draw_y;
                     if (slot == "head") item_draw_y -= 0;
                     if (slot == "face") item_draw_y -= 0;

                    // Draw item using action frame coordinates and draw_xscale
                    draw_sprite_part_ext(item_sprite, 0, frame_x, frame_y, frame_width, frame_height, item_draw_x, item_draw_y, draw_xscale, 1, c_white, 1);
                }
            }
        }
    } else {
        // Fallback if action_state is invalid
        show_debug_message("Warning: Invalid action_state '" + action_state + "' in Draw event. Reverting.");
        action_state = "none";
        // Draw default frame (using xscale = 1)
        frame_x = 0; frame_y = 0; frame_width = 24; frame_height = 24;
        final_draw_x = draw_origin_x - (frame_width / 2);
        final_draw_y = draw_origin_y - frame_height / 2;
        draw_xscale = 1;
        draw_sprite_part_ext(sprite_body, 0, frame_x, frame_y, frame_width, frame_height, final_draw_x, final_draw_y, draw_xscale, 1, c_white, 1);
        draw_sprite_part_ext(sprite_color, 0, frame_x, frame_y, frame_width, frame_height, final_draw_x, final_draw_y, draw_xscale, 1, global.player_color, 1);
    }
}

// --- Depth Sorting ---
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player
File: Step_0.gml
// --- obj_player: Step Event 0 ---

// --- Pause Checks ---
if (global.game_paused || global.is_pause_menu_active || global.chat_active) {
    exit;
}

// --- Inventory Check Example ---
if (instance_exists(obj_inventory)) {
    if (obj_inventory.inventory_has("Wrench")) {
        // Do something if the player has a wrench
    }
}

// --- Action Handling ---
// Handle starting special actions (only when not driving and not already in an action)
if (!driving && action_state == "none") {
    if (keyboard_check_pressed(ord("H"))) {
        action_state = "dance";
        action_timer = 0;
        action_duration = 224;
        image_index = 0;
        show_debug_message("Player Action: Starting dance");
    } else if (keyboard_check_pressed(ord("J"))) {
        action_state = "wave";
        action_timer = 0;
        action_duration = 80;
        image_index = 0;
        show_debug_message("Player Action: Starting wave");
    } else if (keyboard_check_pressed(ord("K"))) {
         // Check if already sitting to toggle off
         if (action_state == "sit" && sit_delay <= 0) { // Allow toggle off only after short delay
            action_state = "none";
            image_speed = 0; // Resume normal animation handling potentially
            show_debug_message("Player Action: Stopped sitting");
         } else if (action_state == "none") { // Only start sitting if not already sitting
             action_state = "sit";
             action_timer = 0;
             action_duration = -1; // Infinite duration
             image_index = 0;
             image_speed = 0;      // Sit is static
             sit_delay = 5;        // Delay before toggle-off is allowed
             show_debug_message("Player Action: Starting sit");
         }
    } else if (keyboard_check_pressed(ord("B"))) {
        if (instance_exists(obj_inventory) && obj_inventory.inventory_has("Jackhammer")) { // Use corrected check
            action_state = "jackhammer";
            action_timer = 0;
            action_duration = 150;
            image_index = 0;
            show_debug_message("Player Action: Starting jackhammer");
        } else {
            show_debug_message("Player Action: Cannot start jackhammer: Item not in inventory.");
        }
    } else if (keyboard_check_pressed(ord("N"))) {
        if (instance_exists(obj_inventory) && obj_inventory.inventory_has("Snow Shovel")) { // Use corrected check
            action_state = "snowshovel";
            action_timer = 0;
            action_duration = 80;
            image_index = 0;
            show_debug_message("Player Action: Starting snow shovel");
        } else {
            show_debug_message("Player Action: Cannot start snow shovel: Item not in inventory.");
        }
    } else if (keyboard_check_pressed(ord("O"))) { // Throw Snowball
        action_state = "throw";
        action_timer = 0;
        action_duration = 24; // Adjust based on your throw animation frames
        image_index = 0;
        // image_speed = ds_map_find_value(action_anim_speed, "throw"); // Speed is handled in the block below
        show_debug_message("Player Action: Starting throw");

        // Create snowball projectile
        var snowball = instance_create_layer(x, y, "Instances", obj_snowball); // Ensure "Instances" layer exists
        switch (face) { // Set direction based on player facing
             case RIGHT: snowball.direction = 0; break;
             case LEFT: snowball.direction = 180; break;
             case UP: snowball.direction = 90; break;
             case DOWN: snowball.direction = 270; break;
             case UP_RIGHT: snowball.direction = 45; break;
             case UP_LEFT: snowball.direction = 135; break;
             case DOWN_RIGHT: snowball.direction = 315; break;
             case DOWN_LEFT: snowball.direction = 225; break;
             default: snowball.direction = 270; // Default down
        }
        snowball.speed = 5; // Example speed
    }
}

// Manage ongoing special actions
if (action_state != "none") {
    xspd = 0; // Prevent movement during actions
    yspd = 0;
    image_speed = ds_map_find_value(action_anim_speed, action_state); // Set animation speed for the current action

    action_timer++; // Increment timer for actions with duration

    // Handle sit toggle-off delay
    if (action_state == "sit") {
        image_speed = 0; // Sit is static
        if (sit_delay > 0) {
            sit_delay--;
        }
        // Allow toggling off sit with 'K'
        if (keyboard_check_pressed(ord("K")) && sit_delay <= 0) {
             action_state = "none";
             show_debug_message("Player Action: Stopped sitting");
        }
    } else {
         // For actions with a set duration
         if (action_duration > 0 && action_timer >= action_duration) {
            action_state = "none";
            show_debug_message("Player Action: Action '" + action_state + "' finished by duration.");
        }
    }

    // Animate
    image_index += image_speed;
    var frames = ds_map_find_value(action_frame_data, action_state);
    var frame_count = is_array(frames) ? array_length(frames) : 0;
    if (frame_count > 0 && image_index >= frame_count) {
         if (action_state == "throw" || action_state == "wave" || action_state == "jackhammer" || action_state == "snowshovel" ) { // End non-looping animations
             action_state = "none";
             image_index = 0;
             image_speed = 0; // Stop animation explicitly
             show_debug_message("Player Action: Action '" + action_state + "' finished by animation loop.");
         } else {
             image_index = 0; // Loop animation for actions like dance
         }
    }
} else {
    // --- Handle Movement (Simplified Collision - WHEN NOT IN ACTION) ---
    var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
    var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
    var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
    var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

    // Calculate intended movement based on input and speed
    var move_dx = (right_key - left_key) * move_spd;
    var move_dy = (down_key - up_key) * move_spd;

    // Sliding logic could modify move_dx/dy here if implemented

    // Determine facing direction based on intended movement
    var is_moving = (move_dx != 0 || move_dy != 0);
    if (is_moving) {
         if (move_dy < 0) {
             if (move_dx < 0) { face = UP_LEFT; } else if (move_dx > 0) { face = UP_RIGHT; } else { face = UP; }
         } else if (move_dy > 0) {
             if (move_dx < 0) { face = DOWN_LEFT; } else if (move_dx > 0) { face = DOWN_RIGHT; } else { face = DOWN; }
         } else {
             if (move_dx > 0) { face = RIGHT; } else if (move_dx < 0) { face = LEFT; }
         }
    }

    // --- Simple Collision Check ---
    // Check X-axis collision
    if (place_meeting(x + move_dx, y, obj_wall)) {
        // Move pixel by pixel until collision
        while (!place_meeting(x + sign(move_dx), y, obj_wall)) {
            x += sign(move_dx);
        }
        move_dx = 0; // Stop horizontal movement
    }
    // Apply horizontal movement if no collision
    x += move_dx;

    // Check Y-axis collision
    if (place_meeting(x, y + move_dy, obj_wall)) {
         // Move pixel by pixel until collision
        while (!place_meeting(x, y + sign(move_dy), obj_wall)) {
            y += sign(move_dy);
        }
        move_dy = 0; // Stop vertical movement
    }
    // Apply vertical movement if no collision
    y += move_dy;
    // --- End Simple Collision Check ---


    // --- Animate Walking ---
    if (is_moving) { // Animate only if there was input intention
        image_speed = 0.15; // << START ADJUSTING THIS VALUE (e.g., 0.1, 0.12, 0.18, 0.2)
        image_index += image_speed;
        if (image_index >= 3) {
             image_index -= 3; // Loop smoothly
        }
    } else {
        image_speed = 0;
        image_index = 0; // Idle frame
    }
} // End else (action_state == "none")

// --- Other Interactions (Only when not in an action) ---
// These should ideally check if action_state == "none" too
if (action_state == "none") {
     // Repair Ice Truck (Now requires check on obj_icetruck_broken) - This logic might be better ON the truck object
     if (keyboard_check_pressed(ord("R"))) {
        var broken_truck = instance_place(x, y, obj_icetruck_broken);
        if (broken_truck != noone) {
             // Trigger repair on the truck object itself if requirements met
             // The truck object will handle consuming items via obj_inventory.inventory_remove()
             with(broken_truck) {
                event_perform(ev_other, ev_user0); // Example: Trigger a user event for repair attempt
             }
        }
     }

     // Enter/Exit Tube/Toboggan/Truck - Keep this logic here or move to obj_controller
     if (keyboard_check_pressed(ord("T"))) {
         if (instance_exists(obj_controller)) {
             if (global.current_skin == "player" && instance_exists(obj_inventory) && obj_inventory.inventory_has("Tube")) {
                 if(obj_controller.switch_skin("tube")) {
                     // Remove tube from inventory AFTER successful switch
                     obj_inventory.inventory_remove("Tube");
                 }
             } else if (global.current_skin == "tube") {
                  if(obj_controller.switch_skin("player")) {
                      // Add tube back AFTER successful switch
                      obj_inventory.inventory_add("Tube");
                  }
             } else if (global.current_skin == "player" && instance_exists(obj_inventory) && obj_inventory.inventory_has("Toboggan")) {
                 if(obj_controller.switch_skin("toboggan")) {
                     obj_inventory.inventory_remove("Toboggan");
                 }
             } else if (global.current_skin == "toboggan") {
                  if(obj_controller.switch_skin("player")) {
                      obj_inventory.inventory_add("Toboggan");
                  }
             }
         }
     }

     if (keyboard_check_pressed(ord("E"))) {
         var truck_nearby = instance_place(x, y, obj_icetruck); // Use instance_place for better check
         if (instance_exists(obj_controller)) {
             if (truck_nearby != noone && global.current_skin == "player") {
                 obj_controller.switch_skin("icetruck");
             }
             // Exit truck logic should be in obj_player_icetruck's step event
         }
     }
      // Interact with Puffle
     if (keyboard_check_pressed(ord("E"))) {
         var puffle_nearby = instance_place(x,y, obj_puffle);
         if (puffle_nearby != noone) {
             // Let the puffle handle the interaction logic
              with(puffle_nearby){
                  event_perform(ev_other, ev_user0); // Example: Trigger a user event for interaction
              }
         }
     }
}


// --- Sled Racing Room Visibility Check ---
var is_sled_room = (room == rm_sled_racing);
// This check seems misplaced, player visibility is usually handled by obj_controller or room start events
// if (is_sled_room) {
//     visible = false;
// } else {
//     visible = true;
// }


// --- Depth Sorting ---
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_base
File: Destroy_0.gml
global.player_x = x;
global.player_y = y;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_base
File: Step_0.gml
// obj_player_base Step
global.player_x = x;
global.player_y = y;

xspd = handle_collision("x", xspd);
yspd = handle_collision("y", yspd);
x += xspd;
y += yspd;
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_base
File: Step_2.gml
global.player_x = x;
global.player_y = y;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_colourpicker
File: Create_0.gml
// Create Event
scale = 2; // General scale factor
panel_width = sprite_get_width(spr_colourpicker_panel) * scale;
panel_height = sprite_get_height(spr_colourpicker_panel) * scale;
x = (display_get_gui_width() - panel_width) / 2; // Center horizontally
y = (display_get_gui_height() - panel_height) / 2; // Center vertically
start_x = 100;   // Starting x position (overridden later)
depth = -10000;  // Ensure it’s drawn on top
is_destroying = false; // Flag to prevent drawing after destruction



// Define colors (unchanged)
var c_notblack = make_color_rgb(51, 59, 70);
var c_bluer = make_color_rgb(41, 82, 172);
var c_brown = make_color_rgb(150, 102, 36);
var c_cyan = make_color_rgb(7, 167, 163);
var c_emerald = make_color_rgb(7, 106, 68);
var c_greener = make_color_rgb(6, 155, 77);
var c_lavender = make_color_rgb(176, 126, 194);
var c_lightblue = make_color_rgb(8, 153, 211);
var c_mint = make_color_rgb(189, 252, 201);
var c_oranger = make_color_rgb(232, 94, 28);
var c_pink = make_color_rgb(234, 20, 160);
var c_purpler = make_color_rgb(102, 49, 158);
var c_reder = make_color_rgb(210, 13, 48);
var c_salmon = make_color_rgb(233, 98, 110);
var c_yellower = make_color_rgb(234, 194, 25);

colors = [
    c_notblack, c_bluer, c_brown, c_cyan, c_emerald,
    c_greener, c_lavender, c_lightblue, c_mint, c_oranger,
    c_pink, c_purpler, c_reder, c_salmon, c_yellower
];

sprites = [
    spr_colouricon_black, spr_colouricon_blue, spr_colouricon_brown, spr_colouricon_cyan, spr_colouricon_emerald,
    spr_colouricon_green, spr_colouricon_lavendar, spr_colouricon_lightblue, spr_colouricon_mint, spr_colouricon_orange,
    spr_colouricon_pink, spr_colouricon_purple, spr_colouricon_red, spr_colouricon_salmon, spr_colouricon_yellow
];

// Grid positioning for color icons
icon_size = 20 * scale;  // Intended size of icons in pixels (e.g., 30 with scale 1.5)
spacing = 5 * scale;     // Spacing between icons
var cols = 5;
var rows = 3;
var grid_width = (cols * icon_size) + ((cols - 1) * spacing);
var grid_height = (rows * icon_size) + ((rows - 1) * spacing);
start_x = x + 108 * scale + (135 * scale - grid_width) / 2;
start_y = y + 35 * scale + (115 * scale - grid_height) / 2;

// Calculate icon_scale for proper sizing
var original_icon_width = sprite_get_width(sprites[0]); // Assuming all icons have the same size
icon_scale = icon_size / original_icon_width; // Scale to fit icon_size
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_colourpicker
File: Draw_64.gml
// Draw GUI Event
if (is_destroying) return;

draw_sprite_ext(spr_colourpicker_panel, 0, x, y, scale, scale, 0, c_white, 1);

// Define and visualize the viewer area
var viewer_x = x + 9 * scale;
var viewer_y = y + 35 * scale;
var viewer_width = (83 - 9) * scale;
var viewer_height = (150 - 35) * scale;
draw_rectangle(viewer_x, viewer_y, viewer_x + viewer_width, viewer_y + viewer_height, true); // Outline the viewer area

// Draw player sprite with debugging
if (instance_exists(global.player_instance)) {
    var player_sprite = global.player_instance.sprite_index;
    show_debug_message("Player instance exists, sprite_index: " + string(player_sprite));
    if (player_sprite != -1) {
        var sprite_scale = min(viewer_width / sprite_get_width(player_sprite), viewer_height / sprite_get_height(player_sprite));
        var x_pos = viewer_x + viewer_width / 2 - sprite_get_xoffset(player_sprite) * sprite_scale;
        var y_pos = viewer_y + viewer_height / 2 - sprite_get_yoffset(player_sprite) * sprite_scale;
        
        // Debug output
        show_debug_message("viewer_x: " + string(viewer_x) + ", viewer_y: " + string(viewer_y));
        show_debug_message("viewer_width: " + string(viewer_width) + ", viewer_height: " + string(viewer_height));
        show_debug_message("sprite_scale: " + string(sprite_scale));
        show_debug_message("x_pos: " + string(x_pos) + ", y_pos: " + string(y_pos));
        show_debug_message("sprite origin: (" + string(sprite_get_xoffset(player_sprite)) + ", " + string(sprite_get_yoffset(player_sprite)) + ")");
        
        // Draw with test parameters
        draw_sprite_ext(player_sprite, 0, x_pos, y_pos, sprite_scale, sprite_scale, 0, c_white, 1);
    } else {
        show_debug_message("Player has no sprite assigned.");
    }
} else {
    show_debug_message("Player instance does not exist.");
}

// Draw color icons with adjusted scale
for (var i = 0; i < 15; i++) {
    var col = i mod 5;
    var row = i div 5;
    var icon_x = start_x + col * (icon_size + spacing);
    var icon_y = start_y + row * (icon_size + spacing);
    draw_sprite_ext(sprites[i], 0, icon_x, icon_y, icon_scale, icon_scale, 0, c_white, 1);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_colourpicker
File: Step_0.gml
// Step Event
if (mouse_check_button_pressed(mb_left)) {
    var mx = device_mouse_x_to_gui(0);
    var my = device_mouse_y_to_gui(0);
    
    // Close area
    if (point_in_rectangle(mx, my, x + 98 * scale, y + 1 * scale, x + 156 * scale, y + 11 * scale)) {
        is_destroying = true;
        instance_destroy();
        show_debug_message("Player color picker closed.");
        global.ui_manager.close_ui();
        global.click_handled = true;
        return;
    }
    
    // Color selection
    for (var i = 0; i < 15; i++) {
        var col = i mod 5;
        var row = i div 5;
        var icon_x = start_x + col * (icon_size + spacing);
        var icon_y = start_y + row * (icon_size + spacing);
        if (point_in_rectangle(mx, my, icon_x, icon_y, icon_x + icon_size, icon_y + icon_size)) {
            global.player_color = colors[i];
            if (instance_exists(global.player_instance)) {
                global.player_instance.image_blend = global.player_color;
            }
            is_destroying = true;
            instance_destroy();
            show_debug_message("Player color set to: " + string(colors[i]));
            global.ui_manager.close_ui();
            global.click_handled = true;
            break;
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_icetruck
File: Create_0.gml
// Core variables
xspd = 0;
yspd = 0;
move_spd = 3; // Adjust as needed for ice truck speed
state = "driving"; // Since this is the ice truck, assume driving state
if (!variable_global_exists("player_color")) { global.player_color = c_white; }

// Ice truck-specific tint
icetruck_tint = c_yellow; // Default tint for spr_icetruck_colour

// Direction
face = DOWN;
is_savable = true;

// Sprite definitions
sprite_base = spr_icetruck_base;
sprite_colour = spr_icetruck_colour;
sprite_penguin = spr_icetruck_penguin_colour;
sprite_window_tint = spr_icetruck_window
mask_index = spr_icetruck_down; // Use base sprite for collisions
sprite_index = spr_icetruck_base;

// Animation variables
image_index = 0; // Current frame
image_speed = 0.1; // Animation speed (adjust as needed)

// Frame data for driving (96x240 sprite sheet: 2 frames per direction)
frame_data = array_create(8); // Array for 8 directions
// [frame1_x, frame1_y, width, height, frame2_x, frame2_y, width, height]
frame_data[DOWN] = [0, 0, 48, 48, 48, 0, 48, 48];           // Row 1
frame_data[DOWN_RIGHT] = [0, 48, 48, 48, 48, 48, 48, 48];  // Row 2
frame_data[RIGHT] = [0, 96, 48, 48, 48, 96, 48, 48];       // Row 3
frame_data[UP_RIGHT] = [0, 144, 48, 48, 48, 144, 48, 48];  // Row 4
frame_data[UP] = [0, 192, 48, 48, 48, 192, 48, 48];        // Row 5
// Left-facing directions will use right-facing frames with flipping
frame_data[DOWN_LEFT] = frame_data[DOWN_RIGHT];
frame_data[LEFT] = frame_data[RIGHT];
frame_data[UP_LEFT] = frame_data[UP_RIGHT];

// Debugging
if (place_meeting(x, y, obj_wall)) {
    show_debug_message("Icetruck colliding with wall at position (" + string(x) + ", " + string(y) + ")");
}

show_debug_message("obj_player_icetruck: Initialized.");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_icetruck
File: Draw_0.gml
var draw_x = x;
var draw_y = y;
var frame_index = floor(image_index) mod 2; // 2 frames per direction
var frame_x = frame_data[face][frame_index * 4];
var frame_y = frame_data[face][frame_index * 4 + 1];
var frame_width = frame_data[face][frame_index * 4 + 2];
var frame_height = frame_data[face][frame_index * 4 + 3];

// Determine if flipping is needed
var xscale = 1;
if (face == LEFT || face == DOWN_LEFT || face == UP_LEFT) {
    xscale = -1;
}

// Center the sprite
draw_x -= (frame_width / 2) * xscale;
draw_y -= frame_height / 2;

// Draw all three layers
draw_sprite_part_ext(sprite_base, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, c_white, 1);
draw_sprite_part_ext(sprite_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, icetruck_tint, 1);
draw_sprite_part_ext(sprite_penguin, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, global.player_color, 1);
draw_sprite_part_ext(sprite_window_tint, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, c_white, 1);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_icetruck
File: Step_0.gml
// Step Event for obj_player_icetruck
// Prevent movement when paused or colour picker is open
if (global.is_pause_menu_active || instance_exists(obj_icetruck_colourpicker) || instance_exists(obj_inventory_expanded)) {
    show_debug_message("Paused or Colour Picker Open: " + string(instance_exists(obj_icetruck_colourpicker) + instance_exists(obj_inventory_expanded)));
    exit;
}

// Handle exiting the truck
if (keyboard_check_pressed(ord("E"))) {
    if (!place_meeting(x, y, obj_icetruck)) {
        var exit_x = x;
        var exit_y = y + 16;
        instance_destroy(id);
        global.player_instance = instance_create_layer(exit_x, exit_y, "Instances", obj_player);
        instance_create_layer(x, y, "Instances", obj_icetruck);
        if (instance_exists(obj_controller)) {
            obj_controller.switch_skin("player"); // Prefixed call
        }
        show_debug_message("Exited ice truck. Current skin: " + global.current_skin);
    } else {
        show_debug_message("No space to exit!");
    }
}

// Handle movement input
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

xspd = (right_key - left_key) * move_spd;
yspd = (down_key - up_key) * move_spd;

// Update direction and animation
if (xspd != 0 || yspd != 0) {
    if (yspd < 0) {
        if (xspd < 0) { face = UP_LEFT; }
        else if (xspd > 0) { face = UP_RIGHT; }
        else { face = UP; }
    } else if (yspd > 0) {
        if (xspd < 0) { face = DOWN_LEFT; }
        else if (xspd > 0) { face = DOWN_RIGHT; }
        else { face = DOWN; }
    } else {
        if (xspd > 0) { face = RIGHT; }
        else if (xspd < 0) { face = LEFT; }
    }
    image_speed = 0.1;
    image_index += image_speed;
    if (image_index >= 2) image_index = 0;
} else {
    image_speed = 0;
    image_index = 0;
}

// Apply collision handling
// Apply collision handling
if (place_meeting(x + xspd, y, obj_wall)) xspd = 0;
if (place_meeting(x, y + yspd, obj_wall)) yspd = 0;
x += handle_collision("x", xspd);
y += handle_collision("y", yspd);

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_ninja
File: Create_0.gml
// Create Event for obj_player_ninja

// Core variables
xspd = 0;
yspd = 0;
move_spd = 3;

// Sliding variables
sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;

// Driving variables
driving = false;
ice_truck_sprite = spr_icetruck_facedown;
original_sprite = sprite_index;

// Set direction and sprites
face = DOWN;
init_sprites(spr_ninja_right, spr_ninja_up, spr_ninja_left, spr_ninja_down, spr_ninja_up_right, spr_ninja_up_left, spr_ninja_down_right, spr_ninja_down_left);

// Debugging
show_debug_message("obj_player_ninja: Initialized. Driving state: " + string(driving));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_ninja
File: Step_0.gml
// Step Event for obj_player
// Prevent player movement and interactions when paused
if (global.is_pause_menu_active) {
    exit; // This prevents the player from updating while paused
}

// Handle interaction with NPC
if (keyboard_check_pressed(ord("E"))) {
    var target_npc = instance_nearest(x, y, obj_npc_old); // Find the nearest NPC
    if (target_npc != noone && distance_to_object(target_npc) < 48) { // Check proximity
        target_npc.current_phrase = target_npc.phrases[irandom_range(0, array_length(target_npc.phrases) - 1)]; // Pick a random phrase
        target_npc.talk_timer = fps * 3; // Show the phrase for 3 seconds
        target_npc.interact_pause = fps * 3; // Pause NPC movement for 3 seconds
        show_debug_message("Player interacted with NPC. NPC says: " + target_npc.current_phrase);
    }
}

// Handle skin switching
if (keyboard_check_pressed(ord("E"))) {
    if (distance_to_object(obj_icetruck) < 32) {
        show_debug_message("E key pressed");
        obj_controller.switch_skin(global.current_skin == "player" ? "icetruck" : "player");
    } else if (distance_to_object(obj_tube) < 32) {
        show_debug_message("E key pressed");
        obj_controller.switch_skin(global.current_skin == "player" ? "tube" : "player");
    }
}

// Handle movement input
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

// Get xspd & yspd
if (!sliding) {
    xspd = (right_key - left_key) * move_spd;
    yspd = (down_key - up_key) * move_spd;
} else {
    // Continue sliding
    xspd = slide_dir_x * slide_speed;
    yspd = slide_dir_y * slide_speed;

    // Decelerate slide over time
    slide_speed *= 0.98; // Adjust this value to control sliding deceleration

    // Stop sliding if speed is low enough
    if (abs(slide_speed) < 0.1) {
        sliding = false;
        xspd = 0;
        yspd = 0;
    }
}

// Pause
if (instance_exists(obj_pauser)) {
    xspd = 0;
    yspd = 0;
}

// Set sprite
mask_index = sprite[DOWN];
if (yspd < 0) {
    if (xspd < 0) { face = UP_LEFT; }
    else if (xspd > 0) { face = UP_RIGHT; }
    else { face = UP; }
} else if (yspd > 0) {
    if (xspd < 0) { face = DOWN_LEFT; }
    else if (xspd > 0) { face = DOWN_RIGHT; }
    else { face = DOWN; }
} else {
    if (xspd > 0) { face = RIGHT; }
    else if (xspd < 0) { face = LEFT; }
}

sprite_index = sprite[face];

// Collisions
xspd = handle_collision("x", xspd);
yspd = handle_collision("y", yspd);

// Move the player
x += xspd;
y += yspd;

// Animate
if (xspd == 0 && yspd == 0) {
    image_index = 0;
}

// Depth
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_toboggan
File: Create_0.gml
xspd = 0;
yspd = 0;
move_spd = 1.5; // Same as tube, adjust if desired
sliding = true;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 3;
face = DOWN;
is_savable = true;

// Define sprite positions for spr_toboggan_sheet
toboggan_sprites = array_create(8);
toboggan_sprites[DOWN] = [0, 0];
toboggan_sprites[UP] = [24, 0];
toboggan_sprites[DOWN_RIGHT] = [48, 0];
toboggan_sprites[UP_LEFT] = [72, 0];
toboggan_sprites[LEFT] = [96, 0];
toboggan_sprites[RIGHT] = [120, 0];
toboggan_sprites[UP_RIGHT] = [144, 0];
toboggan_sprites[DOWN_LEFT] = [168, 0];

mask_index = spr_tube_down; // Create this sprite if not already present
sprite_index = spr_toboggan_sheet;
global.player_instance = id;
global.current_skin = "Toboggan";
show_debug_message("obj_player_toboggan: Initialized. Player instance ID: " + string(id));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_toboggan
File: Draw_0.gml
// --- obj_player_toboggan: Draw Event (Draw_0.gml) ---

// Define sprite frame width/height (assuming 24x24 base)
var frame_w = 24;
var frame_h = 24;
// Calculate centered draw coordinates
var draw_cx = floor(x - frame_w/2);
var draw_cy = floor(y - frame_h/2);

// --- 1. Toboggan Sprite ---
// Get the toboggan's sprite frame based on face direction
var toboggan_frame_x = toboggan_sprites[face][0];
var toboggan_frame_y = toboggan_sprites[face][1];
draw_sprite_part(spr_toboggan_sheet, 0, toboggan_frame_x, toboggan_frame_y, frame_w, frame_h, draw_cx, draw_cy);

// --- 2. Sitting Player Sprite (Using Coordinate Lookup) ---
// Explicitly define the coordinates for each sitting pose direction from spr_player_body sheet
var sitting_sprites = array_create(8);
sitting_sprites[DOWN]       = [0,   72];
sitting_sprites[DOWN_LEFT]  = [24,  72];
sitting_sprites[LEFT]       = [48,  72];
sitting_sprites[UP_LEFT]    = [72,  72];
sitting_sprites[UP]         = [96,  72];
sitting_sprites[UP_RIGHT]   = [120, 72];
sitting_sprites[RIGHT]      = [144, 72];
sitting_sprites[DOWN_RIGHT] = [168, 72];

// Get the specific X, Y from the player sprite sheet for the current face direction
var sit_frame_x = sitting_sprites[face][0];
var sit_frame_y = sitting_sprites[face][1];

// Draw player body & color overlay using the looked-up sitting frame
draw_sprite_part_ext(spr_player_body, 0, sit_frame_x, sit_frame_y, frame_w, frame_h, draw_cx, draw_cy, 1, 1, c_white, 1);
draw_sprite_part_ext(spr_player_colour, 0, sit_frame_x, sit_frame_y, frame_w, frame_h, draw_cx, draw_cy, 1, 1, global.player_color, 1);

// --- 3. Draw Equipped Items (using Player Sitting Frame) ---
// Check required global maps exist
if (ds_exists(global.equipped_items, ds_type_map) && ds_exists(global.item_sprite_map, ds_type_map)) {
    // Define which slots to draw & their draw order (body first, head last)
    var slots_to_draw = ["body", "neck", "face", "head"]; // Render order matters!
    for (var i = 0; i < array_length(slots_to_draw); i++) {
        var slot = slots_to_draw[i];
        var item_name = global.equipped_items[? slot]; // Get item name for the slot

        // Check if an item is actually equipped in this slot
        if (!is_undefined(item_name) && item_name != -1) {
            var item_sprite = ds_map_find_value(global.item_sprite_map, item_name); // Get the item's equipped sprite

            // Check if the sprite resource exists
            if (!is_undefined(item_sprite) && sprite_exists(item_sprite)) {
                // Draw the item sprite using the *looked-up player sitting frame* coordinates
                // This ensures the item aligns correctly with the sitting player pose
                draw_sprite_part_ext(item_sprite, 0, sit_frame_x, sit_frame_y, frame_w, frame_h, draw_cx, draw_cy, 1, 1, c_white, 1);
            }
        }
    }
} else {
    // Log error if critical maps are missing
    show_debug_message("Draw Toboggan ERROR: Missing global maps (equipped_items or item_sprite_map)");
}

// --- 4. Depth Sorting ---
set_depth(); // Apply depth sorting based on Y coordinate
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_toboggan
File: Step_0.gml
// --- obj_player_toboggan: Step Event ---
if (global.is_pause_menu_active) exit;

// Exit toboggan
if (keyboard_check_pressed(ord("T"))) {
    // Check skin and that a switch isn't already happening
    if (global.current_skin == "toboggan" && !global.skin_switching) {
        // Ensure inventory exists and add item back
        if (instance_exists(obj_inventory)) {
            obj_inventory.inventory_add("Toboggan");
        } else {
             show_debug_message("WARNING: obj_inventory not found when exiting toboggan!");
        }
        show_debug_message("Exiting toboggan, switching back to player...");
        // *** CALL obj_controller's method ***
        if (instance_exists(obj_controller)) {
            obj_controller.switch_skin("player"); // Correct way to call
        } else {
            show_debug_message("ERROR: obj_controller not found for skin switch!");
            // Fallback: might need to manually destroy/recreate player if controller lost
        }
        // NOTE: switch_skin handles destroying the old instance (the toboggan)
    }
}

// Movement input
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);
xspd = (right_key - left_key) * move_spd;
yspd = (down_key - up_key) * move_spd;

// Pause check
if (instance_exists(obj_pauser)) {
    xspd = 0;
    yspd = 0;
}

// Update direction
if (xspd != 0 || yspd != 0) {
    if (xspd > 0 && yspd == 0) face = RIGHT;
    else if (xspd < 0 && yspd == 0) face = LEFT;
    else if (yspd > 0 && xspd == 0) face = DOWN;
    else if (yspd < 0 && xspd == 0) face = UP;
    else if (xspd > 0 && yspd > 0) face = DOWN_RIGHT;
    else if (xspd > 0 && yspd < 0) face = UP_RIGHT;
    else if (xspd < 0 && yspd > 0) face = DOWN_LEFT;
    else if (xspd < 0 && yspd < 0) face = UP_LEFT;
}

// Collision handling
if (place_meeting(x + xspd, y, obj_wall)) xspd = 0;
if (place_meeting(x, y + yspd, obj_wall)) yspd = 0;

// Apply movement
if (irandom(1) == 0) {
    x += handle_collision("x", xspd * move_spd);
    y += handle_collision("y", yspd * move_spd);
} else {
    y += handle_collision("y", yspd * move_spd);
    x += handle_collision("x", xspd * move_spd);
}

// Depth sorting
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_tube
File: Create_0.gml
// Create Event for obj_player_tube

// Core variables
xspd = 0;
yspd = 0;
move_spd = 1.5;
sliding = true;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 3;

// Set direction
face = DOWN;

// Define sprite positions for the tube
tube_sprites = array_create(8);
tube_sprites[UP] = [0, 0];        
tube_sprites[LEFT] = [0, 0];      
tube_sprites[DOWN] = [24, 0];     
tube_sprites[RIGHT] = [24, 0];    
tube_sprites[UP_LEFT] = [48, 0];  
tube_sprites[DOWN_RIGHT] = [48, 0];
tube_sprites[DOWN_LEFT] = [72, 0]; 
tube_sprites[UP_RIGHT] = [72, 0];

// Ensure a valid face direction
if (!array_length(tube_sprites[face])) {
    face = DOWN; // Default if invalid
}

mask_index = spr_tube_down; // Ensure collision works

// Set global player instance
global.player_instance = id;
global.current_skin = "tube";
sprite_index = spr_tube_sheet;
is_savable = true;

// Debugging
show_debug_message("obj_player_tube: Initialized. Player instance ID: " + string(id));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_tube
File: Draw_0.gml
// --- obj_player_tube: Draw Event (Draw_0.gml) ---

// Define sprite frame width/height (assuming 24x24 base)
var frame_w = 24;
var frame_h = 24;
// Calculate centered draw coordinates
var draw_cx = floor(x - frame_w/2);
var draw_cy = floor(y - frame_h/2);

// --- 1. Tube Sprite ---
// Get the tube's sprite frame based on face direction
var tube_frame_x = tube_sprites[face][0];
var tube_frame_y = tube_sprites[face][1];
draw_sprite_part(spr_tube_sheet, 0, tube_frame_x, tube_frame_y, frame_w, frame_h, draw_cx, draw_cy);

// --- 2. Sitting Player Sprite (Using Coordinate Lookup) ---
// Explicitly define the coordinates for each sitting pose direction from spr_player_body sheet
var sitting_sprites = array_create(8);
sitting_sprites[DOWN]       = [0,   72];
sitting_sprites[DOWN_LEFT]  = [24,  72];
sitting_sprites[LEFT]       = [48,  72];
sitting_sprites[UP_LEFT]    = [72,  72];
sitting_sprites[UP]         = [96,  72];
sitting_sprites[UP_RIGHT]   = [120, 72];
sitting_sprites[RIGHT]      = [144, 72];
sitting_sprites[DOWN_RIGHT] = [168, 72];

// Get the specific X, Y from the player sprite sheet for the current face direction
var sit_frame_x = sitting_sprites[face][0];
var sit_frame_y = sitting_sprites[face][1];

// Draw player body & color overlay using the looked-up sitting frame
draw_sprite_part_ext(spr_player_body, 0, sit_frame_x, sit_frame_y, frame_w, frame_h, draw_cx, draw_cy, 1, 1, c_white, 1);
draw_sprite_part_ext(spr_player_colour, 0, sit_frame_x, sit_frame_y, frame_w, frame_h, draw_cx, draw_cy, 1, 1, global.player_color, 1);

// --- 3. Draw Equipped Items (using Player Sitting Frame) ---
// Check required global maps exist
if (ds_exists(global.equipped_items, ds_type_map) && ds_exists(global.item_sprite_map, ds_type_map)) {
    // Define which slots to draw & their draw order (body first, head last)
    var slots_to_draw = ["body", "neck", "face", "head"]; // Render order matters!
    for (var i = 0; i < array_length(slots_to_draw); i++) {
        var slot = slots_to_draw[i];
        var item_name = global.equipped_items[? slot]; // Get item name for the slot

        // Check if an item is actually equipped in this slot
        if (!is_undefined(item_name) && item_name != -1) {
            var item_sprite = ds_map_find_value(global.item_sprite_map, item_name); // Get the item's equipped sprite

            // Check if the sprite resource exists
            if (!is_undefined(item_sprite) && sprite_exists(item_sprite)) {
                // Draw the item sprite using the *looked-up player sitting frame* coordinates
                // This ensures the item aligns correctly with the sitting player pose
                draw_sprite_part_ext(item_sprite, 0, sit_frame_x, sit_frame_y, frame_w, frame_h, draw_cx, draw_cy, 1, 1, c_white, 1);
            }
        }
    }
} else {
    // Log error if critical maps are missing - this shouldn't happen if init is correct
    show_debug_message("Draw Tube ERROR: Missing global maps (equipped_items or item_sprite_map)");
}

// --- 4. Depth Sorting ---
set_depth(); // Apply depth sorting based on Y coordinate
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_tube
File: Step_0.gml
// Prevent player movement and interactions when paused
if (global.is_pause_menu_active) {
    exit; // This prevents the player from updating while paused
}

// Exit the tube
if (keyboard_check_pressed(ord("T"))) {
    if (global.current_skin == "tube" && !global.skin_switching) {
        obj_inventory.add_to_inventory("Tube");
        show_debug_message("Exiting tube, switching back to player...");
        var old_instance = id; // Store old instance ID
        if (instance_exists(obj_controller)) {
            obj_controller.switch_skin("player"); // Prefixed call
        }
        // Destroy old instance only after switching
        if (instance_exists(old_instance)) {
            instance_destroy(old_instance);
        }
    }
}


// Handle movement input
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

xspd = (right_key - left_key) * move_spd;
yspd = (down_key - up_key) * move_spd;

// Disable movement if the game is paused
if (instance_exists(obj_pauser)) {
    xspd = 0;
    yspd = 0;
}

// Update tube direction and sprite only if moving
if (xspd != 0 || yspd != 0) {
    if (xspd > 0 && yspd == 0) face = RIGHT;
    else if (xspd < 0 && yspd == 0) face = LEFT;
    else if (yspd > 0 && xspd == 0) face = DOWN;
    else if (yspd < 0 && xspd == 0) face = UP;
    else if (xspd > 0 && yspd > 0) face = DOWN_RIGHT;
    else if (xspd > 0 && yspd < 0) face = UP_RIGHT;
    else if (xspd < 0 && yspd > 0) face = DOWN_LEFT;
    else if (xspd < 0 && yspd < 0) face = UP_LEFT;
}

// Collision handling
if (place_meeting(x + xspd, y, obj_wall)) xspd = 0;
if (place_meeting(x, y + yspd, obj_wall)) yspd = 0;

// Apply movement
if (irandom(1) == 0) {
    x += handle_collision("x", xspd * move_spd);
    y += handle_collision("y", yspd * move_spd);
} else {
    y += handle_collision("y", yspd * move_spd);
    x += handle_collision("x", xspd * move_spd);
}

// Ensure proper depth sorting
set_depth();

var is_sled_room = (room == rm_sled_racing);
if (is_sled_room) {
    if (instance_exists(obj_player_tube)) {
        with (obj_player_tube) {
            visible = false; // Hide the inventory
        }
        show_debug_message("DEBUG: Player Tube hidden in Sled Racing room.");
    }
} else {
    if (instance_exists(obj_player_tube)) {
        with (obj_player_tube) {
            visible = true; // Show the inventory
        }
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_plaza_complete
File: Step_0.gml
set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_polarbear
File: Create_0.gml
// obj_polarbear Create Event
xspd = 0;
yspd = 0;
move_spd = 1; // SLOWER walking speed
face = PB_UP_LEFT; // Use macro for initial face if needed, but 'face' isn't used by polar bear directly anymore
mood = "passive"; // Start in passive mood
throw_timer = 0;
throw_duration = 96; // Duration of throw animation
throw_frame_duration = 4; // Frames per subimage in throw sheet? Seems fast. Let's keep for now.
throw_interval = 120; // Cooldown between throws
throw_interval_timer = 0;
view_range = 100;
attack_distance = 50;
is_savable = true;
frame_w = 48;
frame_h = 48;

// -- NEW Animation Variables --
walk_anim_speed = 0.1; // SLOWER animation speed (adjust as needed)
idle_anim_speed = 0;   // Idle animation speed (0 for static face)
image_index = 0;       // Current animation frame index
image_speed = 0;       // GMS built-in animation speed control

throw_sprite = noone; // Determined in Step event now

wander_timer = 0; // Timer for wandering direction
stop_timer = 0; // Timer for stopping
is_stopped = false; // Whether the bear is stopped
dist_to_player = 1000; // Initial distance to player

// REMOVED Enum definition here

current_direction = PB_DOWN; // Use Macro for Default direction

// -- NEW: Spritesheet Mapping --
walk_frame_sheets = array_create(8);
walk_frame_sheets[PB_DOWN] = spr_polarbear_walkdown_sheet;
walk_frame_sheets[PB_DOWN_LEFT] = spr_polarbear_walkdownleft_sheet;
walk_frame_sheets[PB_LEFT] = spr_polarbear_walkleft_sheet;
walk_frame_sheets[PB_UP_LEFT] = spr_polarbear_walkupleft_sheet;
walk_frame_sheets[PB_UP] = spr_polarbear_walkup_sheet;
// Right-facing directions will use left-facing sheets and be flipped
walk_frame_sheets[PB_DOWN_RIGHT] = spr_polarbear_walkdownleft_sheet; // Uses down-left sheet
walk_frame_sheets[PB_RIGHT] = spr_polarbear_walkleft_sheet; // Uses left sheet
walk_frame_sheets[PB_UP_RIGHT] = spr_polarbear_walkupleft_sheet; // Uses up-left sheet

// -- Collision Mask Update --
mask_index = spr_polarbear_down; // Use the new specified sprite

set_depth(); // Call set_depth script
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_polarbear
File: Draw_0.gml
   // obj_polarbear Draw Event - REVISED WALK FRAME CALC + DEBUG
   var _frame_w = 48;
   var _frame_h = 48;
   var _draw_x = x;
   var _draw_y = y;
   var _sprite_to_draw = spr_polarbear_face_sheet; // Default fallback
   var _frame_index_to_draw = current_direction;   // Default to face direction index
   var _xscale = 1;                                // Default horizontal scale
   var _final_draw_x = _draw_x - (_frame_w / 2);   // Default centered X
   var _final_draw_y = _draw_y - (_frame_h / 2);   // Default centered Y
   var _cols_per_sheet = 8;                        // Default for face/throw sheets
   var _left = 0;
   var _top = 0;
   var _total_frames_in_sprite = 1; // Default

   // --- DEBUG START ---
   var _debug_draw_state = "Mood: " + mood + ", ThrT: " + string(throw_timer) + ", Stop: " + string(is_stopped) + ", ImgIdx: " + string(image_index) + ", ImgSpd: " + string(image_speed) + ", CurDir: " + string(current_direction);
   // --- DEBUG END ---


   if (mood == "passive" || (mood == "angry" && throw_timer <= 0)) {
       // --- Walking or Idle (or Angry but NOT currently throwing) ---
       var _is_currently_idle = (xspd == 0 && yspd == 0);

       if (_is_currently_idle || is_stopped) {
           _sprite_to_draw = spr_polarbear_face_sheet;
           _total_frames_in_sprite = 8; // Face sheet has 8 frames
           _frame_index_to_draw = current_direction % _total_frames_in_sprite;
           _xscale = 1;
           _cols_per_sheet = 8;
           _debug_draw_state += " | DrawState: IdleFace";
       } else {
           _sprite_to_draw = walk_frame_sheets[current_direction];
           if (!sprite_exists(_sprite_to_draw)) { /* ... fallback ... */
               _debug_draw_state += " | ERROR: Walk sheet invalid for dir " + string(current_direction);
               _sprite_to_draw = spr_polarbear_face_sheet;
               _total_frames_in_sprite = 8;
               _frame_index_to_draw = current_direction % _total_frames_in_sprite;
               _xscale = 1;
               _cols_per_sheet = 8;
           } else {
              // *** MANUALLY USE 40 FRAMES FOR WALK SHEETS ***
              _total_frames_in_sprite = 40; // All walk sheets have 40 frames (8x5 grid)
              _frame_index_to_draw = floor(image_index) % _total_frames_in_sprite;
              // *** END CHANGE ***

              if (current_direction == PB_DOWN_RIGHT || current_direction == PB_RIGHT || current_direction == PB_UP_RIGHT) { _xscale = -1; } else { _xscale = 1; }
              _cols_per_sheet = 8;
              _debug_draw_state += " | DrawState: Walking";
           }
       }

   } else if (mood == "angry" && throw_timer > 0) {
        // --- Throwing State ---
         _sprite_to_draw = throw_sprite;
        if (!sprite_exists(_sprite_to_draw)) { /* ... fallback ... */
             _debug_draw_state += " | ERROR: Invalid throw_sprite! Fallback to face.";
             _sprite_to_draw = spr_polarbear_face_sheet;
             _total_frames_in_sprite = 8; // Use face sheet frame count
             _frame_index_to_draw = current_direction % _total_frames_in_sprite;
            _xscale = 1;
            _cols_per_sheet = 8;
        } else {
            _total_frames_in_sprite = sprite_get_number(_sprite_to_draw);
             if (_total_frames_in_sprite <= 0) _total_frames_in_sprite = 1;
            _frame_index_to_draw = 0;
            if (throw_duration > 0 && _total_frames_in_sprite > 0) {
                var _anim_progress = 1 - (throw_timer / throw_duration);
                _frame_index_to_draw = floor(_anim_progress * _total_frames_in_sprite);
                _frame_index_to_draw = clamp(_frame_index_to_draw, 0, _total_frames_in_sprite - 1);
            }
            if (current_direction == PB_DOWN_RIGHT || current_direction == PB_RIGHT || current_direction == PB_UP_RIGHT) { _xscale = -1; } else { _xscale = 1; }
            _cols_per_sheet = 8;
            _debug_draw_state += " | DrawState: Throwing";
        }
   } else {
        // Fallback state if logic is missed
        _debug_draw_state += " | DrawState: UNKNOWN/FALLBACK";
        _sprite_to_draw = spr_polarbear_face_sheet;
        _total_frames_in_sprite = 8; // Use face sheet frame count
        _frame_index_to_draw = current_direction % _total_frames_in_sprite;
        _xscale = 1;
        _cols_per_sheet = 8;
   }

   // --- Calculate Final Drawing Parameters ---
   _final_draw_x = _draw_x - (_frame_w / 2) * _xscale; // Apply scale offset
   _final_draw_y = _draw_y - (_frame_h / 2);
   if (_cols_per_sheet <= 0) _cols_per_sheet = 1;
   var _col = _frame_index_to_draw % _cols_per_sheet;
   var _row = floor(_frame_index_to_draw / _cols_per_sheet);
   _left = _col * _frame_w;
   _top = _row * _frame_h;

   // --- Final Draw Call & Debug ---
   if (sprite_exists(_sprite_to_draw)) {
       draw_sprite_part_ext(_sprite_to_draw, 0, _left, _top, _frame_w, _frame_h, _final_draw_x, _final_draw_y, _xscale, 1, c_white, 1);
       draw_set_halign(fa_center); draw_set_valign(fa_bottom); draw_set_font(fnt_earlygb); draw_set_color(c_yellow);
       // Refined Debug Text
       var _sprite_name = sprite_get_name(_sprite_to_draw);
       var _frame_info = " (" + string(_col) + "," + string(_row) + " of " + string(_total_frames_in_sprite) + ")";
       draw_text(x, y - _frame_h/2 - 2, _debug_draw_state + " | Spr: " + _sprite_name + " | Frm: " + string(_frame_index_to_draw) + _frame_info);
       draw_set_color(c_white); draw_set_halign(fa_left); draw_set_valign(fa_top);
   } else { /* ... fallback drawing ... */ }

   set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_polarbear
File: Step_0.gml
// obj_polarbear Step Event - COMPLETE
if (global.is_pause_menu_active) exit;

// Handle warp block interaction
if (place_meeting(x, y, obj_warp_block) && !instance_exists(obj_warp)) {
     var warp = instance_nearest(x, y, obj_warp_block);
     var inst = instance_create_depth(0, 0, -9999, obj_warp);
     inst.target_x = warp.target_x;
     inst.target_y = warp.target_y;
     inst.target_rm = warp.target_rm;
     inst.target_face = current_direction; // Keep current direction
     inst.target_instance = id;
     // Note: Cooldown is handled by obj_warp_block now
}

// Get player instance safely
var _player_inst = instance_exists(global.player_instance) ? global.player_instance : noone;

// Determine player distance ONLY if player exists
dist_to_player = (_player_inst != noone) ? distance_to_object(_player_inst) : 10000;
if (_player_inst == noone && mood == "angry") { mood = "passive"; } // Calm down if player gone

// --- DEBUG: Log Start of State Logic ---
// show_debug_message("PB Step Start: Mood=" + mood + ", is_stopped=" + string(is_stopped) + ", xspd=" + string(xspd) + ", yspd=" + string(yspd));

// --- State Machine ---
switch (mood) {
    case "passive":
        image_speed = 0; // Default for passive
        xspd = 0;
        yspd = 0;

        if (is_stopped) {
            image_speed = idle_anim_speed; // Usually 0
            if (stop_timer > 0) {
                stop_timer--;
                // Face player logic...
                if (_player_inst != noone && dist_to_player < view_range / 2) {
                     var dir_to_player = point_direction(x, y, _player_inst.x, _player_inst.y);
                     var angle = round(dir_to_player / 45) % 8;
                     var face_map = [PB_RIGHT, PB_UP_RIGHT, PB_UP, PB_UP_LEFT, PB_LEFT, PB_DOWN_LEFT, PB_DOWN, PB_DOWN_RIGHT];
                     current_direction = face_map[angle];
                }
            } else {
                is_stopped = false;
                wander_timer = irandom_range(60, 180);
                current_direction = irandom(7);
                 // show_debug_message("PB Passive: Stop timer ended. Starting wander. New Dir: " + string(current_direction));
            }
        } else { // Wandering
            image_speed = walk_anim_speed; // Should be > 0
            if (wander_timer > 0) {
                wander_timer--;
                // Calculate speed based on current_direction macro
                switch (current_direction) { /* ... speed calculation ... */
                     case PB_DOWN:      yspd = move_spd; break;
                     case PB_DOWN_LEFT: xspd = -move_spd; yspd = move_spd; break;
                     case PB_LEFT:      xspd = -move_spd; break;
                     case PB_UP_LEFT:   xspd = -move_spd; yspd = -move_spd; break;
                     case PB_UP:        yspd = -move_spd; break;
                     case PB_UP_RIGHT:  xspd = move_spd; yspd = -move_spd; break;
                     case PB_RIGHT:     xspd = move_spd; break;
                     case PB_DOWN_RIGHT:xspd = move_spd; yspd = move_spd; break;
                }
            } else {
                 // show_debug_message("PB Passive: Wander timer ended. Deciding next action.");
                if (random(1) < 0.3) { // Stop
                    is_stopped = true;
                    stop_timer = irandom_range(60, 180);
                     // show_debug_message("PB Passive: Decided to stop.");
                } else { // Change direction
                    current_direction = irandom(7);
                    wander_timer = irandom_range(60, 180);
                     // show_debug_message("PB Passive: Decided to wander again. New Dir: " + string(current_direction));
                }
                 // Reset speed here to reflect decision immediately
                xspd = 0;
                yspd = 0;
                if (!is_stopped) { image_speed = walk_anim_speed; } else { image_speed = idle_anim_speed; }
            }
        }
        break; // End passive state

    case "angry":
        image_speed = 0; // Default for angry
        xspd = 0;
        yspd = 0;

        if (_player_inst == noone) { mood = "passive"; break; }

        // Face the player
        var dir_to_player = point_direction(x, y, _player_inst.x, _player_inst.y);
        var angle = round(dir_to_player / 45) % 8;
        var face_map = [PB_RIGHT, PB_UP_RIGHT, PB_UP, PB_UP_LEFT, PB_LEFT, PB_DOWN_LEFT, PB_DOWN, PB_DOWN_RIGHT];
        current_direction = face_map[angle];

        if (throw_timer > 0) {
            // --- Currently Throwing ---
            throw_timer--;
            if (throw_sprite != noone && sprite_exists(throw_sprite)) {
                 var _num_frames = sprite_get_number(throw_sprite);
                 image_speed = (_num_frames > 0 && throw_duration > 0) ? (_num_frames / throw_duration) : 0;
                 // show_debug_message("PB Throwing: Anim Speed=" + string(image_speed));
            } else { image_speed = 0; }

            if (throw_timer <= 0) { // Throw finished
                 if (_player_inst != noone) {
                     var snowball = instance_create_layer(x, y + 5, "Instances", obj_snowball); // Adjust Y slightly
                     snowball.direction = dir_to_player;
                     snowball.speed = 5;
                      show_debug_message("Polar Bear threw snowball!");
                 }
                 image_speed = idle_anim_speed; // Transition to idle speed
                 image_index = 0;
                 throw_interval_timer = throw_interval;
                 throw_sprite = noone;
                  // show_debug_message("PB Throwing: Finished. Starting Cooldown.");
            }
        } else { // Not Throwing
            if (throw_interval_timer > 0) { // Cooldown
                throw_interval_timer--;
                image_speed = idle_anim_speed; // Idle during cooldown
                 // show_debug_message("PB Angry: Cooldown. Timer=" + string(throw_interval_timer));
            } else { // Cooldown Finished
                 // show_debug_message("PB Angry: Cooldown finished. Checking range. Dist=" + string(dist_to_player));
                if (dist_to_player <= attack_distance) { // Start Throw
                    throw_timer = throw_duration;
                    image_index = 0;
                    if (_player_inst.y > y + 10) { throw_sprite = spr_polarbear_snowballdownright_sheet; }
                    else { throw_sprite = spr_polarbear_snowballupright_sheet; }
                    if (!sprite_exists(throw_sprite)) { /* error handling */ mood = "passive"; throw_sprite = noone; throw_timer = 0; }
                    else { show_debug_message("PB Angry: Starting throw. Sprite: " + sprite_get_name(throw_sprite)); image_speed = 0; }
                } else if (dist_to_player <= view_range) { // Chase
                    var stop_distance = attack_distance - 8;
                    if (dist_to_player > stop_distance) {
                         var chase_dir = point_direction(x, y, _player_inst.x, _player_inst.y);
                         xspd = lengthdir_x(move_spd, chase_dir);
                         yspd = lengthdir_y(move_spd, chase_dir);
                         image_speed = walk_anim_speed; // Walk anim while chasing
                          // show_debug_message("PB Angry: Chasing. Speed set.");
                    } else {
                         image_speed = idle_anim_speed; // Idle when close enough
                         // show_debug_message("PB Angry: Close enough, idling.");
                    }
                } else { // Calm Down
                    mood = "passive";
                    is_stopped = true;
                    stop_timer = 60;
                    image_speed = idle_anim_speed;
                    show_debug_message("Polar Bear calmed down (out of range).");
                }
            }
        }
        break; // End angry state
} // End switch(mood)

// --- DEBUG: Log final speed and image_speed BEFORE collision ---
// show_debug_message("PB Pre-Collision: Mood=" + mood + ", xspd=" + string(xspd) + ", yspd=" + string(yspd) + ", image_speed=" + string(image_speed));

// --- Collision Handling (using script) ---
xspd = handle_collision("x", xspd);
yspd = handle_collision("y", yspd);
// x and y are updated by handle_collision

// --- DEBUG: Log position AFTER collision ---
// show_debug_message("PB Post-Collision: X=" + string(x) + ", Y=" + string(y));

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffle
File: Create_0.gml
// Movement variables
xspd = 0;
yspd = 0;
move_spd = 2;
direction = choose(0, 45, 90, 135, 180, 225, 270, 315);
direction_timer = 120; // Change direction every 2 seconds at 60 FPS

// Animation variables
face = DOWN;
image_index = 0;
image_speed = 0.1;

// AI State System
enum PuffleState {
    IDLE,
    FOLLOWING,
    PLAYING,
    EATING
}
state = PuffleState.IDLE; // Start in IDLE for testing
idle_timer = 0;
follow_distance = 32;
is_savable = true;
persistent = false;
color = "white";
following_player = false;
player_idle_timer = 0; // Timer for player inactivity

// Eating timer
eating_timer = 0;

// Ensure collision mask
sprite_index = spr_puffle; // Set sprite for collision detection

/// Set Random Puffle Color
var color_variations = [
    make_color_rgb(255, 0, 0),    // Red
    make_color_rgb(0, 0, 255),    // Blue
    make_color_rgb(0, 255, 0),    // Green
    make_color_rgb(255, 255, 0),  // Yellow
    make_color_rgb(128, 0, 128),  // Purple
    make_color_rgb(255, 192, 203),// Pink
    make_color_rgb(255, 165, 0),  // Orange
    make_color_rgb(255, 255, 255) // White
];

// Correct way to select a random color
image_blend = color_variations[irandom(array_length(color_variations) - 1)];

prev_face = face; // Add this line
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffle
File: Draw_0.gml
var sprite_data = get_puffle_sprite_data(face);
var base_subimage = sprite_data[0];
var xscale = sprite_data[1];
var anim_frame = floor(image_index) % 8;
var final_subimage = base_subimage + anim_frame;

var col = final_subimage % 8;
var row = floor(final_subimage / 8);
var left = col * 24;
var top = row * 24;

// Adjust draw_x based on xscale to center the sprite
var draw_x = x - (12 * xscale); // Shift left for xscale=1, right for xscale=-1
var draw_y = y - 12;

draw_sprite_part_ext(spr_puffle_walk, 0, left, top, 24, 24, draw_x, draw_y, xscale, 1, image_blend, 1);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffle
File: Other_10.gml
// --- obj_puffle: User Event 0 (Interaction Attempt) ---

show_debug_message("Puffle User Event 0: Interaction triggered.");

// Check if player is nearby (redundant check, but safe)
if (distance_to_object(global.player_instance) >= 24) exit;

// Handle feeding/befriending ONLY if not already following
if (!following_player) {
    // Check inventory using the CORRECT method
    if (instance_exists(obj_inventory) && (obj_inventory.inventory_has("Puffle O") || obj_inventory.inventory_has("Box Puffle O"))) {
        state = PuffleState.EATING;
        // Turn to face player
        var dir_to_player = point_direction(x, y, global.player_instance.x, global.player_instance.y);
        var angle = round(dir_to_player / 45) % 8;
        var face_map = [RIGHT, UP_RIGHT, UP, UP_LEFT, LEFT, DOWN_LEFT, DOWN, DOWN_RIGHT];
        face = face_map[angle];
        // Stop animation during eating
        image_speed = 0;
        image_index = 0; // Or specific eating frame if you have one

        eating_timer = 120; // Eat for 2 seconds

        // Consume item using the CORRECT method
        if (obj_inventory.inventory_has("Puffle O")) {
            obj_inventory.inventory_remove("Puffle O");
        } else {
            obj_inventory.inventory_remove("Box Puffle O");
        }
        show_debug_message("Puffle is eating.");
    } else {
        show_debug_message("Player needs a Puffle O or Box Puffle O to befriend the puffle.");
        // Optional: Display a thought bubble above the puffle?
    }
} else {
    show_debug_message("Puffle is already following player.");
    // Optional: Add other interactions for already-following puffles (e.g., petting)
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffle
File: Other_4.gml
// Room Start Event for obj_puffle
if (following_player && variable_global_exists("player_instance") && instance_exists(global.player_instance)) {
    // Position puffle 16 pixels offset from player based on player's facing direction
    var offset_dist = 16;
    var offset_dir;
    switch (global.player_instance.face) {
        case RIGHT: offset_dir = 0; break;
        case LEFT: offset_dir = 180; break;
        case UP: offset_dir = 90; break;
        case DOWN: offset_dir = 270; break;
        default: offset_dir = 270; // Default to below player
    }
    x = global.player_instance.x + lengthdir_x(offset_dist, offset_dir);
    y = global.player_instance.y + lengthdir_y(offset_dist, offset_dir);

    // Prevent overlap with walls
    if (place_meeting(x, y, obj_wall)) {
        x = global.player_instance.x;
        y = global.player_instance.y;
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffle
File: Step_0.gml
// --- obj_puffle: Step Event ---

// Exit if paused
if (global.is_pause_menu_active) exit;

// Ensure player_instance is valid
if (!instance_exists(global.player_instance)) {
    // Try finding any player object if global ref is lost
    global.player_instance = instance_find(obj_player_base, 0); // Find any parent player object
    if (!instance_exists(global.player_instance)) {
        show_debug_message("Puffle Warning: No player instance found!");
        exit;
    }
}

// --- Player Interaction (Check for 'E' press) ---
// This section now *only* handles the 'E' key press detection.
// The actual feeding logic is moved to User Event 0 triggered below.
if (distance_to_object(global.player_instance) < 24 && keyboard_check_pressed(ord("E"))) {
     // Trigger User Event 0 on the puffle itself to handle the interaction attempt
     event_perform(ev_other, ev_user0);
}

// Debugging state
//show_debug_message("Puffle state: " + string(state) + ", Position: (" + string(x) + ", " + string(y) + ")");

// New variable for player inactivity timer (initialized in Create event if not present)
if (!variable_instance_exists(id, "player_idle_timer")) player_idle_timer = 0;

// State-specific logic
switch (state) {
    case PuffleState.IDLE:
        xspd = 0;
        yspd = 0;
        idle_timer += 1;
        if (idle_timer >= 120) {
            var idle_behavior = choose("bounce", "roll", "look_around");
            if (idle_behavior == "bounce") {
                y -= 2;
                alarm[0] = 5;
            }
            if (idle_behavior == "roll") {
                image_angle += choose(-5, 5);
            }
            if (idle_behavior == "look_around") {
                face = choose(RIGHT, LEFT, UP, DOWN);
            }
            idle_timer = 0;
        }
        // Check if player starts moving again
        if (following_player && point_distance(0, 0, global.player_instance.xspd, global.player_instance.yspd) > 0.5) {
            state = PuffleState.FOLLOWING;
            player_idle_timer = 0;
            show_debug_message("Puffle resumes following player.");
        }
        break;

    case PuffleState.PLAYING:
        if (direction_timer <= 0 || place_meeting(x + xspd, y, obj_wall) || place_meeting(x, y + yspd, obj_wall)) {
            direction = choose(0, 45, 90, 135, 180, 225, 270, 315);
            direction_timer = 120;
        }
        xspd = lengthdir_x(move_spd, direction);
        yspd = lengthdir_y(move_spd, direction);
        direction_timer -= 1;
        break;

    case PuffleState.FOLLOWING:
        if (instance_exists(global.player_instance)) {
            // Target a position behind the player with some randomness
            var base_dist = 24; // Increased distance for looser following
            var offset_dir = (global.player_instance.face + 180) % 360; // Opposite of player's facing
            var random_offset = irandom_range(-8, 8); // Add natural variation
            var target_x = global.player_instance.x + lengthdir_x(base_dist, offset_dir) + random_offset;
            var target_y = global.player_instance.y + lengthdir_y(base_dist, offset_dir) + random_offset;
            var dist = point_distance(x, y, target_x, target_y);

            if (dist > 12) { // Minimum distance to start moving
                var dir = point_direction(x, y, target_x, target_y);
                var move_x = lengthdir_x(move_spd, dir);
                var move_y = lengthdir_y(move_spd, dir);
                xspd = lerp(xspd, move_x, 0.15); // Slightly higher acceleration for responsiveness
                yspd = lerp(yspd, move_y, 0.15);
            } else {
                xspd = lerp(xspd, 0, 0.3); // Faster deceleration when close
                yspd = lerp(yspd, 0, 0.3);
            }

            // Check if player is stationary
            if (point_distance(0, 0, global.player_instance.xspd, global.player_instance.yspd) < 0.1) {
                player_idle_timer += 1;
                if (player_idle_timer >= 180) { // 3 seconds at 60 FPS
                    state = PuffleState.IDLE;
                    player_idle_timer = 0;
                    show_debug_message("Puffle switched to idle state.");
                }
            } else {
                player_idle_timer = 0; // Reset timer if player moves
            }
        } else {
            xspd = 0;
            yspd = 0;
        }
        break;

    case PuffleState.EATING:
        xspd = 0;
        yspd = 0;
        if (eating_timer > 0) {
            eating_timer -= 1;
        } else {
            state = PuffleState.FOLLOWING;
            following_player = true;
            persistent = true;
            ds_list_add(global.following_puffles, id);
            show_debug_message("Puffle finished eating and is now following player.");
        }
        break;
}

// Collision Handling with Obstacle Avoidance
var old_x = x;
var old_y = y;
x += xspd;
if (place_meeting(x, y, obj_wall)) {
    x = old_x; // Revert x movement
    y += yspd;
    if (place_meeting(x, y, obj_wall)) {
        y = old_y; // Revert y movement
        // Try sliding around obstacle
        var slide_dir = point_direction(x, y, global.player_instance.x, global.player_instance.y) + choose(-90, 90);
        xspd = lengthdir_x(move_spd * 0.5, slide_dir);
        yspd = lengthdir_y(move_spd * 0.5, slide_dir);
    } else {
        // y movement succeeded, adjust xspd to avoid sticking
        xspd = lerp(xspd, 0, 0.2);
    }
} else {
    y += yspd;
    if (place_meeting(x, y, obj_wall)) {
        y = old_y; // Revert y if stuck
        xspd = lerp(xspd, 0, 0.2); // Slow down to prevent sticking
    }
}

// Animation Handling
if (xspd != 0 || yspd != 0) {
    var angle = point_direction(0, 0, xspd, yspd);
    var dir_index = round(angle / 45) % 8;
    var face_map = [RIGHT, UP_RIGHT, UP, UP_LEFT, LEFT, DOWN_LEFT, DOWN, DOWN_RIGHT];
    var new_face = face_map[dir_index];
    if (new_face != prev_face) {
        image_index = 0;  // Reset animation when direction changes
        prev_face = new_face;
    }
    face = new_face;
    image_speed = 0.15;
} else {
    image_speed = 0;
}
image_index += image_speed;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffleo_item
File: Create_0.gml
event_inherited();
item_name = "Puffle O";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pufflewhistle_item
File: Create_0.gml
event_inherited();
item_name = "Puffle Whistle";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_repair_ui
File: Create_0.gml
// Create Event for obj_repair_ui
visible = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_repair_ui
File: Draw_64.gml
// Draw GUI Event for obj_repair_ui
if (visible) {
    var ui_x = camera_get_view_x(view_camera[0]) + 20;
    var ui_y = camera_get_view_y(view_camera[0]) + 20;

    draw_set_color(c_white);
    draw_rectangle(ui_x, ui_y, ui_x + 150, ui_y + 50, false);
    draw_set_color(c_black);
    draw_text(ui_x + 10, ui_y + 10, "Press 'E' to Repair");

    // Draw required materials
    for (var i = 0; i < 3; i++) {
        draw_sprite(spr_inventory_items, 7 + i, ui_x + 10 + (i * 20), ui_y + 30);
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_repair_ui
File: Step_0.gml
// Step Event for obj_repair_ui
var b = instance_nearest(global.player_instance.x, global.player_instance.y, obj_building);

if (b != noone && distance_to_object(b) < 32 && b.repair_stage == 0) {
    visible = true;
} else {
    visible = false;
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_rocks
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_settings
File: CleanUp_0.gml
//font_delete(global.font_main);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_settings
File: Create_0.gml
global.font_main = fnt_bumbastika_sml;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sidewalk
File: Step_0.gml
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_signpost
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_signpostalt
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skilift
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpicker
File: Create_0.gml
depth = -1000; // Ensuring the skin picker is in front of everything

// Menu dimensions
menu_width = 109;
menu_height = 72;

// Position the skin picker around the current player instance or center it in the view
if (instance_exists(global.player_instance)) {
    x = global.player_instance.x - menu_width / 2;
    y = global.player_instance.y - menu_height / 2;
} else {
    x = view_xview[0] + (view_wview[0] - menu_width) / 2;
    y = view_yview[0] + (view_hview[0] - menu_height) / 2;
}

// Ensure the global skins array exists
if (!variable_global_exists("skins")) {
    global.skins = [
        {object: obj_player_icetruck, name: "Ice Truck"},
        {object: obj_player, name: "Penguin"},
        {object: obj_player_tube, name: "Tube"}
    ];
}

// Button properties
var button_width = 37.5; 
var button_height = 10; 
var button_padding = 2.5; 
var button_x = x + (menu_width - button_width) / 2; 
var button_y = y + button_padding; 

// Create buttons for each skin
for (var i = 0; i < array_length(global.skins); i++) {
    var skin = global.skins[i];
    var btn_skin = instance_create_layer(button_x, button_y, "Instances", obj_skinpickerbutton); // Reference obj_skinpickerbutton
    btn_skin.skin_object = skin.object; // Set the object to switch to
    btn_skin.skin_name = skin.name;    // Set the button label

    // Scale buttons
    btn_skin.image_xscale = button_width / sprite_get_width(spr_button);
    btn_skin.image_yscale = button_height / sprite_get_height(spr_button);

    button_y += button_height + button_padding; // Position the next button
}

// Create a Close button
var btn_close = instance_create_layer(button_x, button_y, "Instances", obj_skinpickerbutton);
btn_close.skin_object = noone; // No skin switch, just close
btn_close.skin_name = "Close"; 
btn_close.sprite_index = spr_button;

// Scale the Close button
btn_close.image_xscale = button_width / sprite_get_width(spr_button);
btn_close.image_yscale = button_height / sprite_get_height(spr_button);



Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpicker
File: Destroy_0.gml
// Destroy all button instances when the skin picker menu is destroyed
with (obj_skinpickerbutton) {
    instance_destroy(); // Destroy all buttons linked to this menu
}
shader_reset(); // Reset the shader to remove the blur effect

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpicker
File: Draw_0.gml
// Draw Event for obj_skinpicker
//if (shader_is_compiled(shd_blur)) {
    // Apply blur shader
//    var tex = surface_get_texture(application_surface);
//    shader_set(shd_blur);
 //   shader_set_uniform_i(shader_get_uniform(shd_blur, "texture"), tex);
//    draw_surface(application_surface, 0, 0);
//    shader_reset();
//}

// Draw the skin picker menu
draw_self();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpicker
File: KeyPress_80.gml
show_debug_message("Buttons left: " + string(instance_number(obj_skinpickerbutton)));
show_debug_message("Skinpickers left: " + string(instance_number(obj_skinpicker)));
show_debug_message("Skin picker buttons: " + string(instance_number(obj_skinpickerbutton)));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpickerbutton
File: Create_0.gml
depth = -1010; // Ensure buttons are in front of the skin picker

// Initialize button-specific variables
skin_object = noone; // The skin this button switches to
skin_name = "";      // The name displayed on the button

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpickerbutton
File: Draw_0.gml
// Draw Event for obj_button
draw_self(); // Draw the button sprite

// Draw the button text
draw_set_color(c_black); // Set text color to black
draw_set_halign(fa_center); // Center text horizontally
draw_set_valign(fa_middle); // Center text vertically

var button_width = sprite_width * image_xscale;
var button_height = sprite_height * image_yscale;

var text_x = x + button_width / 2;
var text_y = y + button_height / 2;

draw_text(text_x, text_y, skin_name); // Center the text
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpickerbutton
File: Mouse_4.gml
if (skin_object != noone) {
    obj_controller.switch_skin(skin_name);
}

// Destroy the skin picker menu if a valid skin was selected
if (skin_object != noone) {
    with (obj_skinpicker) {
        instance_destroy();
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_player
File: Create_0.gml
xspd = 0;
yspd = 0; // No vertical movement
move_spd = 5; // Adjust speed as needed
lives = 3; // Start with 3 lives
global.game_started = true; // Game starts immediately
game_timer = 10 * 60; // 10 seconds timer (assuming 60 FPS)
collision_cooldown = 0; // To prevent multiple hits quickly
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_player
File: Draw_0.gml
// Draw Event for obj_sled_player

draw_self(); // Draw the player sprite

if (global.game_started) {
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    draw_set_color(c_black);
    draw_text(10, 10, "Lives: " + string(lives));
    draw_text(10, 30, "Time: " + string(ceil(game_timer / 60))); // Display in seconds
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_player
File: Other_4.gml
// Room Start Event for obj_sled_player
global.player_instance = id;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_player
File: Step_0.gml
// Step Event for obj_sled_player

if (global.game_started) {
    game_timer -= 1; // Decrement timer each frame

    // Horizontal movement
    if (keyboard_check(vk_left) || keyboard_check(ord("A"))) {
        x -= move_spd; // Move left
    } 
    if (keyboard_check(vk_right) || keyboard_check(ord("D"))) {
        x += move_spd; // Move right
    }

    // Prevent movement outside room boundaries
    x = clamp(x, 0, room_width - sprite_width);
}
    // Check for collision with obstacles
if (global.game_started) {
    // Collision detection with cooldown
    if (collision_cooldown <= 0 && place_meeting(x, y, obj_obstacle)) {
        show_debug_message("Collision with obstacle!");
        lives -= 1; // Deduct one life
        collision_cooldown = 30; // Set cooldown (0.5 seconds at 60 FPS)
        // Optional: Add sound effect or visual feedback here
    } else {
        collision_cooldown -= 1; // Decrement cooldown
    }

    // Win condition: Survive 10 seconds with lives remaining
    if (game_timer <= 0 && lives > 0) {
        global.last_player_x = 55; // Set position for rm_ski_village
        global.last_player_y = 235;
        switch_skin("player"); // Switch back to obj_player
        room_goto(rm_ski_village); // Transition to rm_ski_village
    }

    // Lose condition: No lives remaining
    if (lives <= 0) {
        global.last_player_x = 245; // Set position for rm_ski_mountaintop
        global.last_player_y = 120;
        switch_skin("player"); // Switch back to obj_player
        room_goto(rm_ski_mountaintop); // Transition to rm_ski_mountaintop
    }
}


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_slippery
File: Create_0.gml
xspd = 0;
yspd = 0;

sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_slippery
File: Step_0.gml
if (place_meeting(x, y, obj_player) || place_meeting(x, y, obj_player_tube)) {
    if (!sliding) {
        sliding = true;
        
        // Get the player's last movement direction
        var player = instance_nearest(x, y, obj_player); // Get closest player
        if (!instance_exists(player)) player = instance_nearest(x, y, obj_player_tube);

        if (instance_exists(player)) {
            slide_dir_x = sign(player.xspd);
            slide_dir_y = sign(player.yspd);
            slide_speed = max(abs(player.xspd), abs(player.yspd)); // Carry over momentum
        }
    }
}

// **Sliding Deceleration Logic**
if (sliding) {
    x += slide_dir_x * slide_speed;
    y += slide_dir_y * slide_speed;

    // Reduce speed gradually
    slide_speed *= 0.95; 

    // Stop sliding when slow enough
    if (slide_speed < 0.1) {
        sliding = false;
        slide_speed = 0;
    }

    // **Collision Handling (Bounce Effect)**
    if (place_meeting(x + slide_dir_x * slide_speed, y, obj_wall)) {
        slide_dir_x = -slide_dir_x; // Reverse direction on X collision
        slide_speed *= 0.7; // Reduce speed slightly when bouncing
    }
    
    if (place_meeting(x, y + slide_dir_y * slide_speed, obj_wall)) {
        slide_dir_y = -slide_dir_y; // Reverse direction on Y collision
        slide_speed *= 0.7;
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_small_bushes
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_small_trees
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sml_boat
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowball
File: Collision_obj_polarbear.gml
   // obj_polarbear Collision Event with obj_snowball
   show_debug_message("DEBUG: Snowball (" + string(id) + ") colliding with Polar Bear (" + string(other.id) + ")");

   // Check if the polar bear instance still exists before trying to modify it
   if (instance_exists(other))
   {
       show_debug_message("Polar Bear instance exists. Setting mood to angry.");
       with (other) { // Use 'with' to ensure context is the polar bear
           mood = "angry";
           throw_interval_timer = 0;
           throw_timer = 0;
           is_stopped = false;
           throw_sprite = noone;

           // Correctly access the bear's idle_anim_speed
           if (variable_instance_exists(id, "idle_anim_speed")) { // 'id' inside 'with' refers to the bear
               image_speed = idle_anim_speed;
           } else {
               image_speed = 0;
               show_debug_message("WARNING: idle_anim_speed missing on Polar Bear!");
           }
           image_index = 0;
       }
   } else { show_debug_message("WARNING: Polar Bear instance was already destroyed."); }

   instance_destroy(); // Destroy the snowball (self)
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowball
File: Create_0.gml
direction = 0;
speed = 3;
image_speed = 0;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowball
File: Draw_0.gml
draw_self();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowball
File: Step_0.gml
x += lengthdir_x(speed, direction);
y += lengthdir_y(speed, direction);

// Check for collision with walls or out of bounds
if (place_meeting(x, y, obj_wall) || x < 0 || x > room_width || y < 0 || y > room_height) {
    instance_destroy();
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowblaster_item
File: Create_0.gml
event_inherited();
item_name = "Snow Blaster";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowforts
File: Step_0.gml
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowshovel_item
File: Create_0.gml
event_inherited();
item_name = "Snow Shovel";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snow_item
File: Create_0.gml
event_inherited();
item_name = "Snow";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_spawn_point
File: Create_0.gml
// obj_spawn_point: Create Event

// This object is just a marker for the room editor.
// It should not be visible during gameplay.
visible = false;

// You can optionally set a depth if needed, though visibility false usually suffices.
// depth = 10000; // Set very deep if needed for editor visibility layering

show_debug_message("Spawn Point marker created at (" + string(x) + ", " + string(y) + ")");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_spyphone_item
File: Create_0.gml
event_inherited();
item_name = "Spy Phone";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_stampbook_item
File: Create_0.gml
event_inherited();
item_name = "Stamp Book";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_starterdeck_item
File: Create_0.gml
event_inherited();
item_name = "Starter Deck";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tall_bush
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tall_trees
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_toboggan
File: Create_0.gml
item_name = "Toboggan";
face = DOWN;
is_savable = true;

// Define sprite positions for spr_toboggan_sheet
toboggan_sprites = array_create(8);
toboggan_sprites[DOWN] = [0, 0];         // DOWN
toboggan_sprites[UP] = [24, 0];          // UP
toboggan_sprites[DOWN_RIGHT] = [48, 0];  // DOWN_RIGHT
toboggan_sprites[UP_LEFT] = [72, 0];     // UP_LEFT
toboggan_sprites[LEFT] = [96, 0];        // LEFT
toboggan_sprites[RIGHT] = [120, 0];      // RIGHT
toboggan_sprites[DOWN_LEFT] = [144, 0];   // Same as DOWN_RIGHT, flipped in Draw
toboggan_sprites[UP_RIGHT] = [168, 0];    // Same as UP_LEFT, flipped in Draw
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_toboggan
File: Destroy_0.gml
instance_destroy(); // Destroy the current ice truck instance
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_toboggan
File: Draw_0.gml
var base_x = toboggan_sprites[face][0];
var base_y = toboggan_sprites[face][1];
var flip = (face == DOWN_LEFT || face == UP_RIGHT) ? -1 : 1;
draw_sprite_part_ext(spr_toboggan_sheet, 0, base_x, base_y, 24, 24, x - 12, y - 12, flip, 1, c_white, 1);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_toboggan
File: Step_0.gml
event_inherited();
item_name = "Toboggan";

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tourhat_item
File: Create_0.gml
event_inherited();
item_name = "Tour Hat";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tour_booth
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_town_complete
File: Step_0.gml
set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube
File: Create_0.gml
item_name = "Tube";

// Core variables
face = DOWN;

// Assign sprite sheet directions (indices for spr_tube_sheet)
tube_sprites = array_create(8);
tube_sprites[UP] = [0, 0];        // UP, LEFT
tube_sprites[LEFT] = [0, 0];
tube_sprites[DOWN] = [24, 0];     // DOWN, RIGHT
tube_sprites[RIGHT] = [24, 0];
tube_sprites[UP_LEFT] = [48, 0];  // UP_LEFT, DOWN_RIGHT
tube_sprites[DOWN_RIGHT] = [48, 0];
tube_sprites[DOWN_LEFT] = [72, 0]; // DOWN_LEFT, UP_RIGHT
tube_sprites[UP_RIGHT] = [72, 0];
is_savable = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube
File: Destroy_0.gml
instance_destroy(); // Destroy the current ice truck instance
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube
File: Draw_0.gml
// Get tube sprite position
var tube_x = tube_sprites[face][0];
var tube_y = tube_sprites[face][1];

// Draw tube
draw_sprite_part(spr_tube_sheet, 0, tube_x, tube_y, 24, 24, x, y);

// Draw player sitting inside the tube
var sitting_sprites = array_create(8);
sitting_sprites[DOWN] = [0, 72];
sitting_sprites[DOWN_LEFT] = [24, 72];
sitting_sprites[LEFT] = [48, 72];
sitting_sprites[UP_LEFT] = [72, 72];
sitting_sprites[UP] = [96, 72];
sitting_sprites[UP_RIGHT] = [120, 72];
sitting_sprites[RIGHT] = [144, 72];
sitting_sprites[DOWN_RIGHT] = [168, 72];

var sit_x = sitting_sprites[face][0];
var sit_y = sitting_sprites[face][1];
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube
File: Step_0.gml
event_inherited();
item_name = "Tube";

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube_tower_decoration
File: Create_0.gml
item_name = "Tube";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube_tower_decoration
File: Step_0.gml
event_inherited();
item_name = "Tube";

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui
File: Create_0.gml
// obj_ui_create.txt
// Initialize variables
ui_elements = []; // Array to store UI elements

// Example: Add a button to the UI
var button = {
    x: 100,
    y: 100,
    width: 200,
    height: 50,
    text: "Click Me",
    action: function() {
        show_message("Button Clicked!");
    }
};
array_push(ui_elements, button);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui
File: Draw_0.gml
// obj_ui_draw.txt
// Set font and alignment for UI text
draw_set_font(fnt_bumbastika_sml);
draw_set_halign(fa_center);
draw_set_valign(fa_middle);

// Draw UI elements
for (var i = 0; i < array_length(ui_elements); i++) {
    var elem = ui_elements[i];
    draw_rectangle(elem.x, elem.y, elem.x + elem.width, elem.y + elem.height, false);
    draw_text(elem.x + elem.width / 2, elem.y + elem.height / 2, elem.text);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui
File: Mouse_4.gml
// obj_ui_leftpressed.txt
// Get mouse position
var mouse_x_pos = device_mouse_x_to_gui(0);
var mouse_y_pos = device_mouse_y_to_gui(0);

// Check if any UI element is clicked
for (var i = 0; i < array_length(ui_elements); i++) {
    var elem = ui_elements[i];
    if (mouse_x_pos > elem.x && mouse_x_pos < elem.x + elem.width && mouse_y_pos > elem.y && mouse_y_pos < elem.y + elem.height) {
        // Execute the action associated with the UI element
        elem.action();
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui_manager
File: Create_0.gml
// obj_ui_manager Create Event
persistent = true; // Make persistent to stay across rooms
global.ui_manager = id;
active_ui = noone;  // Current UI instance
inventory_instance = instance_exists(obj_inventory) ? obj_inventory : instance_create_layer(0, 0, "UI", obj_inventory);
depth = -1000;  // Above all UI elements
show_debug_message("UI Manager initialized.");

// Add this inside obj_ui_manager Create Event
// Function to open UI (within obj_ui_manager Step Event)
open_ui = function(ui_object) {
    show_debug_message("UI Manager: Request to open UI object: " + object_get_name(ui_object));

    // --- CRITICAL: Ensure UI Layer Exists ---
    // Check for the layer *immediately before* attempting to create on it.
    if (!layer_exists("UI")) {
         // If it doesn't exist, create it. This is the most reliable place.
         layer_create(-10000, "UI"); // Ensure high depth for UI layer
         show_debug_message("UI Manager (open_ui): Created missing 'UI' Layer.");
    }
    // --- End Layer Check ---

    // Close existing UI first (if any)
    if (active_ui != noone && instance_exists(active_ui)) {
        show_debug_message("UI Manager: Destroying previous active UI (" + string(active_ui) + ", Object: " + object_get_name(instance_exists(active_ui) ? active_ui.object_index : -1) + ")");
        instance_destroy(active_ui);
        active_ui = noone; // Clear the reference immediately
    } else if (active_ui != noone) {
        // If reference exists but instance doesn't, just clear the reference
         show_debug_message("UI Manager: Clearing stale active_ui reference.");
        active_ui = noone;
    }

    // Create the new UI instance on the (now guaranteed) UI layer
    active_ui = instance_create_layer(0, 0, "UI", ui_object);
    if (instance_exists(active_ui)) {
        show_debug_message("UI Manager: Successfully created new active UI (" + string(active_ui) + ") for object: " + object_get_name(ui_object));
    } else {
        show_debug_message("UI Manager ERROR: Failed to create UI instance for: " + object_get_name(ui_object));
        active_ui = noone; // Ensure reference is clear on failure
    }

    // Hide inventory while UI is open
    if (instance_exists(inventory_instance)) {
        inventory_instance.visible = false;
    }

    return active_ui; // Return the new instance ID (or noone if failed)
} // End open_ui function definition

close_ui = function() {
    show_debug_message("UI Manager: Request to close active UI.");
    if (active_ui != noone && instance_exists(active_ui)) {
        show_debug_message("UI Manager: Destroying active UI (" + string(active_ui) + ")");
        instance_destroy(active_ui);
    } else if (active_ui != noone) {
        show_debug_message("UI Manager: Clearing stale active_ui reference.");
    }
    active_ui = noone; // Clear reference

    // Restore inventory visibility IF not paused and not in a UI room
    var is_ui_room = (room == rm_init || room == rm_main_menu || room == rm_map || room == rm_pause_menu || room == rm_settings_menu);
	if (instance_exists(inventory_instance) && !global.is_pause_menu_active && !is_ui_room) {
		inventory_instance.visible = true;
        show_debug_message("UI Manager: Restored inventory visibility after UI close.");
	}
} // End close_ui function definition
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui_manager
File: Step_0.gml
// obj_ui_manager Step Event
var is_ui_room = (room == rm_init || room == rm_main_menu || room == rm_map || room == rm_pause_menu || room == rm_settings_menu);
if (!is_ui_room && !global.is_pause_menu_active) {
    if (instance_exists(inventory_instance) && active_ui == noone) {
        inventory_instance.visible = true;
    }
}
if (active_ui != noone && !instance_exists(active_ui)) {
    active_ui = noone;  // Clear if destroyed
    if (instance_exists(inventory_instance)) {
        inventory_instance.visible = true;
        show_debug_message("UI Manager restored inventory visibility.");
    }
}


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_wall
File: Step_0.gml
set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Alarm_0.gml
/// Alarm[0] Event
global.warp_cooldown = false;
show_debug_message("DEBUG: Warp cooldown finished. Warping allowed again.");
instance_destroy(); // Destroy the warp object itself after cooldown
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Create_0.gml
   // obj_warp: Create Event
   target_rm = 0;
   target_x = 0;
   target_y = 0;
   target_face = 0;
   target_instance = noone;

   persistent = true; // <<< MAKE PERSISTENT

   // Alarm 0 will reset the global cooldown
   alarm[0] = room_speed / 2; // Keep the alarm short

   show_debug_message("obj_warp initialized (Persistent: " + string(persistent) + "). Target Room: " + string(target_rm));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Draw_0.gml
draw_sprite_tiled(sprite_index, image_index, 0, 0)
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Other_7.gml
/// Animation End Event for obj_warp - REVISED (Focus on target_instance)

show_debug_message("DEBUG (Warp Anim End): Animation ended. Processing warp for target_instance: " + string(target_instance));

// Make sure the specific target instance still exists
if (!instance_exists(target_instance)) {
    show_debug_message("ERROR (Warp Anim End): Target instance (" + string(target_instance) + ") no longer exists!");
    room_goto(target_rm); // Go to room anyway
    instance_destroy(); // Destroy self
    exit;
}

show_debug_message("DEBUG (Warp Anim End): Moving instance: " + string(target_instance) + " (" + object_get_name(target_instance.object_index) + ") before room transition.");

/// Animation End Event for obj_warp - REVISED (Focus on target_instance)

show_debug_message("DEBUG (Warp Anim End): Animation ended. Processing warp for target_instance: " + string(target_instance));

// Make sure the specific target instance still exists
if (!instance_exists(target_instance)) { /* ... Error handling ... */ }
else
{
    show_debug_message("DEBUG (Warp Anim End): Moving instance: " + string(target_instance) + " (" + object_get_name(target_instance.object_index) + ") before room transition.");

    // --- Position the SPECIFIC target instance ---
    target_instance.x = target_x; target_instance.y = target_y;
    if (variable_instance_exists(target_instance, "current_direction")) { target_instance.current_direction = target_face; }
    else if (variable_instance_exists(target_instance, "face")) { target_instance.face = target_face; }
    show_debug_message("DEBUG (Warp Anim End): Instance " + string(target_instance) + " moved.");

   // --- Store Warp Coords ONLY IF it was the Player ---
    global.warp_target_x = undefined; global.warp_target_y = undefined; global.warp_target_face = undefined; global.warp_target_inst_id = noone; // Clear first
    if (target_instance == global.player_instance) { global.warp_target_x = target_x; global.warp_target_y = target_y; global.warp_target_face = target_face; global.warp_target_inst_id = target_instance; show_debug_message("DEBUG (Warp Anim End): Stored PLAYER warp target pos."); }
    else { if (!target_instance.persistent) { target_instance.persistent = true; show_debug_message("DEBUG (Warp Anim End): Made NPC persistent."); } show_debug_message("DEBUG (Warp Anim End): NPC warped. Global targets remain undefined."); }
}

// Go to the target room
room_goto(target_rm);

// Destroy self *after* initiating room transition, allowing Alarm 0 to potentially trigger
instance_destroy(); // <<< ADD THIS
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Step_0.gml
// Step Event for obj_warp
if (room == target_rm && image_index < 1) {
    instance_destroy();
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_block
File: Create_0.gml
target_rm = 0;
target_x = 0;
target_y = 0;
target_face = 0;
// Create Event for obj_warp
if (!variable_global_exists("warp_cooldown")) {
    global.warp_cooldown = false;
}



Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_block
File: Other_4.gml
// Check if a warp instance exists
if (instance_exists(obj_warp)) {
    var warp_inst = instance_find(obj_warp, 0);
    if (warp_inst != noone) {
        if (instance_exists(global.player_instance)) {
            global.player_instance.x = warp_inst.target_x;
            global.player_instance.y = warp_inst.target_y;
            // Optional: Adjust the player's facing direction
            if (is_real(warp_inst.target_face)) {
                global.player_instance.face = warp_inst.target_face;
            }
        } else {
            show_debug_message("WARNING: Player instance does not exist for warping.");
        }
        instance_destroy(warp_inst);
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_block
File: Step_0.gml
/// Step Event for obj_warp_block - REVISED LOGIC

// Skip if a warp is in progress or cooldown is active
if (instance_exists(obj_warp)) {
    show_debug_message("DEBUG Warp Block: Warp already in progress, skipping.");
    exit;
}
if (global.warp_cooldown) {
    if (instance_exists(global.player_instance) && place_meeting(x, y, global.player_instance)) {
        show_debug_message("DEBUG Warp Block: Player colliding but global.warp_cooldown is TRUE.");
    }
    exit;
}

// Initialize variables for warp handling
var _warp_instance = noone;
var _warp_target_face = target_face;

// Check for player collision
if (instance_exists(global.player_instance) && place_meeting(x, y, global.player_instance)) {
    _warp_instance = global.player_instance;
    if (variable_instance_exists(global.player_instance, "face")) {
        _warp_target_face = global.player_instance.face;
    }
    show_debug_message("DEBUG: Player detected. Prioritizing warp.");
}

// Check for polar bear collision (only if player is not warping)
if (_warp_instance == noone) {
    var _polar_bear = instance_place(x, y, obj_polarbear);
    if (_polar_bear != noone) {
        _warp_instance = _polar_bear;
        _warp_target_face = _polar_bear.current_direction;
        show_debug_message("DEBUG: Polar Bear detected on obj_warp_block. Warping.");
    }
}

// Create warp instance if a target was found
if (_warp_instance != noone) {
    // Validate and assign target room
    if (!variable_instance_exists(id, "target_rm") || !room_exists(target_rm)) {
        target_rm = room; // Fallback to the current room
        show_debug_message("DEBUG: Invalid target room. Defaulting to current room.");
    } else {
        show_debug_message("DEBUG: Valid target room identified: " + string(target_rm));
    }

    // Prevent duplicate player instances during polar bear warps
    if (_warp_instance.object_index == obj_polarbear) {
        if (instance_exists(global.player_instance)) {
            show_debug_message("DEBUG: Checking for duplicate player instance during polar bear warp.");
            if (instance_exists(global.player_instance)) {
                global.player_instance.destroy();
                show_debug_message("DEBUG: Destroyed duplicate player instance during polar bear warp.");
            }
        }
    }

    show_debug_message("Creating obj_warp for instance: " + string(_warp_instance) + " (" + object_get_name(_warp_instance.object_index) + ")");
    var warp_inst = instance_create_layer(x, y, "Instances", obj_warp);
    warp_inst.target_instance = _warp_instance;
    warp_inst.target_face = _warp_target_face;
    warp_inst.target_rm = target_rm; // Assign the validated target room
    warp_inst.target_x = target_x; // Assign the target x-coordinate
    warp_inst.target_y = target_y; // Assign the target y-coordinate

    global.warp_cooldown = true; // Activate cooldown
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_map
File: Create_0.gml
// obj_warp_map: Create Event
target_rm = noone;  // Set this in Creation Code
target_x = 0;  
target_y = 0;  
target_face = 0;  
depth = -9999;  // Ensure it's drawn on top
// Create Event for obj_warp
if (!variable_global_exists("warp_cooldown")) {
    global.warp_cooldown = false;
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_map
File: Mouse_4.gml
// obj_warp_map: Left Pressed Event (Handles Click to Warp)
if (target_rm != noone) {
    show_debug_message("Warping to Room: " + string(target_rm) + " at (" + string(target_x) + ", " + string(target_y) + ")");
    
    // Store last room before warping
    global.last_room = room;  
    
    // Create warp instance to handle transition
    var warp_inst = instance_create_depth(0, 0, -9999, obj_warp);
    warp_inst.target_rm = target_rm;
    warp_inst.target_x = target_x;
    warp_inst.target_y = target_y;
    warp_inst.target_face = target_face;
    warp_inst.target_instance = global.player_instance;

	global.camera_reset = true; // Ensure camera resets correctly
    // Room transition handling
    room_goto(target_rm);

    // Improved handling to check if player instance exists after room transition
    alarm[0] = 2;  // Set alarm to delay camera setup and check for player existence
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_wood_item
File: Create_0.gml
event_inherited();
item_name = "Wood";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_wrench_item
File: Step_0.gml
event_inherited();
item_name = "Wrench";
