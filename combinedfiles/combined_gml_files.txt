Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_battery
File: Create_0.gml
event_inherited();
item_name = "Battery";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_beta_hat
File: Create_0.gml
event_inherited();
item_name = "Beta Hat";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_big_bush
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_blackhoodie_item
File: Create_0.gml
event_inherited();
item_name = "Black Hoodie";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_blacksunglasses_item
File: Create_0.gml
event_inherited();
item_name = "Black Sun Glasses";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_boxpuffleo_item
File: Create_0.gml
event_inherited();
item_name = "Box Puffle O";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_box_decoration
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_broken_spyphone_item
File: Create_0.gml
event_inherited();
item_name = "Broken Spy Phone";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_bulletin_board
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_camera
File: Alarm_0.gml
// Alarm[0] Event (Handles delayed camera setup after room start)
/// obj_camera: Alarm[0] Event (Handles delayed camera setup after room start)
if (instance_exists(global.player_instance)) {
    camera_set_view_target(global.camera, global.player_instance); // Attach camera to player
    camera_set_view_pos(global.camera,
        global.player_instance.x - (camera_get_view_width(global.camera) / 2),
        global.player_instance.y - (camera_get_view_height(global.camera) / 2));
    camera_set_view_size(global.camera, view_wview[0], view_hview[0]); // Reset zoom
    show_debug_message("DEBUG: Camera attached to player at (" + string(global.player_instance.x) + ", " + string(global.player_instance.y) + ")");
} else {
    show_debug_message("ERROR: Player instance still not found. Retrying...");
    alarm[0] = 2; // Retry after 2 frames if player instance is not found
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_camera
File: Create_0.gml
// Create Event for obj_camera
global.camera = camera_create();
view_set_camera(0, global.camera);
camera_set_view_size(global.camera, view_wview[0], view_hview[0]);
camera_set_view_pos(global.camera, 0, 0);
show_debug_message("DEBUG: New global camera created. ID: " + string(global.camera));
global.camera_reset = false;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_camera
File: Other_4.gml
/// obj_camera - Room Start Event
if (global.camera_reset) {
    alarm[0] = 2; // Delay camera setup by 2 frames
    global.camera_reset = false;
} else {
    alarm[0] = 2; // Always delay on room start to ensure player exists
}

show_debug_message("DEBUG: Room Start - Camera setup delayed by 2 frames.");

// Ensure the camera is valid
if (!variable_global_exists("camera") || !is_real(global.camera)) {
    global.camera = camera_create();
    view_set_camera(0, global.camera);
    camera_set_view_size(global.camera, view_wview[0], view_hview[0]);
    camera_set_view_pos(global.camera, 0, 0);
    show_debug_message("DEBUG: New global camera created. ID: " + string(global.camera));
} else {
    view_set_camera(0, global.camera);
    show_debug_message("DEBUG: Reattached to existing global camera. ID: " + string(global.camera));
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_camera
File: Step_0.gml
// obj_camera Step Event
if (instance_exists(global.player_instance)) {
    var target_x = global.player_instance.x - (camera_get_view_width(global.camera) / 2);
    var target_y = global.player_instance.y - (camera_get_view_height(global.camera) / 2);
    target_x = clamp(target_x, 0, room_width - camera_get_view_width(global.camera));
    target_y = clamp(target_y, 0, room_height - camera_get_view_height(global.camera));
    camera_set_view_pos(global.camera, 
        lerp(camera_get_view_x(global.camera), target_x, 0.9),
        lerp(camera_get_view_y(global.camera), target_y, 0.9));
} else if (alarm[0] == -1) { // Only retry if alarm isnâ€™t already set
    show_debug_message("WARNING: Player instance missing. Trying again in 2 frames...");
    alarm[0] = 2;
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Create_0.gml
// In obj_chat_window Create Event
dialog_data = [];        // Will be assigned by the NPC
dialog_index = 0;        // Current dialogue line
choice_selected = -1;    // Index of selected choice (-1 means none)
depth = -1001;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Draw_0.gml

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Draw_64.gml
// obj_chat_window: Draw GUI Event
if (global.chat_active && array_length(dialog_data) > 0 && global.chat_npc != noone) {
    // Get GUI dimensions (matches viewport: 288x216)
    var gui_width = display_get_gui_width();  // 288
    var gui_height = display_get_gui_height(); // 216

    // Get original window sprite size
    var orig_width = sprite_get_width(spr_npc_dialouge_full_window);
    var orig_height = sprite_get_height(spr_npc_dialouge_full_window);

    // Calculate scale to fill viewport width (288 pixels)
    var window_scale = gui_width / orig_width; // e.g., 288 / 100 = 2.88

    // Check height constraint (ensure it fits within 216 pixels)
    var scaled_height = orig_height * window_scale;
    if (scaled_height > gui_height) {
        window_scale = gui_height / orig_height;
    }

    // Recalculate scaled dimensions
    var scaled_width = orig_width * window_scale;
    scaled_height = orig_height * window_scale;

    // Calculate window position: centered horizontally, touching the bottom
    var window_x = (gui_width - scaled_width) / 2;
    var window_y = gui_height - scaled_height;

    // Draw the dialogue window (scaled to fill width)
    draw_sprite_ext(spr_npc_dialouge_full_window, 0, window_x, window_y, window_scale, window_scale, 0, c_white, 1);

    // Draw NPC portrait (shifted 2 units left and up, scaled)
    var portrait_x = window_x + 2 * window_scale;
    var portrait_y = window_y + 2 * window_scale;
    draw_sprite_ext(spr_npc_dialouge_full_colour_portrait, 0, portrait_x, portrait_y, window_scale, window_scale, 0, global.chat_npc.npc_color, 1);
    draw_sprite_ext(spr_npc_dialouge_full_outline_portrait, 0, portrait_x, portrait_y, window_scale, window_scale, 0, c_white, 1);

    // Set font
    draw_set_font(fnt_bonkfatty);

    // Draw dialogue text (scaled positions) with validation
    var text_x = window_x + 77 * window_scale;
    var text_y = window_y + 20 * window_scale;
    var max_text_width = (256 - 77) * window_scale;
    var separation = 20 * window_scale;

    if (dialog_data != undefined && dialog_index < array_length(dialog_data)) {
        var dialog_entry = dialog_data[dialog_index];

        if (is_struct(dialog_entry) && variable_struct_exists(dialog_entry, "text") && is_string(dialog_entry.text)) {
            // Draw the dialogue text
            draw_set_color(c_black);
            draw_text_ext(text_x, text_y, dialog_entry.text, separation, max_text_width);
        } else {
            // Log an error if the data is invalid
            show_debug_message("ERROR: Invalid dialog_data entry or missing 'text' property at index " + string(dialog_index));
        }

        // Draw dialogue choices if available
        if (is_struct(dialog_entry) && variable_struct_exists(dialog_entry, "choices") && array_length(dialog_entry.choices) > 0) {
            // Define button height before using it
            var button_height = sprite_get_height(spr_button) * window_scale;
            var choices_y = window_y - button_height - 10 * window_scale;

            // Button and chat sprite sizes
            var button_width = sprite_get_width(spr_button) * window_scale;
            var chat_width = sprite_get_width(spr_chat) * window_scale;
            var chat_height = sprite_get_height(spr_chat) * window_scale;
            var spacing = 10 * window_scale;

            var num_choices = array_length(dialog_entry.choices);
            var total_choices_width = (num_choices * button_width) + ((num_choices - 1) * spacing);
            var choices_start_x = window_x + (scaled_width - total_choices_width) / 2;

            for (var i = 0; i < num_choices; i++) {
                var button_x = choices_start_x + i * (button_width + spacing);
                // Draw spr_button as background
                draw_sprite_ext(spr_button, 0, button_x, choices_y, window_scale, window_scale, 0, c_white, 1);
                // Center spr_chat within spr_button
                var chat_x = button_x + (button_width - chat_width) / 2;
                var chat_y = choices_y + (button_height - chat_height) / 2;
                draw_sprite_ext(spr_chat, 0, chat_x, chat_y, window_scale, window_scale, 0, c_white, 1);
                // Draw choice text centered in spr_chat
                draw_set_color(i == choice_selected ? c_red : c_black);
                draw_set_halign(fa_center);
                draw_set_valign(fa_middle);
                draw_text(chat_x + chat_width / 2, chat_y + chat_height / 2, dialog_entry.choices[i]);
                draw_set_halign(fa_left);
                draw_set_valign(fa_top);
            }
        }
    } else {
        // Log an error if the index or data is invalid
        show_debug_message("ERROR: dialog_data is undefined or dialog_index out of bounds. Index: " + string(dialog_index));
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Mouse_4.gml
// obj_chat_window: Mouse Left Pressed Event
if (global.chat_active) {
    // Convert mouse coordinates to GUI coordinates
    var gui_mouse_x = device_mouse_x_to_gui(0);
    var gui_mouse_y = device_mouse_y_to_gui(0);

    // GUI dimensions
    var gui_width = display_get_gui_width();
    var gui_height = display_get_gui_height();
    var menu_width = 300;
    var menu_height = 150;
    var menu_x = (gui_width - menu_width) / 2;
    var menu_y = gui_height - menu_height - 50;

    // Close button logic
    var close_button_size = 20;
    var close_x = menu_x + menu_width - close_button_size - 20;
    var close_y = menu_y + 20;

    if (gui_mouse_x >= close_x && gui_mouse_x <= close_x + close_button_size &&
        gui_mouse_y >= close_y && gui_mouse_y <= close_y + close_button_size) {
        global.chat_active = false;
        global.chat_npc = noone;
        dialog_queue = [];
        show_debug_message("Close button clicked. Chat deactivated.");
        exit;
    }

    // Dialogue choice logic (example)
    if (dialog_index < array_length(dialog_data)) {
        var dialog_entry = dialog_data[dialog_index];
        if (is_struct(dialog_entry) && variable_struct_exists(dialog_entry, "choices") && array_length(dialog_entry.choices) > 0) {
            var button_width = 100;  // Adjust based on your button sprite/size
            var button_height = 30;  // Adjust based on your button sprite/size
            var spacing = 10;
            var choices_y = menu_y + menu_height - button_height - 10;  // Position below dialogue text
            var num_choices = array_length(dialog_entry.choices);
            var total_choices_width = (num_choices * button_width) + ((num_choices - 1) * spacing);
            var choices_start_x = menu_x + (menu_width - total_choices_width) / 2;

            for (var i = 0; i < num_choices; i++) {
                var button_x = choices_start_x + i * (button_width + spacing);
                if (gui_mouse_x >= button_x && gui_mouse_x <= button_x + button_width &&
                    gui_mouse_y >= choices_y && gui_mouse_y <= choices_y + button_height) {
                    choice_selected = i;
                    dialog_index++;  // Advance to next dialogue
                    show_debug_message("Choice " + string(i) + " selected: " + dialog_entry.choices[i]);
                    // Add your action logic here (e.g., start quest, update variables)
                    break;
                }
            }
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Step_0.gml
// In obj_chat_window Step Event
if (global.chat_active) {
    if (dialog_index < array_length(dialog_data)) {
        var current_dialog = dialog_data[dialog_index];
        
        // Check condition for dialogue (if it exists)
        if (variable_struct_exists(current_dialog, "condition")) {
            if (!current_dialog.condition()) {
                dialog_index++;  // Skip if condition fails
                exit;
            }
        }
        
        // Handle choices if they exist
        if (variable_struct_exists(current_dialog, "choices")) {
            if (keyboard_check_pressed(vk_up)) {
                choice_selected = max(choice_selected - 1, 0);
            }
            if (keyboard_check_pressed(vk_down)) {
                choice_selected = min(choice_selected + 1, array_length(current_dialog.choices) - 1);
            }
            if (keyboard_check_pressed(vk_space)) {
                if (choice_selected >= 0) {
                    // Handle quest actions
                    if (variable_struct_exists(current_dialog, "quest")) {
                        var quest = current_dialog.quest;
                        with (global.chat_npc) {
                            if (quest.action == "start") {
                                quest_stage = 1;  // Quest started
                            } else if (quest.action == "complete") {
                                // Add your inventory check here (e.g., player has quest_item)
                                quest_stage = 2;  // Quest completed
                                // Add reward logic here
                            }
                        }
                    }
                    dialog_index++;  // Move to next dialogue
                    choice_selected = -1;
                }
            }
        } else {
            if (keyboard_check_pressed(vk_space)) {
                dialog_index++;  // Advance to next line
            }
        }
    } else {
        // Dialogue ended
        global.chat_active = false;
        instance_destroy();
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_icon
File: Create_0.gml
// Initialize state
image_index = 0; // Default: not selected
is_selected = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_icon
File: Mouse_4.gml

// Deselect all other color icons
with (obj_color_icon) {
    image_index = 0; // Not selected
    is_selected = false;
}

// Select this icon
image_index = 1; // Selected
is_selected = true;

// Set global player color
global.player_color = icon_color;
global.last_player_color = global.player_color; // Save the choice persistently


// Ensure this icon is assigned a valid color
if (icon_color == undefined) {
    show_debug_message("ERROR: Icon color is undefined in obj_color_icon.");
    icon_color = c_white; // Default to white
}


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_picker_controller
File: Create_0.gml
// Define custom colors
var c_notblack = make_color_rgb(51, 51, 51);
var c_bluer = make_color_rgb(46, 71, 170);
var c_brown = make_color_rgb(153, 102, 0);
var c_cyan = make_color_rgb(7, 167, 163);
var c_emerald = make_color_rgb(7, 106, 68);
var c_greener = make_color_rgb(6, 155, 77);
var c_lavender = make_color_rgb(176, 126, 194);
var c_lightblue = make_color_rgb(8, 153, 211);
var c_mint = make_color_rgb(189, 252, 201);
var c_oranger = make_color_rgb(255, 102, 0);
var c_pink = make_color_rgb(255, 51, 153);
var c_purpler = make_color_rgb(102, 49, 158);
var c_reder = make_color_rgb(204, 0, 0);
var c_salmon = make_color_rgb(255, 67, 63);
var c_yellower = make_color_rgb(255, 204, 0);

// Colors array
var colors = [
    c_notblack, c_bluer, c_brown, c_cyan, c_emerald,
    c_greener, c_lavender, c_lightblue, c_mint, c_oranger,
    c_pink, c_purpler, c_reder, c_salmon, c_yellower
];

// Sprites for color icons
var sprites = [
    spr_colouricon_black, spr_colouricon_blue, spr_colouricon_brown, spr_colouricon_cyan, spr_colouricon_emerald,
    spr_colouricon_green, spr_colouricon_lavendar, spr_colouricon_lightblue, spr_colouricon_mint, spr_colouricon_orange,
    spr_colouricon_pink, spr_colouricon_purple, spr_colouricon_red, spr_colouricon_salmon, spr_colouricon_yellow
];

// Grid dimensions
var cols = 5;
var rows = 3;
var spacing = 70; // Distance between grid items
var start_x = room_width / 2.2 - ((cols - 1) * spacing) / 2;
var start_y = room_height / 2.2 - ((rows - 1) * spacing) / 2;

// Create the grid
for (var i = 0; i < array_length(colors); i++) { // Use array_length explicitly
    var x_pos = start_x + (i mod cols) * spacing;
    var y_pos = start_y + (i div cols) * spacing;

    // Create color icon instance
    var color_icon = instance_create_layer(x_pos, y_pos, "Instances", obj_color_icon);
    color_icon.icon_color = colors[i];       // Assign color
    color_icon.sprite_index = sprites[i];    // Assign corresponding sprite
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_wheel
File: Create_0.gml
depth = -1000;
// Menu dimensions
menu_width = 109;
menu_height = 72;

// Position the skin picker around the current player instance or center it in the view
if (instance_exists(global.player_instance)) {
    x = global.player_instance.x - menu_width / 2;
    y = global.player_instance.y - menu_height / 2;
} else {
    x = view_xview[0] + (view_wview[0] - menu_width) / 2;
    y = view_yview[0] + (view_hview[0] - menu_height) / 2;
}

// Initialize variables
selected_color = c_white;
global.player_color = c_white;

// Define selection areas
color_wheel_x = x + 31;
color_wheel_y = y + 19;
color_wheel_width = 46;
color_wheel_height = 46;

exit_x = x + 6;
exit_y = y + 6;
exit_width = 9;
exit_height = 9;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_wheel
File: Draw_0.gml
// Draw the background first
draw_sprite(spr_colorpicker_background, 0, x, y);

// Draw the color wheel directly without using the surface
draw_sprite(spr_color_bar, 0, x + 31, y + 19);

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_wheel
File: Mouse_4.gml
var mx = (device_mouse_x_to_gui(0) / display_get_gui_width()) * camera_get_view_width(global.camera) + camera_get_view_x(global.camera);
var my = (device_mouse_y_to_gui(0) / display_get_gui_height()) * camera_get_view_height(global.camera) + camera_get_view_y(global.camera);

// Check if the player clicked inside the exit button (6,6 to 14,14)
if (point_in_rectangle(mx, my, exit_x, exit_y, exit_x + exit_width, exit_y + exit_height)) {
    show_debug_message("Closing color wheel...");
    with (obj_pause_menu) instance_destroy();
    instance_destroy();
    return;
}

// Check if the click is inside the color wheel selection area
if (point_in_rectangle(mx, my, color_wheel_x, color_wheel_y, color_wheel_x + color_wheel_width, color_wheel_y + color_wheel_height)) {
    var sx = mx - color_wheel_x; // Convert to surface coordinates
	var sy = my - color_wheel_y;

	if (sx >= 0 && sy >= 0 && sx < sprite_get_width(spr_color_bar) && sy < sprite_get_height(spr_color_bar)) {
		selected_color = surface_getpixel(surf_color_wheel, sx, sy);
	}

   if (selected_color != c_black) { // Avoid selecting transparent areas
    global.player_color = selected_color;

    if (instance_exists(global.player_instance)) {
        global.player_instance.image_blend = global.player_color;
    }

    show_debug_message("Color selected: " + string(selected_color));
    
    // Close color wheel & pause menu
    with (obj_pause_menu) instance_destroy();
    instance_destroy();
	}
}

show_debug_message("Color picked: " + string(draw_getpixel(mx, my)));
show_debug_message("Fixed Mouse World X: " + string(mouse_world_x) + " | Y: " + string(mouse_world_y));
show_debug_message("View X: " + string(camera_get_view_x(global.camera)) + " | View Y: " + string(camera_get_view_y(global.camera)));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_wheel
File: Step_0.gml
// Handle mouse click for selecting a color
if (mouse_check_button_pressed(mb_left)) {
    var mx = device_mouse_x_to_gui(0);
    var my = device_mouse_y_to_gui(0);

    if (point_in_rectangle(mx, my, x, y, x + sprite_width, y + sprite_height)) {
        var sx = mx - x; // Convert to surface coordinates
        var sy = my - y;

        // Ensure the surface exists before sampling
        if (surface_exists(surf_color_wheel)) {
            selected_color = surface_getpixel(surf_color_wheel, sx, sy);
        } else {
            selected_color = c_black; // Fallback
        }

        // Apply color globally if valid
        if (selected_color != c_black) {
            global.player_color = selected_color;
            if (instance_exists(global.player_instance)) {
                global.player_instance.image_blend = global.player_color;
            }
            show_debug_message("Color selected: " + string(selected_color));
        }
        
        // Close the color wheel and return to previous room
        if (variable_global_exists("last_room") && global.last_room != noone) {
            room_goto(global.last_room);
        } else {
            room_goto(rm_town); // Default return room
        }
        instance_destroy();
    }
}


// Debug mouse position
show_debug_message("Mouse X: " + string(mouse_x) + " | Mouse Y: " + string(mouse_y));
show_debug_message("GUI Mouse X: " + string(device_mouse_x_to_gui(0)) + " | GUI Mouse Y: " + string(device_mouse_y_to_gui(0)));
show_debug_message("View X: " + string(camera_get_view_x(view_camera[0])) + " | View Y: " + string(camera_get_view_y(view_camera[0])));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_config_menu
File: Create_0.gml
// obj_config_menu: Create Event
depth = -10000; // Draw on top of other UI
item_scroll = 0; // Starting position for item list scrolling

// Center the panel
panel_width = sprite_get_width(spr_blue_square_panel);
panel_height = sprite_get_height(spr_blue_square_panel);
panel_x = (display_get_gui_width() - panel_width) / 2;
panel_y = (display_get_gui_height() - panel_height) / 2;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_config_menu
File: Draw_64.gml
//obj_config_menu Draw GUI event
// Draw background
draw_sprite(spr_blue_square_panel, 0, panel_x, panel_y);

// Skin buttons
var title = "Skins";
var title_width = string_width(title);
draw_text(panel_x + 20 + (100 - title_width) / 2, panel_y + 20, title);
var button_y = panel_y + 40;
for (var i = 0; i < array_length(global.skins); i++) {
    draw_set_color(c_white);
    draw_rectangle(panel_x + 20, button_y, panel_x + 120, button_y + 30, false); // 100x30 rectangle
    draw_set_color(c_black);
    var text = "Switch to " + global.skins[i].name;
    var text_width = string_width(text);
    var text_height = string_height(text);
    var text_x = panel_x + 20 + (100 - text_width) / 2; // Center horizontally
    var text_y = button_y + (30 - text_height) / 2; // Center vertically
    draw_text(text_x, text_y, text);
    button_y += 40;
}

// Item buttons with sprites
draw_set_color(c_black);
draw_text(panel_x + 170, panel_y + 20, "Items");
var items = ["Beta Hat", "Party Hat", "Wrench", "Tube", "Toboggan", "Battery", "Spy Phone", "Broken Spy Phone", "EPF Phone", "Fishing Rod", "Jackhammer", "Snow Shovel", "Pizza Slice", "Puffle O", "Box Puffle O", "Fish", "Mullet", "Wood", "Snow"];
var item_display_count = 5;
button_y = panel_y + 40;
for (var i = item_scroll; i < item_scroll + item_display_count && i < array_length(items); i++) {
    var square_x = panel_x + 150;
    var square_y = button_y;
    draw_set_color(c_white);
    draw_rectangle(square_x, square_y, square_x + 30, square_y + 30, false); // 30x30 square
    var item_index = ds_map_find_value(global.item_index_map, items[i]);
    if (!is_undefined(item_index)) {
        draw_sprite_part(spr_inventory_items, 0, item_index * 18, 0, 18, 18, square_x + 6, square_y + 6); // Centered sprite
    }
    button_y += 40;
}

// Scroll buttons
draw_set_color(c_white);
draw_rectangle(panel_x + 190, panel_y + 40, panel_x + 210, panel_y + 60, false); // Up button
draw_rectangle(panel_x + 190, panel_y + 60, panel_x + 210, panel_y + 80, false); // Down button
draw_set_color(c_black);
draw_text(panel_x + 200, panel_y + 45, "^");
draw_text(panel_x + 200, panel_y + 65, "v");

// Color picker buttons
draw_set_color(c_black);
draw_text(panel_x + 220, panel_y + 20, "Colors");
draw_set_color(c_white);
draw_rectangle(panel_x + 220, panel_y + 40, panel_x + 320, panel_y + 70, false);  // Player Color button
draw_set_color(c_black);
draw_set_halign(fa_center);
draw_text(panel_x + 270, panel_y + 55, "Player Color");
draw_set_color(c_white);
draw_rectangle(panel_x + 220, panel_y + 80, panel_x + 320, panel_y + 110, false); // Icetruck Color button
draw_set_color(c_black);
draw_text(panel_x + 270, panel_y + 95, "Icetruck Color");
draw_set_halign(fa_left);

// Close button
draw_set_color(c_red);
draw_rectangle(panel_x + panel_width - 30, panel_y + 10, panel_x + panel_width - 10, panel_y + 30, false);
draw_set_color(c_white);
draw_set_halign(fa_center);
draw_text(panel_x + panel_width - 20, panel_y + 12, "X"); // Center of 20x20 button
draw_set_halign(fa_left); // Reset to default


//npc dialouge code!!
if (global.chat_active && array_length(dialog_data) > 0 && variable_struct_exists(current_dialog, "choices") && array_length(current_dialog.choices) > 0) {
    var gui_width = display_get_gui_width();
    var gui_height = display_get_gui_height();
    
    // Determine inventory height based on HUD state
    var inventory_height;
    if (instance_exists(obj_hud_expanded) && global.is_expanded) {
        inventory_height = sprite_get_height(spr_hud_expanded) * 3; // Assuming ui_scale = 3
    } else {
        inventory_height = 50; // Default height for regular inventory
    }
    
    // Position choices above inventory
    var choices_y = gui_height - inventory_height - 20; // 20px buffer
    var num_choices = array_length(current_dialog.choices);
    var choice_width = 100; // Fixed width per choice
    var spacing = 10; // Space between choices
    var total_width = choice_width * num_choices + spacing * (num_choices - 1);
    var start_x = (gui_width - total_width) / 2; // Center horizontally

    // Draw each choice
    for (var i = 0; i < num_choices; i++) {
        var choice_x = start_x + i * (choice_width + spacing);
        draw_set_color(i == choice_selected ? c_red : c_black);
        draw_text(choice_x, choices_y, current_dialog.choices[i]);
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_config_menu
File: Step_0.gml
// obj_config_menu Step Event
if (mouse_check_button_pressed(mb_left)) {
    var mx = device_mouse_x_to_gui(0);
    var my = device_mouse_y_to_gui(0);
    
    // Skin buttons
    var button_y = panel_y + 40;
    for (var i = 0; i < array_length(global.skins); i++) {
        if (point_in_rectangle(mx, my, panel_x + 20, button_y, panel_x + 120, button_y + 30)) {
            obj_controller.switch_skin(global.skins[i].name);
            show_debug_message("Switched to skin: " + global.skins[i].name);
            global.ui_manager.close_ui();
            if (instance_exists(obj_inventory)) {
                obj_inventory.visible = true;  // Restore inventory
                show_debug_message("Inventory visibility set to true after skin switch.");
            }
            break;
        }
        button_y += 40;
    }
    
    // Item buttons
    var items = ["Beta Hat", "Party Hat", "Wrench", "Tube", "Toboggan", "Battery", "Spy Phone", "Broken Spy Phone", "EPF Phone", "Fishing Rod", "Jackhammer", "Snow Shovel", "Pizza Slice", "Puffle O", "Box Puffle O", "Fish", "Mullet", "Wood", "Snow"];
    var item_display_count = 5;
    button_y = panel_y + 40;
    var should_close = false;
    for (var i = item_scroll; i < item_scroll + item_display_count && i < array_length(items); i++) {
        if (point_in_rectangle(mx, my, panel_x + 150, button_y, panel_x + 180, button_y + 30)) {
            obj_inventory.add_to_inventory(items[i]);
            show_debug_message("Spawned item: " + items[i]);
            should_close = true;  // Flag to close after spawning
            break;
        }
        button_y += 40;
    }
    
    // Scroll buttons
    if (point_in_rectangle(mx, my, panel_x + 190, panel_y + 40, panel_x + 210, panel_y + 60)) {
        item_scroll = max(0, item_scroll - 1);
    } else if (point_in_rectangle(mx, my, panel_x + 190, panel_y + 60, panel_x + 210, panel_y + 80)) {
        item_scroll = min(array_length(items) - item_display_count, item_scroll + 1);
    }
    
    // Color picker buttons
    if (point_in_rectangle(mx, my, panel_x + 220, panel_y + 40, panel_x + 320, panel_y + 70)) {
        instance_create_layer(0, 0, "Instances", obj_player_colourpicker);
        global.ui_manager.close_ui();
        if (instance_exists(obj_inventory)) {
            obj_inventory.visible = true;  // Restore inventory
            show_debug_message("Inventory visibility set to true after player colour picker.");
        }
    } else if (point_in_rectangle(mx, my, panel_x + 220, panel_y + 80, panel_x + 320, panel_y + 110)) {
        instance_create_layer(0, 0, "Instances", obj_icetruck_colourpicker);
        global.ui_manager.close_ui();
        if (instance_exists(obj_inventory)) {
            obj_inventory.visible = true;  // Restore inventory
            show_debug_message("Inventory visibility set to true after icetruck colour picker.");
        }
    }
    
    // Close button
    if (point_in_rectangle(mx, my, panel_x + panel_width - 30, panel_y + 10, panel_x + panel_width - 10, panel_y + 30)) {
        global.ui_manager.close_ui();
        if (instance_exists(obj_inventory)) {
            obj_inventory.visible = true;  // Restore inventory
            show_debug_message("Inventory visibility set to true after close button.");
        }
        show_debug_message("Configuration menu closed.");
    }
    
    // Close after spawning item
    if (should_close) {
        global.ui_manager.close_ui();
        if (instance_exists(obj_inventory)) {
            obj_inventory.visible = true;  // Restore inventory
            show_debug_message("Inventory visibility set to true after spawning item.");
        }
    }
}

if (keyboard_check_pressed(vk_escape)) {
    global.ui_manager.close_ui();
    if (instance_exists(obj_inventory)) {
        obj_inventory.visible = true;  // Restore inventory
        show_debug_message("Inventory visibility set to true after ESC.");
    }
    show_debug_message("Configuration menu closed via ESC.");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_continue_button
File: Create_0.gml
depth = -1000;
visible = file_exists("savegame.sav");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_continue_button
File: Mouse_4.gml
load_game();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Alarm_0.gml
// Ensure the new player instance is created after the previous one is destroyed
if (global.skin_to_spawn != noone) {
    var player_x = global.last_player_x;
    var player_y = global.last_player_y;

    // Create the new player instance
    global.player_instance = instance_create_layer(player_x, player_y, "Instances", global.skin_to_spawn);
    global.current_skin = global.skin_name_to_spawn;

    // Reset the temporary skin variables
    global.skin_to_spawn = noone;
    global.skin_name_to_spawn = "";

    // Ensure camera follows the new player
    if (instance_exists(global.player_instance)) {
        camera_set_view_target(global.camera, global.player_instance);
        show_debug_message("Skin switched to: " + global.current_skin + ". New instance ID: " + string(global.player_instance));
    } else {
        show_debug_message("ERROR: Failed to create player instance.");
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Create_0.gml
/// Create Event for obj_controller
global.is_loading_game = false;
if (!global.is_loading_game) {
    init_globals();
} 
global.chat_active = false;
global.chat_npc = noone;
global.player_controls_enabled = true;

persistent = true; // Ensure persistence across rooms

// Initialize global variables early to avoid undefined references
global.dialogue_active = false; // Dialogue system starts inactive

// Track clicks processed by any UI elements
global.click_handled = false;
global.is_expanded = false;

// Get the FPS value for the room
var room_fps = game_get_speed(gamespeed_fps);

// Initialize countdown_timer with the desired duration in seconds multiplied by room_fps
global.countdown_timer = 1 * room_fps; // 1 second countdown 
global.is_pause_menu_active = false;
global.game_started = false; // Flag to check if the game has started
global.lives = 3; // Initialize player lives
game_timer = 0; // Initialize game timer
global.skin_switching = false; // Initialize the skin switching flag

// Initialize global variables
global.skins = [
    { name: "player", object: obj_player },
    { name: "icetruck", object: obj_player_icetruck },
    { name: "tube", object: obj_player_tube },
    { name: "toboggan", object: obj_player_toboggan },
    { name: "sled_player", object: obj_sled_player },
    { name: "ninja", object: obj_player_ninja }
];

global.current_skin = "player"; // Starting skin
global.player_instance = noone; // Initialize player instance
global.icetruck_destroyed = false; // Initialize icetruck_destroyed

// Define player colors globally
global.player_colors = [
    make_color_rgb(51, 51, 51),    // notblack
    make_color_rgb(46, 71, 170),   // bluer
    make_color_rgb(153, 102, 0),   // brown
    make_color_rgb(7, 167, 163),   // cyan
    make_color_rgb(7, 106, 68),    // emerald
    make_color_rgb(6, 155, 77),    // greener
    make_color_rgb(176, 126, 194), // lavender
    make_color_rgb(8, 153, 211),   // lightblue
    make_color_rgb(189, 252, 201), // mint
    make_color_rgb(255, 102, 0),   // oranger
    make_color_rgb(255, 51, 153),  // pink
    make_color_rgb(102, 49, 158),  // purpler
    make_color_rgb(204, 0, 0),     // reder
    make_color_rgb(255, 67, 63),   // salmon
    make_color_rgb(255, 204, 0)    // yellower
];

// Room state management
if (!variable_global_exists("room_states")) {
    global.room_states = ds_map_create();
}
global.current_room = room; // Track current room

// Ensure player instance exists
if (global.player_instance == noone) {
    if (global.current_skin == "player") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player);
    } else if (global.current_skin == "icetruck") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player_icetruck);
    } else if (global.current_skin == "tube") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player_tube);
    } else if (global.current_skin == "sled_player") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_sled_player);
    } else if (global.current_skin == "ninja") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player_ninja);
    } else if (global.current_skin == "toboggan") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player_toboggan);
    }
}

if (instance_exists(global.player_instance)) {
    global.player_instance.image_blend = global.player_color;
    show_debug_message("Restored player color: " + string(global.player_color));
} 

if (!variable_global_exists("following_puffles")) {
    global.following_puffles = ds_list_create();
}

// Quest management
global.active_quests = ds_list_create();
global.completed_quests = ds_list_create();
global.quest_progress = ds_map_create();
global.quest_definitions = ds_map_create();

// Define a sample quest
function create_quest(_id, _name, _description, _objectives, _rewards) {
    var quest = ds_map_create();
    ds_map_add(quest, "id", _id);
    ds_map_add(quest, "name", _name);
    ds_map_add(quest, "description", _description);
    ds_map_add(quest, "objectives", _objectives);
    ds_map_add(quest, "rewards", _rewards);
    return quest;
}

// Sample quest: Find the Missing Puffle
var quest1 = create_quest(
    1,
    "Find the Missing Puffle",
    "Help the NPC find their lost puffle.",
    [
        { "type": "collect", "item": "Puffle O", "amount": 1 },
        { "type": "talk", "npc": "NPC1" }
    ],
    { "coins": 100, "item": "Beta Hat" }
);
ds_map_add(global.quest_definitions, 1, quest1);

// Debugging
if (instance_exists(global.player_instance)) {
    show_debug_message("Player instance created: " + string(global.player_instance));
} else {
    show_debug_message("Error: Failed to create player instance.");
}

// Add debug message to confirm Create event runs
show_debug_message("obj_controller created with ID: " + string(id));
show_debug_message("obj_controller Create event executed");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Other_3.gml
function cleanup_game() {
if (ds_exists(global.room_states, ds_type_map)) {
    ds_map_destroy(global.room_states);
}
if (ds_exists(global.following_puffles, ds_type_list)) {
    ds_list_destroy(global.following_puffles);
}
if (ds_exists(global.active_quests, ds_type_list)) {
    ds_list_destroy(global.active_quests);
}
if (ds_exists(global.completed_quests, ds_type_list)) {
    ds_list_destroy(global.completed_quests);
}
if (ds_exists(global.quest_progress, ds_type_map)) {
    ds_map_destroy(global.quest_progress);
}
if (ds_exists(global.quest_definitions, ds_type_map)) {
    ds_map_destroy(global.quest_definitions);
}
// Add destruction for other global data structures used in your project
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Other_4.gml
/// Room Start Event for obj_controller
show_debug_message("obj_controller Room Start event started in room: " + room_get_name(room));

// Handle player creation
var is_ui_room = (room == rm_init || room == rm_main_menu || room == rm_map || 
                  room == rm_pause_menu || room == rm_settings_menu || room == rm_saveload);

if (!instance_exists(global.player_instance) && !is_ui_room) {
    var player_x = global.is_loading_game ? global.player_x : (variable_global_exists("last_player_x") ? global.last_player_x : 170);
    var player_y = global.is_loading_game ? global.player_y : (variable_global_exists("last_player_y") ? global.last_player_y : 154);
    var player_obj;
    switch (global.current_skin) {
        case "player": player_obj = obj_player; break;
        case "toboggan": player_obj = obj_player_toboggan; break;
        case "tube": player_obj = obj_player_tube; break;
        case "icetruck": player_obj = obj_player_icetruck; break;
        case "sled_player": player_obj = obj_sled_player; break;
        case "ninja": player_obj = obj_player_ninja; break;
        default:
            player_obj = obj_player;
            show_debug_message("WARNING: Unknown skin '" + global.current_skin + "', defaulting to obj_player.");
    }
    global.player_instance = instance_create_layer(player_x, player_y, "Instances", player_obj);
    if (instance_exists(global.player_instance)) {
        global.player_instance.persistent = true;
        global.player_instance.image_blend = global.player_color;
        global.player_instance.face = global.is_loading_game ? global.last_player_face : DOWN;
        show_debug_message("DEBUG: Player created at (" + string(player_x) + ", " + string(player_y) + ") with skin: " + global.current_skin);
    } else {
        show_debug_message("ERROR: Failed to create player instance.");
    }
    if (global.is_loading_game) {
        global.is_loading_game = false;
        show_debug_message("Loading complete, reset is_loading_game flag.");
    }
} else if (is_ui_room && instance_exists(global.player_instance)) {
    global.last_player_x = global.player_instance.x;
    global.last_player_y = global.player_instance.y;
    instance_destroy(global.player_instance);
    global.player_instance = noone;
    camera_set_view_target(global.camera, noone);
    var cam_x = room_width / 2;
    var cam_y = room_height / 2;
    camera_set_view_pos(global.camera, cam_x - (camera_get_view_width(global.camera) / 2), cam_y - (camera_get_view_height(global.camera) / 2));
}

// Load room state
load_room_state(room);
show_debug_message("DEBUG: Room Start Event triggered in obj_controller.");

// Set camera to follow player
if (instance_exists(global.player_instance)) {
    camera_set_view_target(global.camera, global.player_instance);
    show_debug_message("DEBUG: Camera now follows player.");
    var target_x = global.player_instance.x - (camera_get_view_width(global.camera) / 2);
    var target_y = global.player_instance.y - (camera_get_view_height(global.camera) / 2);
    camera_set_view_pos(global.camera, target_x, target_y);
} else if (!is_ui_room) {
    show_debug_message("WARNING: No player instance in non-UI room.");
}

// Handle Puffle instance
if (instance_exists(obj_puffle)) {
    with (obj_puffle) {
        if (!variable_instance_exists(id, "following_player")) {
            following_player = false;
        }
        if (following_player) { 
            x = global.player_instance.x + 16;
            y = global.player_instance.y + 16;
        }
    }
}

// Ensure a "UI" layer exists for GUI elements
if (!layer_exists("UI")) {
    layer_create(0, "UI");
    show_debug_message("DEBUG: UI layer created.");
} else {
    show_debug_message("DEBUG: UI layer already exists.");
}

// Pause system
if (global.dialogue_active) {
    with (obj_player) { move_speed = 0; }
    with (obj_npc) { move_speed = 0; }
} else {
    with (obj_player) { move_speed = move_spd; }
    with (obj_npc) { move_speed = move_spd; }
}

// Hide Inventory in the Pause Menu
if (room == rm_pause_menu) {
    with (obj_inventory) {
        visible = false;
    }
    show_debug_message("DEBUG: Inventory hidden in pause menu.");
} else {
    with (obj_inventory) {
        visible = true;
    }
    show_debug_message("DEBUG: Inventory restored after pause menu.");
}

// Ensure the ice truck remains destroyed if it was destroyed previously
if (global.icetruck_destroyed && instance_exists(obj_icetruck)) {
    with (obj_icetruck) {
        instance_destroy();
    }
}

// Create UI manager if it doesn't exist
if (!instance_exists(obj_ui_manager)) {
    instance_create_layer(0, 0, "UI", obj_ui_manager);
    show_debug_message("DEBUG: Created obj_ui_manager in Room Start.");
}

// Final debug messages
show_debug_message("Pause menu closed.");
if (instance_exists(obj_skinpicker)) {
    show_debug_message("Skin picker opened successfully.");
} else if (instance_exists(obj_color_wheel)) {
    show_debug_message("Color wheel opened successfully.");
}
show_debug_message("DEBUG: Room Start Event completed. Current skin: " + global.current_skin);
show_debug_message("DEBUG: Player instance ID: " + string(global.player_instance));
show_debug_message("obj_controller Room Start event for ID: " + string(id));
show_debug_message("Room Start Event triggered in obj_controller.");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Other_5.gml

if (!global.is_loading_game) {
    save_room_state(room);
show_debug_message("Saved state for room: " + room_get_name(room));
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Step_0.gml
/// Step Event for obj_controller
global.click_handled = false;
// Toggle Pause Menu with ESC
if (keyboard_check_pressed(vk_escape) && !global.colour_picker_active) {
    global.is_pause_menu_active = !global.is_pause_menu_active;
    if (global.is_pause_menu_active) {
        global.player_controls_enabled = false;
        show_debug_message("Game Paused");
    } else {
        global.player_controls_enabled = true;
        if (instance_exists(obj_inventory)) {
            obj_inventory.visible = true;  // Restore inventory
        }
        show_debug_message("Game Resumed");
    }
}

// Toggle expanded inventory
if (keyboard_check_pressed(ord("I"))) {
    if (instance_exists(obj_inventory_expanded)) {
        with (obj_inventory_expanded) {
            instance_destroy();
        }
        global.game_paused = false;
    } else {
        instance_create_layer(0, 0, "Instances", obj_inventory_expanded);
        global.game_paused = true;
    }
}

// Toggle icetruck colour picker with "C" when skin is icetruck
if (keyboard_check_pressed(ord("C")) && global.current_skin == "icetruck") {
    if (instance_exists(obj_icetruck_colourpicker)) {
        with (obj_icetruck_colourpicker) instance_destroy();
    } else {
        instance_create_layer(0, 0, "Instances", obj_icetruck_colourpicker);
    }
}

// Ensure inventory visibility in non-UI rooms
var is_ui_room = (room == rm_init || room == rm_main_menu || room == rm_map || room == rm_pause_menu || room == rm_settings_menu);
if (!is_ui_room && instance_exists(obj_inventory)) {
    if (!global.is_pause_menu_active) {  // Only show when not paused
        obj_inventory.visible = false;
    }
}
if (!is_ui_room && instance_exists(global.player_instance)) {
    camera_set_view_target(global.camera, global.player_instance);
}

// Hide or show the player in UI rooms
if (is_ui_room) {
    if (instance_exists(global.player_instance)) {
        global.player_instance.visible = false;
        show_debug_message("DEBUG: UI Room detected. Player instance hidden.");
    }
} else {
    if (!instance_exists(global.player_instance)) {
        show_debug_message("WARNING: No player instance found. Recreating...");
        var player_x = global.player_x;
        var player_y = global.player_y;
        var player_obj;
        switch (global.current_skin) {
            case "player":
                player_obj = obj_player;
                break;
            case "toboggan":
                player_obj = obj_player_toboggan;
                break;
            case "tube":
                player_obj = obj_player_tube;
                break;
            case "icetruck":
                player_obj = obj_player_icetruck;
                break;
            case "sled_player":
                player_obj = obj_sled_player;
                break;
            case "ninja":
                player_obj = obj_player_ninja;
                break;
            default:
                player_obj = obj_player;
        }
        global.player_instance = instance_create_layer(player_x, player_y, "Instances", player_obj);
        show_debug_message("DEBUG: Player recreated in Step event at (" + string(player_x) + ", " + string(player_y) + ") with skin: " + global.current_skin);
    } else {
        global.player_instance.visible = true;
    }
    if (instance_exists(global.player_instance)) {
        camera_set_view_target(global.camera, global.player_instance);
    } else {
        show_debug_message("ERROR: Camera could not follow player instance.");
    }
}

// Function to switch player skins
function switch_skin(new_skin) {
    if (global.skin_switching) return;
    global.skin_switching = true;

    var player_x = global.player_instance != noone ? global.player_instance.x : global.player_x;
    var player_y = global.player_instance != noone ? global.player_instance.y : global.player_y;
    var player_face = DOWN;
    var saved_icetruck_tint = c_white;

    // Preserve tint if switching from icetruck
    if (instance_exists(global.player_instance) && global.current_skin == "icetruck") {
        saved_icetruck_tint = global.player_instance.icetruck_tint;
    }

    if (instance_exists(global.player_instance)) {
        if (variable_instance_exists(global.player_instance, "face")) {
            player_face = global.player_instance.face;
        }
        instance_destroy(global.player_instance);
    }

    var new_instance = noone;
    var skin_found = false;
    for (var i = 0; i < array_length(global.skins); i++) {
        if (global.skins[i].name == new_skin) {
            new_instance = instance_create_layer(player_x, player_y, "Instances", global.skins[i].object);
            global.current_skin = new_skin;
            skin_found = true;
            break;
        }
    }

    if (!skin_found || new_instance == noone) {
        new_instance = instance_create_layer(player_x, player_y, "Instances", obj_player);
        global.current_skin = "player";
        show_debug_message("WARNING: Defaulted to player skin. Invalid skin name: " + new_skin);
    }

    if (variable_instance_exists(new_instance, "face")) {
        new_instance.face = player_face;
    }
    if (new_skin == "icetruck" && variable_instance_exists(new_instance, "icetruck_tint")) {
        new_instance.icetruck_tint = saved_icetruck_tint;
    }

    global.player_instance = new_instance;
    camera_set_view_target(global.camera, global.player_instance);
    show_debug_message("Switched to skin: " + new_skin + ". New instance ID: " + string(new_instance));

    global.skin_switching = false;
}

if (room == rm_sled_racing) {
    switch_skin("sled_player");
}

// Function to start a quest
function start_quest(quest_id) {
    if (!ds_list_find_index(global.active_quests, quest_id)) {
        ds_list_add(global.active_quests, quest_id);
        var quest = ds_map_find_value(global.quest_definitions, quest_id);
        var progress = ds_map_create();
        for (var i = 0; i < array_length(quest[?"objectives"]); i++) {
            ds_map_add(progress, i, false); // Not completed
        }
        ds_map_add(global.quest_progress, quest_id, progress);
        show_debug_message("Started quest: " + quest[?"name"]);
    }
}

// Function to check quest completion
function check_quest_completion(quest_id) {
    var progress = ds_map_find_value(global.quest_progress, quest_id);
    if (progress == undefined) return false;
    var quest = ds_map_find_value(global.quest_definitions, quest_id);
    var objectives = quest[?"objectives"];
    for (var i = 0; i < array_length(objectives); i++) {
        var obj = objectives[i];
        if (obj.type == "collect") {
            var item_count = obj_inventory.get_inventory_item_count(obj.item);
            if (item_count < obj.amount) return false;
        } else if (obj.type == "talk") {
            if (!ds_map_find_value(progress, i)) return false;
        }
    }
    return true;
}

// Function to complete a quest
function complete_quest(quest_id) {
    var index = ds_list_find_index(global.active_quests, quest_id);
    if (index != -1) {
        ds_list_delete(global.active_quests, index);
        ds_list_add(global.completed_quests, quest_id);
        var quest = ds_map_find_value(global.quest_definitions, quest_id);
        var rewards = quest[?"rewards"];
        if (variable_struct_exists(rewards, "coins")) {
            global.coins = variable_global_exists("coins") ? global.coins + rewards.coins : rewards.coins;
        }
        if (variable_struct_exists(rewards, "item")) {
            obj_inventory.add_to_inventory(rewards.item);
        }
        var progress = ds_map_find_value(global.quest_progress, quest_id);
        ds_map_destroy(progress);
        ds_map_delete(global.quest_progress, quest_id);
        show_debug_message("Completed quest: " + quest[?"name"]);
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_crates
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_dock
File: Step_0.gml
set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_dropped_item
File: Create_0.gml
// Set item properties
item_type = ""; // Set when the object is created
sprite_index = spr_inventory_items;
is_savable = true; // Mark as savable
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_dropped_item
File: Draw_0.gml
// Draw the dropped item
draw_sprite(sprite_index, 0, x, y);

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_dropped_item
File: Step_0.gml
// Check if player picks up the item
if (distance_to_object(global.player_instance) < 16 && keyboard_check_pressed(ord("E"))) {
    obj_inventory.add_to_inventory(item_type);
    instance_destroy();
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_epfphone_item
File: Create_0.gml
event_inherited();
item_name = "EPF Phone";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishbarrel1
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishbarrel2
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishbarrel3
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishbarrel4
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishing_rod
File: Create_0.gml
event_inherited();
item_name = "Fishing Rod";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ghostcostume_item
File: Create_0.gml
event_inherited();
item_name = "Ghost Costume";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_hud_expanded
File: Create_0.gml
// obj_hud_expanded: Create Event
depth = -10000;
inventory = obj_inventory.inventory;
inventory_size = obj_inventory.inventory_size;
active_slot = obj_inventory.active_slot;
global.active_item_index = active_slot;
global.is_special_actions_open = false
is_active = true;
global.expanded_hud_instance = id;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_hud_expanded
File: Draw_64.gml
// obj_hud_expanded: Draw GUI Event
if (is_active) {
if (global.is_expanded) {
    var ui_scale = 3;
    var gui_width = display_get_gui_width();
    var gui_height = display_get_gui_height();
    var inv_width = sprite_get_width(spr_hud_expanded) * ui_scale;
    var inv_height = sprite_get_height(spr_hud_expanded) * ui_scale;
    var inv_x = (gui_width - inv_width) / 2;
    var inv_y = gui_height - inv_height;
    draw_sprite_ext(spr_hud_expanded, 0, inv_x, inv_y, ui_scale, ui_scale, 0, c_white, 1);

    // Draw inventory items
    var slot_positions = [
        [inv_x + 5 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 25 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 45 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 65 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 85 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 105 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 125 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 145 * ui_scale, inv_y + 14 * ui_scale]
    ];

    for (var i = 0; i < 8; i++) {
                if (!is_undefined(inventory[i]) && inventory[i] != -1) { // Skip empty slots
                    var slot_x = slot_positions[i][0];
                    var slot_y = slot_positions[i][1];
                    var item_index = inventory[i];
                    var x_offset, y_offset;
                    if (item_index < 21) { // First row: items 0â€“20
                        x_offset = item_index * 18;
                        y_offset = 0;
                    } else { // Second row: items 21â€“24
                        x_offset = (item_index - 21) * 18;
                        y_offset = 18;
                    }
                    draw_sprite_part_ext(spr_inventory_items, 0, x_offset, y_offset, 18, 18, slot_x, slot_y, ui_scale, ui_scale, c_white, 1);
                    if (i == active_slot) {
                        draw_sprite_ext(spr_inventory_highlight, 0, slot_x - 1 * ui_scale, slot_y - 1 * ui_scale, ui_scale, ui_scale, 0, c_white, 1);
                    }
                }
            }

    // Draw special actions menu
    if (global.is_special_actions_open) {
        var special_x = inv_x + 85 * ui_scale;
        var special_y = inv_y + 37 * ui_scale - sprite_get_height(spr_hud_special_actions) * ui_scale;
        draw_sprite_ext(spr_hud_special_actions, 0, special_x, special_y, ui_scale, ui_scale, 0, c_white, 1);
    }
	update_equipped_items_display();
}
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_hud_expanded
File: Step_0.gml
// obj_hud_expanded Step event
if (global.chat_active) exit;
// Handle mouse clicks
if (is_active) {
    if (mouse_check_button_pressed(mb_left)) {
        var mx = device_mouse_x_to_gui(0);
        var my = device_mouse_y_to_gui(0);
	
    var ui_scale = 3;
    var gui_width = display_get_gui_width();
    var gui_height = display_get_gui_height();
    var inv_width = sprite_get_width(spr_hud_expanded) * ui_scale;
    var inv_x = (gui_width - inv_width) / 2;
    var inv_y = gui_height - sprite_get_height(spr_hud_expanded) * ui_scale;
    var close_area_left = inv_x + 54 * ui_scale;
    var close_area_top = inv_y + 2 * ui_scale;
    var close_area_right = inv_x + 112 * ui_scale;
    var close_area_bottom = inv_y + 9 * ui_scale;
	// Define the special actions button area
    var special_area_left = inv_x + 85 * ui_scale;
    var special_area_top = inv_y + 37 * ui_scale;
    var special_area_right = inv_x + 102 * ui_scale;
    var special_area_bottom = inv_y + 54 * ui_scale;

	if (point_in_rectangle(mx, my, close_area_left, close_area_top, close_area_right, close_area_bottom)) {
	    global.expanded_hud_open = false; // Add this line
	    global.is_expanded = false;
	    instance_destroy();
	    global.expanded_hud_instance = noone;
	    show_debug_message("Expanded HUD closed successfully.");
	    global.click_handled = true;
	    return;
	}
		// Open expanded inventory menu
        else if (point_in_rectangle(mx, my, inv_x + 65 * ui_scale, inv_y + 37 * ui_scale, inv_x + 82 * ui_scale, inv_y + 54 * ui_scale)) {
            instance_create_layer(0, 0, "Instances", obj_inventory_expanded);
            show_debug_message("Expanded inventory menu opened.");
        }
        // Open special actions menu
        else if (point_in_rectangle(mx, my, special_area_left, special_area_top, special_area_right, special_area_bottom)) {
        global.is_special_actions_open = !global.is_special_actions_open;
        show_debug_message("Special actions menu toggled: " + (global.is_special_actions_open ? "open" : "closed"));
        return;
		}
        // Throw a snowball (placeholder)
        else if (point_in_rectangle(mx, my, inv_x + 105 * ui_scale, inv_y + 37 * ui_scale, inv_x + 122 * ui_scale, inv_y + 54 * ui_scale)) {
            global.is_expanded = false;
            show_debug_message("Throw snowball clicked - to be implemented.");
            // Add snowball logic here later
        }
        // Go to igloo (placeholder)
        else if (point_in_rectangle(mx, my, inv_x + 125 * ui_scale, inv_y + 37 * ui_scale, inv_x + 142 * ui_scale, inv_y + 54 * ui_scale)) {
            global.is_expanded = false;
            show_debug_message("Go to igloo clicked - to be implemented.");
            // Add igloo room transition here later
        }
        // Open configuration menu
        else if (point_in_rectangle(mx, my, inv_x + 145 * ui_scale, inv_y + 37 * ui_scale, inv_x + 162 * ui_scale, inv_y + 54 * ui_scale)) {
            global.ui_manager.open_ui(obj_config_menu);
            show_debug_message("Configuration menu opened.");
            is_active = false; // Deactivate the expanded HUD
            return;
        }
        
         // Handle special actions menu clicks
    if (global.is_special_actions_open) {
        var special_x = inv_x + 85 * ui_scale;
        var special_y = inv_y + 37 * ui_scale - sprite_get_height(spr_hud_special_actions) * ui_scale;
        
        // Wave action (coordinates: adjust as per your sprite layout)
        if (point_in_rectangle(mx, my, special_x + 1 * ui_scale, special_y + 41 * ui_scale, special_x + 16 * ui_scale, special_y + 55 * ui_scale)) {
            obj_player.action_state = "wave";
            obj_player.action_timer = 0;
            obj_player.action_duration = 80; // 16 frames * 5 steps (0.2 speed)
            obj_player.image_index = 0;
            show_debug_message("Wave action triggered");
            global.is_special_actions_open = false;
            global.is_expanded = false;
            instance_destroy();
        }
        // Sit action
        else if (point_in_rectangle(mx, my, inv_x + 145 * ui_scale, inv_y + 37 * ui_scale, inv_x + 162 * ui_scale, inv_y + 54 * ui_scale)) {
        if (instance_exists(global.player_instance)) {
            if (global.player_instance.action_state == "sit") {
                global.player_instance.action_state = "none";
                show_debug_message("Stopped sitting via HUD.");
            } else {
                global.player_instance.action_state = "sit";
                global.player_instance.action_timer = 0;
                global.player_instance.action_duration = -1;
                global.player_instance.image_index = 0;
                show_debug_message("Started sitting via HUD.");
            }
        }
        global.click_handled = true;
    }
        // Dance action
        else if (point_in_rectangle(mx, my, special_x + 1 * ui_scale, special_y + 1 * ui_scale, special_x + 16 * ui_scale, special_y + 24 * ui_scale)) {
            obj_player.action_state = "dance";
            obj_player.action_timer = 0;
            obj_player.action_duration = 224; // 56 frames * 4 steps (0.25 speed)
            obj_player.image_index = 0;
            show_debug_message("Dance action triggered");
            global.is_special_actions_open = false;
            global.is_expanded = false;
            instance_destroy();
        }
    }
}
}

//show_debug_message("obj_hud_expanded is_active = " + string(is_active));
//show_debug_message("obj_hud_expanded exists: " + string(instance_exists(obj_hud_expanded)));
// Keep existing depth setting
depth = -1000;

// Function: Check if player has an item
function has_item(item_name) {
    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index)) return false;
    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == item_index) return true;
    }
    return false;
}

// Function: Add an item to the inventory
function add_to_inventory(item_name) {
    if (has_item(item_name)) {
        show_debug_message("WARNING: " + item_name + " is already in the inventory.");
        return false;
    }

    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index)) {
        show_debug_message("ERROR: Invalid item name - " + string(item_name));
        return false;
    }

    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == -1) { // Empty slot
            inventory[i] = item_index;
            show_debug_message("Added " + item_name + " to inventory in slot " + string(i));
            return true;
        }
    }

    show_debug_message("Inventory full!");
    return false;
}

// Function: Remove an item from the inventory
function remove_item(item_name) {
    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index)) {
        show_debug_message("ERROR: Invalid item name - " + string(item_name));
        return false;
    }

    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == item_index) {
            inventory[i] = -1;
            show_debug_message("Removed " + item_name + " from inventory slot " + string(i));
            return true;
        }
    }

    show_debug_message("ERROR: Item " + item_name + " not found in inventory!");
    return false;
}

// Function: Drop the active item
function drop_active_item() {
    var item_index = inventory[active_slot];
    if (item_index == -1) {
        show_debug_message("No item in active slot to drop.");
        return;
    }

    // Find the item name from the index
    var item_name = "";
    var keys = ds_map_keys_to_array(global.item_index_map);
    for (var i = 0; i < array_length(keys); i++) {
        if (ds_map_find_value(global.item_index_map, keys[i]) == item_index) {
            item_name = keys[i];
            break;
        }
    }

    if (item_name != "") {
        // Get the corresponding object from item_object_map
        var dropped_object = ds_map_find_value(global.item_object_map, item_name);
        if (!is_undefined(dropped_object) && object_exists(dropped_object)) {
            // Create the specific object instance at the player's position
            var dropped_item = instance_create_layer(global.player_instance.x, global.player_instance.y, "Instances", dropped_object);
            show_debug_message("Dropped " + item_name + " as " + object_get_name(dropped_object) + " at (" + string(global.player_instance.x) + ", " + string(global.player_instance.y) + ")");
        } else {
            show_debug_message("ERROR: No valid object mapped for item " + item_name + ". Dropping as generic obj_dropped_item.");
            var dropped_item = instance_create_layer(global.player_instance.x, global.player_instance.y, "Instances", obj_dropped_item);
            dropped_item.item_type = item_name; // Fallback to generic item
        }
    } else {
        show_debug_message("ERROR: Could not find item name for index " + string(item_index));
        return;
    }

    // Remove the item from the inventory
    inventory[active_slot] = -1;
    show_debug_message("Removed " + item_name + " from inventory slot " + string(active_slot));
}


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck
File: Create_0.gml
// Sprite definitions
sprite_base = spr_icetruck_base_empty;
sprite_colour = spr_icetruck_colour;
sprite_window = spr_icetruck_window;
icetruck_tint = c_yellow; // Default tint
mask_index = spr_icetruck_down; // For collision detection

// Existing state variables
repair_required = false;
is_driveable = true;
is_savable = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck
File: Destroy_0.gml
instance_destroy(); // Destroy the current ice truck instance
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck
File: Draw_0.gml
// Define drawing position and frame (static, facing DOWN)
var draw_x = x;
var draw_y = y;
var frame_x = 0; // Assuming DOWN direction
var frame_y = 0;
var frame_width = 48;
var frame_height = 48;

depth = -1000; // Maintain existing depth

// Draw layered sprites
draw_sprite_part(sprite_base, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y);
draw_sprite_part_ext(sprite_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, icetruck_tint, 1);
draw_sprite_part(sprite_window, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y);

// Display interaction prompt when player is close
if (distance_to_object(global.player_instance) < 16 && global.current_skin == "player") {
    var text = "Press 'E' to drive";
    var text_width = string_width(text);
    draw_set_font(fnt_earlygb);
    draw_set_color(c_black);
    draw_text(x + (sprite_width / 2) - (text_width / 2), y - 20, text);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck
File: Step_0.gml
// Ensure the truck is repaired before allowing entry
if (!repair_required) { 
    if (keyboard_check_pressed(ord("E")) && distance_to_object(global.player_instance) < 32) {
        if (global.current_skin == "player") {
            // Enter the ice truck
            var player_x = global.player_instance.x;
            var player_y = global.player_instance.y;

            instance_destroy(global.player_instance); // Remove player
            instance_destroy(id); // Remove icetruck

            global.player_instance = instance_create_layer(player_x, player_y, "Instances", obj_player_icetruck);
            global.current_skin = "icetruck";

            show_debug_message("Entered ice truck. Current skin: " + global.current_skin);
        }
    }
} else {
    show_debug_message("The truck is still broken! Repair it first.");
}

// Ensure correct depth
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Alarm_0.gml
global.repair_cooldown = false;
show_debug_message("Repair cooldown ended. You can now enter the truck.");

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Alarm_1.gml
show_debug_message("DEBUG: Resetting repair flag...");
global.repair_complete = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Create_0.gml
// Sprite definitions
sprite_base = spr_icetruck_base_empty_repairable;
sprite_colour = spr_icetruck_colour;
sprite_window = spr_icetruck_window;
icetruck_tint = c_yellow; // Default tint, consistent with obj_player_icetruck
mask_index = spr_icetruck_facedown; // For collision detection

// Existing state variables
repair_required = true;
repair_complete = false;
global.repair_complete = false;
is_driveable = false;

alarm[1] = 5; // Keep the repair flag active for 5 frames
is_savable = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Destroy_0.gml
instance_destroy(); // Destroy the current ice truck instance
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Draw_0.gml
// Define drawing position and frame (static, facing DOWN)
var draw_x = x;
var draw_y = y;
var frame_x = 0; // Assuming frame 0 is the DOWN direction
var frame_y = 0;
var frame_width = 48; // Match sprite sheet dimensions
var frame_height = 48;

depth = -1000; // Maintain existing depth

// Draw layered sprites
draw_sprite_part(sprite_base, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y);
draw_sprite_part_ext(sprite_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, icetruck_tint, 1);
draw_sprite_part(sprite_window, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y);

// Display repair prompt if player is near
if (distance_to_object(obj_player) < 24) {
    draw_set_font(fnt_earlygb);
    draw_set_color(c_black);
    draw_text(x - 20, y - 20, "Press 'R' to repair");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Step_0.gml
// Ensure player is near and pressing "R" to repair
if (keyboard_check_pressed(ord("R")) && distance_to_object(obj_player) < 16) {
    if (obj_inventory.has_item("Wrench") > 0 || obj_inventory.has_item("Battery") > 0) {
    
        show_debug_message("Repairing ice truck...");
        
        // Destroy the broken truck
        instance_destroy();
        
        // Replace with repaired version
        var new_truck = instance_create_layer(x, y, "Instances", obj_icetruck);
        new_truck.repair_required = false;
		new_truck.repair_complete = true;
		global.repair_complete = true;
		show_debug_message("DEBUG: Setting global.repair_complete = true");
        new_truck.is_driveable = true;

        // Prevent instant entry by disabling key input for a short time
        global.repair_cooldown = true;
        alarm[0] = 30; // 0.5 sec cooldown
        
        show_debug_message("Ice truck repaired! It is now driveable.");
    } else {
        show_debug_message("You need a wrench or a battery to repair this!");
		show_debug_message("Has Wrench: " + string(obj_inventory.has_item("Wrench")));
		show_debug_message("Has Battery: " + string(obj_inventory.has_item("Battery")));
		show_debug_message("Distance to player: " + string(distance_to_object(obj_player)));
		if (keyboard_check_pressed(ord("R"))) {
	    show_debug_message("R key pressed");
	}
    }
}

// Ensure correct depth
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Create_0.gml
// Create Event
scale = 2; // Adjust as needed
panel_width = sprite_get_width(spr_colourpicker_panel) * scale;
panel_height = sprite_get_height(spr_colourpicker_panel) * scale;
x = (display_get_gui_width() - panel_width) / 2;
y = (display_get_gui_height() - panel_height) / 2;
depth = -10000;

// Define colors (unchanged)
var c_notblack = make_color_rgb(51, 59, 70);
var c_bluer = make_color_rgb(41, 82, 172);
var c_brown = make_color_rgb(150, 102, 36);
var c_cyan = make_color_rgb(7, 167, 163);
var c_emerald = make_color_rgb(7, 106, 68);
var c_greener = make_color_rgb(6, 155, 77);
var c_lavender = make_color_rgb(176, 126, 194);
var c_lightblue = make_color_rgb(8, 153, 211);
var c_mint = make_color_rgb(189, 252, 201);
var c_oranger = make_color_rgb(232, 94, 28);
var c_pink = make_color_rgb(234, 20, 160);
var c_purpler = make_color_rgb(102, 49, 158);
var c_reder = make_color_rgb(210, 13, 48);
var c_salmon = make_color_rgb(233, 98, 110);
var c_yellower = make_color_rgb(234, 194, 25);

colors = [
    c_notblack, c_bluer, c_brown, c_cyan, c_emerald,
    c_greener, c_lavender, c_lightblue, c_mint, c_oranger,
    c_pink, c_purpler, c_reder, c_salmon, c_yellower
];

// Grid positioning
var grid_width = (5 * 20 + 4 * 5) * scale;
var grid_height = (3 * 20 + 2 * 5) * scale;
start_x = x + 108 * scale + (135 * scale - grid_width) / 2;
start_y = y + 35 * scale + (115 * scale - grid_height) / 2;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Destroy_0.gml
// Destroy Event for obj_icetruck_colourpicker
show_debug_message("Icetruck colourpicker destroyed.");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Draw_64.gml
// Draw GUI Event
draw_sprite_ext(spr_colourpicker_panel, 0, x, y, scale, scale, 0, c_white, 1);

// Viewer
var viewer_x = x + 9 * scale;
var viewer_y = y + 35 * scale;
var viewer_width = (83 - 9) * scale;
var viewer_height = (150 - 35) * scale;
var scale_preview = min(viewer_width / 48, viewer_height / 48) * scale;
var tint = instance_exists(obj_player_icetruck) ? obj_player_icetruck.icetruck_tint : c_white;
draw_sprite_part_ext(spr_icetruck_base, 0, 48, 48, 48, 48, viewer_x + viewer_width / 2 - 24 * scale_preview, viewer_y + viewer_height / 2 - 24 * scale_preview, scale_preview, scale_preview, c_white, 1);
draw_sprite_part_ext(spr_icetruck_colour, 0, 48, 48, 48, 48, viewer_x + viewer_width / 2 - 24 * scale_preview, viewer_y + viewer_height / 2 - 24 * scale_preview, scale_preview, scale_preview, tint, 1);

// Color previews
var scale_icon = (20 * scale) / 48;
for (var i = 0; i < 15; i++) {
    var col = i mod 5;
    var row = i div 5;
    var icon_x = start_x + col * 25 * scale;
    var icon_y = start_y + row * 25 * scale;
    draw_sprite_part_ext(spr_icetruck_base, 0, 48, 48, 48, 48, icon_x, icon_y, scale_icon, scale_icon, c_white, 1);
    draw_sprite_part_ext(spr_icetruck_colour, 0, 48, 48, 48, 48, icon_x, icon_y, scale_icon, scale_icon, colors[i], 1);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Mouse_4.gml
// Mouse Pressed Event for obj_icetruck_colourpicker
var mx = device_mouse_x_to_gui(0);
var my = device_mouse_y_to_gui(0);

for (var i = 0; i < array_length(colour_slots[i]); i++) {
    var slot_x = x + slot_positions[i][0];
    var slot_y = y + slot_positions[i][1];
    if (point_in_rectangle(mx, my, slot_x, slot_y, slot_x + 17, slot_y + 17)) {
        if (instance_exists(obj_player_icetruck)) {
            obj_player_icetruck.icetruck_tint = color_options[i];
            show_debug_message("Ice truck color changed to: " + string(color_options[i]));
        }
        break;
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Step_0.gml
// Step Event
if (mouse_check_button_pressed(mb_left)) {
    var mx = device_mouse_x_to_gui(0);
    var my = device_mouse_y_to_gui(0);
    
    // Close area
    if (point_in_rectangle(mx, my, x + 98 * scale, y + 1 * scale, x + 156 * scale, y + 11 * scale)) {
        instance_destroy();
        show_debug_message("Icetruck color picker closed.");
        global.ui_manager.close_ui();
        global.click_handled = true;
        return;
    }
    
    // Color selection
    for (var i = 0; i < 15; i++) {
        var col = i mod 5;
        var row = i div 5;
        var icon_x = start_x + col * 25;
        var icon_y = start_y + row * 25;
        if (point_in_rectangle(mx, my, icon_x, icon_y, icon_x + 20, icon_y + 20)) {
            if (instance_exists(obj_player_icetruck)) {
                obj_player_icetruck.icetruck_tint = colors[i];
                show_debug_message("Icetruck tint set to: " + string(colors[i]));
            } else {
                show_debug_message("No icetruck instance found to set tint.");
            }
            instance_destroy();
            global.ui_manager.close_ui();
            global.click_handled = true;
            break;
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_initializer
File: Create_0.gml
/// Create Event for obj_initializer
// Initialize following_puffles
if (!variable_global_exists("following_puffles") || !ds_exists(global.following_puffles, ds_type_list)) {
    global.following_puffles = ds_list_create();
    show_debug_message("DEBUG: global.following_puffles initialized.");
}

// Initialize item_index_map
if (!variable_global_exists("item_index_map") || !ds_exists(global.item_index_map, ds_type_map)) {
    global.item_index_map = ds_map_create();
    var item_names = ["Beta Hat", "Party Hat", "Wrench", "Tube", "Toboggan", "Battery", "Spy Phone", "Broken Spy Phone", "EPF Phone", "Fishing Rod", "Jackhammer", "Snow Shovel", "Pizza Slice", "Puffle O", "Box Puffle O", "Fish", "Mullet", "Wood", "Snow", "Snow Blaster", "Ghost Costume", "Black Sun Glasses", "Black Hoodie", "Miners Hard Hat", "Tour Hat"];
    for (var i = 0; i < array_length(item_names); i++) {
        ds_map_add(global.item_index_map, item_names[i], i);
    }
    show_debug_message("DEBUG: global.item_index_map initialized in obj_initializer.");
} else {
    show_debug_message("DEBUG: global.item_index_map already exists.");
}

// Initialize item_object_map
if (!variable_global_exists("item_object_map") || !ds_exists(global.item_object_map, ds_type_map)) {
    global.item_object_map = ds_map_create();
    ds_map_add(global.item_object_map, "Battery", obj_battery);
    ds_map_add(global.item_object_map, "Box Puffle O", obj_boxpuffleo_item);
    ds_map_add(global.item_object_map, "EPF Phone", obj_epfphone_item);
    ds_map_add(global.item_object_map, "Fishing Rod", obj_fishing_rod);
    ds_map_add(global.item_object_map, "Jackhammer", obj_Jackhammer_item);
    ds_map_add(global.item_object_map, "Map", obj_map_item);
    ds_map_add(global.item_object_map, "Party Hat", obj_party_hat);
    ds_map_add(global.item_object_map, "Beta Hat", obj_beta_hat);
    ds_map_add(global.item_object_map, "Pizza Slice", obj_pizzaslice_item);
    ds_map_add(global.item_object_map, "Puffle O", obj_puffleo_item);
    ds_map_add(global.item_object_map, "Puffle Whistle", obj_pufflewhistle_item);
    ds_map_add(global.item_object_map, "Snow", obj_snow_item);
    ds_map_add(global.item_object_map, "Snow Shovel", obj_snowshovel_item);
    ds_map_add(global.item_object_map, "Snow Blaster", obj_snowblaster_item);
    ds_map_add(global.item_object_map, "Ghost Costume", obj_ghostcostume_item);
    ds_map_add(global.item_object_map, "Black Sun Glasses", obj_blacksunglasses_item);
    ds_map_add(global.item_object_map, "Black Hoodie", obj_blackhoodie_item);
    ds_map_add(global.item_object_map, "Miners Hard Hat", obj_minershardhat_item);
    ds_map_add(global.item_object_map, "Tour Hat", obj_tourhat_item);
    ds_map_add(global.item_object_map, "Broken Spy Phone", obj_broken_spyphone_item); // Fixed typo: "Broken_Spy Phone" to "Broken Spy Phone"
    ds_map_add(global.item_object_map, "Spy Phone", obj_spyphone_item);
    ds_map_add(global.item_object_map, "Stamp Book", obj_stampbook_item);
    ds_map_add(global.item_object_map, "Starter Deck", obj_starterdeck_item);
    ds_map_add(global.item_object_map, "Wood", obj_wood_item);
    ds_map_add(global.item_object_map, "Wrench", obj_wrench_item);
    ds_map_add(global.item_object_map, "Tube", obj_tube);
    ds_map_add(global.item_object_map, "Toboggan", obj_toboggan);
    show_debug_message("DEBUG: global.item_object_map initialized in obj_initializer.");
} else {
    show_debug_message("DEBUG: global.item_object_map already exists.");
}

// Initialize inventory_expanded
if (!variable_global_exists("inventory_expanded")) {
    global.inventory_expanded = false;
    show_debug_message("DEBUG: global.inventory_expanded initialized.");
}

// Ensure obj_inventory and obj_map_icon exist
if (!instance_exists(obj_inventory)) {
    instance_create_layer(0, 0, "Instances", obj_inventory);
    show_debug_message("DEBUG: obj_inventory created.");
}
if (!instance_exists(obj_map_icon)) {
    instance_create_layer(0, 0, "Instances", obj_map_icon);
    show_debug_message("DEBUG: obj_map_icon created.");
}

// Initialize game_paused
if (!variable_global_exists("game_paused")) {
    global.game_paused = false;
    show_debug_message("DEBUG: global.game_paused initialized.");
}

// Initialize equipped_items (Initialization Check Step)
if (!variable_global_exists("equipped_items") || !ds_exists(global.equipped_items, ds_type_map)) {
    global.equipped_items = ds_map_create();
    ds_map_add(global.equipped_items, "head", -1);
    ds_map_add(global.equipped_items, "face", -1);
    ds_map_add(global.equipped_items, "neck", -1);
    ds_map_add(global.equipped_items, "body", -1);
    ds_map_add(global.equipped_items, "hand", -1);
    ds_map_add(global.equipped_items, "feet", -1);
    show_debug_message("DEBUG: global.equipped_items initialized with slots set to -1.");
} else {
    show_debug_message("DEBUG: global.equipped_items already exists.");
}

// Initialize item_player_sprites
if (!variable_global_exists("item_player_sprites") || !ds_exists(global.item_player_sprites, ds_type_map)) {
    global.item_player_sprites = ds_map_create();
    ds_map_add(global.item_player_sprites, 0, spr_player_betahat); // Beta Hat
    ds_map_add(global.item_player_sprites, 1, spr_player_partyhat); // Party Hat
    ds_map_add(global.item_player_sprites, ds_map_find_value(global.item_index_map, "Jackhammer"), spr_jackhammer_object);
    ds_map_add(global.item_player_sprites, ds_map_find_value(global.item_index_map, "Snow Shovel"), spr_snowshovel_object);
    show_debug_message("DEBUG: global.item_player_sprites initialized.");
}

// Initialize item_type_map
if (!variable_global_exists("item_type_map") || !ds_exists(global.item_type_map, ds_type_map)) {
    global.item_type_map = ds_map_create();
    ds_map_add(global.item_type_map, 0, "head");   // Beta Hat
    ds_map_add(global.item_type_map, 1, "head");   // Party Hat
    ds_map_add(global.item_type_map, 20, "body");  // Ghost Costume
    ds_map_add(global.item_type_map, 21, "face");  // Black Sun Glasses
    ds_map_add(global.item_type_map, 22, "body");  // Black Hoodie
    ds_map_add(global.item_type_map, 23, "head");  // Miners Hard Hat
    ds_map_add(global.item_type_map, 24, "head");  // Tour Hat
    show_debug_message("DEBUG: global.item_type_map initialized.");
}

// Ensure party_hat_visible and beta_hat_visible are set
if (!variable_global_exists("party_hat_visible")) {
    global.party_hat_visible = false;
    show_debug_message("DEBUG: global.party_hat_visible initialized.");
}
if (!variable_global_exists("beta_hat_visible")) {
    global.beta_hat_visible = false;
    show_debug_message("DEBUG: global.beta_hat_visible initialized.");
}

// Initialize the global camera
if (!variable_global_exists("camera") || !is_real(global.camera)) {
    global.camera = camera_create();
    camera_set_view_size(global.camera, view_wview[0], view_hview[0]);
    camera_set_view_pos(global.camera, 0, 0);
    show_debug_message("DEBUG: New camera created.");
}
view_set_camera(0, global.camera);

// Ensure global player instance is correctly set
if (!variable_global_exists("player_instance") || global.player_instance == noone) {
    if (instance_exists(obj_player)) {
        global.player_instance = obj_player;
    } else if (instance_exists(obj_sled_player)) {
        global.player_instance = obj_sled_player;
    } else if (instance_exists(obj_player_icetruck)) {
        global.player_instance = obj_player_icetruck;
    } else if (instance_exists(obj_player_tube)) {
        global.player_instance = obj_player_tube;
    } else if (instance_exists(obj_player_toboggan)) {
        global.player_instance = obj_player_toboggan;
    }
    show_debug_message("DEBUG: global.player_instance set to: " + string(global.player_instance));
}

// Initialize icetruck colour picker
if (!variable_global_exists("colour_picker_active")) {
    global.colour_picker_active = false;
    show_debug_message("DEBUG: global.colour_picker_active initialized.");
}

show_debug_message("DEBUG: obj_initializer Create Event executed.");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_initializer
File: Other_2.gml
// Initialize all required global variables
global.player_instance = noone;
global.player_instance_initialized = false;
global.camera = noone;
global.current_skin = "player"; // Default skin
global.initialized = false; // To track overall initialization

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_initializer
File: Step_0.gml
// Step Event for obj_initializer

// Ensure the camera is correctly set to follow the player
var cam = camera_create();
camera_set_view_target(cam, global.player_instance);
camera_apply(cam);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory
File: Create_0.gml
// obj_inventory: Create Event
inventory_size = 42;
inventory = array_create(inventory_size, -1);
active_slot = 0;
global.active_item_index = active_slot;
persistent = true;
global.is_expanded = false;
global.is_special_actions_open = false;

// Function to get item type based on name
get_item_type = function(item_name) {
    var item_index = ds_map_find_value(global.item_index_map, item_name);
    show_debug_message("get_item_type: Item '" + item_name + "' has index: " + (is_undefined(item_index) ? "undefined" : string(item_index)));
    if (!is_undefined(item_index)) {
        var item_type = ds_map_find_value(global.item_type_map, item_index);
        show_debug_message("get_item_type: Index " + string(item_index) + " has type: " + (is_undefined(item_type) ? "undefined" : item_type));
        return item_type;
    }
    return -1;
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory
File: Draw_64.gml
// In obj_inventory Draw GUI Event
if (instance_exists(id)) {
    if (visible) {
        var ui_scale = 3;
        var gui_width = display_get_gui_width();
        var gui_height = display_get_gui_height();
        var inv_width = sprite_get_width(spr_inventory_ui) * ui_scale;
        var inv_height = sprite_get_height(spr_inventory_ui) * ui_scale;
        var inv_x = (gui_width - inv_width) / 2;
        var inv_y = gui_height - inv_height + 0 * ui_scale;

        if (!global.is_expanded) {
            draw_sprite_ext(spr_inventory_ui, 0, inv_x, inv_y, ui_scale, ui_scale, 0, c_white, 1);

            // Update slot positions
            var slot_positions = [
                [inv_x + 5 * ui_scale, inv_y + 14 * ui_scale],
                [inv_x + 25 * ui_scale, inv_y + 14 * ui_scale],
                [inv_x + 45 * ui_scale, inv_y + 14 * ui_scale],
                [inv_x + 65 * ui_scale, inv_y + 14 * ui_scale],
                [inv_x + 85 * ui_scale, inv_y + 14 * ui_scale],
                [inv_x + 105 * ui_scale, inv_y + 14 * ui_scale],
                [inv_x + 125 * ui_scale, inv_y + 14 * ui_scale],
                [inv_x + 145 * ui_scale, inv_y + 14 * ui_scale]
            ];

            // Draw inventory items
            for (var i = 0; i < 8; i++) {
                if (!is_undefined(inventory[i]) && inventory[i] != -1) { // Skip empty slots
                    var slot_x = slot_positions[i][0];
                    var slot_y = slot_positions[i][1];
                    var item_index = inventory[i];
                    var x_offset, y_offset;
                    if (item_index < 21) { // First row: items 0â€“20
                        x_offset = item_index * 18;
                        y_offset = 0;
                    } else { // Second row: items 21â€“24
                        x_offset = (item_index - 21) * 18;
                        y_offset = 18;
                    }
                    draw_sprite_part_ext(spr_inventory_items, 0, x_offset, y_offset, 18, 18, slot_x, slot_y, ui_scale, ui_scale, c_white, 1);
                    if (i == active_slot) {
                        draw_sprite_ext(spr_inventory_highlight, 0, slot_x - 1 * ui_scale, slot_y - 1 * ui_scale, ui_scale, ui_scale, 0, c_white, 1);
                    }
                }
            }
        }

        // Click detection to open expanded HUD
        if (mouse_check_button_pressed(mb_left) && !instance_exists(obj_hud_expanded)) {
            var click_area_left = inv_x + 54 * ui_scale;
            var click_area_top = inv_y + 2 * ui_scale;
            var click_area_right = inv_x + 112 * ui_scale;
            var click_area_bottom = inv_y + 9 * ui_scale;
            var gui_mouse_x = device_mouse_x_to_gui(0);
            var gui_mouse_y = device_mouse_y_to_gui(0);
            if (gui_mouse_x >= click_area_left && gui_mouse_x <= click_area_right &&
                gui_mouse_y >= click_area_top && gui_mouse_y <= click_area_bottom) {
                global.is_expanded = true;
                instance_create_layer(0, 0, "Instances", obj_hud_expanded);
                show_debug_message("Expanded HUD opened - global.is_expanded set to true");
            }
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory
File: Mouse_4.gml
/// Mouse Left Pressed Event for obj_inventory
var item_index = inventory_get_item_index_at_mouse();
if (item_index != -1) {
    show_debug_message("Mouse clicked on inventory item at index: " + string(item_index));
    inventory_click_handler(item_index);
} else {
    show_debug_message("No item found at clicked inventory slot.");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory
File: Step_0.gml
// obj_inventory: Step Event
if (global.chat_active) exit;

// Existing logic (scroll, drop, Tube, Toboggan)
if (mouse_wheel_up()) {
    active_slot = min(active_slot + 1, 7);
    global.active_item_index = inventory[active_slot];
}
if (mouse_wheel_down()) {
    active_slot = max(active_slot - 1, 0);
    global.active_item_index = inventory[active_slot];
}
if (keyboard_check_pressed(ord("F"))) {
    drop_active_item();
}

// Remove the used item from inventory
if (keyboard_check_pressed(ord("R")) && global.repair_complete) { 
    show_debug_message("DEBUG: Repair complete flag detected in inventory."); 
    if (has_item("Battery")) {
        show_debug_message("DEBUG: Battery detected in inventory. Attempting to remove...");
        remove_item("Battery");
        show_debug_message("Battery removed after repair.");
    } else {
        show_debug_message("ERROR: Neither Battery nor Wrench found in inventory!");
    }
}

// Auto-remove Tube when switching to obj_player_tube
if (keyboard_check_pressed(ord("T")) && global.current_skin == "tube") {
    show_debug_message("Switching from tube to player");
    obj_controller.switch_skin("player");
    if (!has_item("Tube")) {
        add_to_inventory("Tube");
    }
    show_debug_message("Exited tube. Switched back to player. Tube added back to inventory.");
} else if (keyboard_check_pressed(ord("T")) && global.current_skin == "player" && has_item("Tube")) {
    show_debug_message("Switching from player to tube");
    obj_controller.switch_skin("tube");
    if (has_item("Tube")) {
        show_debug_message("Removing Tube from inventory...");
        remove_item("Tube");
    } else {
        show_debug_message("ERROR: Tube not found in inventory!");
    }
}

// Auto-remove Toboggan when switching to obj_player_toboggan
if (keyboard_check_pressed(ord("T")) && global.current_skin == "toboggan") {
    show_debug_message("Switching from toboggan to player");
    obj_controller.switch_skin("player");
    if (!has_item("Toboggan")) {
        add_to_inventory("Toboggan");
    }
    show_debug_message("Exited toboggan. Switched back to player. Toboggan added back to inventory.");
} else if (keyboard_check_pressed(ord("T")) && global.current_skin == "player" && has_item("Toboggan")) {
    show_debug_message("Switching from player to toboggan");
    obj_controller.switch_skin("toboggan");
    if (has_item("Toboggan")) {
        show_debug_message("Removing Toboggan from inventory...");
        remove_item("Toboggan");
    } else {
        show_debug_message("ERROR: Toboggan not found in inventory!");
    }
}

// Depth setting for UI layering
depth = -1000;

// Function: Check if player has an item
function has_item(item_name) {
    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index)) return false;
    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == item_index) return true;
    }
    return false;
}

// Function: Add an item to the inventory
function add_to_inventory(item_name) {
    if (has_item(item_name)) {
        show_debug_message("WARNING: " + item_name + " is already in the inventory.");
        return false;
    }

    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index)) {
        show_debug_message("ERROR: Invalid item name - " + string(item_name));
        return false;
    }

    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == -1) { // Empty slot
            inventory[i] = item_index;
            show_debug_message("Added " + item_name + " to inventory in slot " + string(i));
            return true;
        }
    }
    
    // Notify quest system
    for (var i = 0; i < ds_list_size(global.active_quests); i++) {
        var quest_id = ds_list_find_value(global.active_quests, i);
        var quest = ds_map_find_value(global.quest_definitions, quest_id);
        var objectives = quest[?"objectives"];
        for (var j = 0; j < array_length(objectives); j++) {
            if (objectives[j].type == "collect" && objectives[j].item == item_name) {
                // Progress updated when completing the quest
            }
        }
    }

    show_debug_message("Inventory full!");
    return false;
}

// Function: Remove an item from the inventory
function remove_item(item_name) {
    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index)) {
        show_debug_message("ERROR: Invalid item name - " + string(item_name));
        return false;
    }

    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == item_index) {
            inventory[i] = -1;
            show_debug_message("Removed " + item_name + " from inventory slot " + string(i));
            return true;
        }
    }

    show_debug_message("ERROR: Item " + item_name + " not found in inventory!");
    return false;
}

// Function: Drop the active item
function drop_active_item() {
    var item_index = inventory[active_slot];
    if (item_index == -1) {
        show_debug_message("No item in active slot to drop.");
        return;
    }

    // Find the item name from the index
    var item_name = "";
    var keys = ds_map_keys_to_array(global.item_index_map);
    for (var i = 0; i < array_length(keys); i++) {
        if (ds_map_find_value(global.item_index_map, keys[i]) == item_index) {
            item_name = keys[i];
            break;
        }
    }

    if (item_name != "") {
        // Get the corresponding object from item_object_map
        var dropped_object = ds_map_find_value(global.item_object_map, item_name);
        if (!is_undefined(dropped_object) && object_exists(dropped_object)) {
            // Create the specific object instance at the player's position
            var dropped_item = instance_create_layer(global.player_instance.x, global.player_instance.y, "Instances", dropped_object);
            show_debug_message("Dropped " + item_name + " as " + object_get_name(dropped_object) + " at (" + string(global.player_instance.x) + ", " + string(global.player_instance.y) + ")");
        } else {
            show_debug_message("ERROR: No valid object mapped for item " + item_name + ". Dropping as generic obj_dropped_item.");
            var dropped_item = instance_create_layer(global.player_instance.x, global.player_instance.y, "Instances", obj_dropped_item);
            dropped_item.item_type = item_name; // Fallback to generic item
        }
    } else {
        show_debug_message("ERROR: Could not find item name for index " + string(item_index));
        return;
    }

    // Remove the item from the inventory
    inventory[active_slot] = -1;
    show_debug_message("Removed " + item_name + " from inventory slot " + string(active_slot));
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Create_0.gml
// obj_inventory_expanded: Create Event
global.game_paused = true;
depth = -10000;

// Default inventory states
global.inventory_open_state = "closed"; // Inventory starts in the closed state
global.inventory_visible = true; // Both sprites are visible by default

// Character variables
character_face = DOWN; // Default direction
character_action = "none"; // Default no action
character_image_index = 0; // Default animation frame

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Destroy_0.gml
// obj_inventory_expanded: Destroy Event
global.game_paused = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Draw_64.gml
// obj_inventory_expanded Draw GUI
var ui_scale = 2.2;

// GUI dimensions
var gui_width = display_get_gui_width();
var gui_height = display_get_gui_height();

// Closed inventory positioning
var closed_width = sprite_get_width(spr_inventory_closed) * ui_scale;
var closed_height = sprite_get_height(spr_inventory_closed) * ui_scale;
var closed_x = (gui_width / 2) - closed_width - 0;
var closed_y = (gui_height - closed_height) / 2;

// Open inventory positioning
var open_width = sprite_get_width(spr_inventory_open) * ui_scale;
var open_height = sprite_get_height(spr_inventory_open) * ui_scale;
var open_x = closed_x + closed_width - 35;
var open_y = (gui_height - open_height) / 2;

// Draw sprites based on inventory state
if (global.inventory_visible) {
    draw_sprite_ext(spr_inventory_closed, 0, closed_x, closed_y, ui_scale, ui_scale, 0, c_white, 1);
    
    // Draw equipped items in clothing slots
    var clothing_slots = [[9, 20], [9, 40], [9, 60], [9, 80], [9, 100], [9, 120]];
    var slots = ["head", "face", "neck", "body", "hand", "feet"];
    for (var i = 0; i < array_length(slots); i++) {
        var slot_x = closed_x + clothing_slots[i][0] * ui_scale;
        var slot_y = closed_y + clothing_slots[i][1] * ui_scale;
        var item_name = global.equipped_items[? slots[i]];
        if (!is_undefined(item_name) && item_name != -1) {
            var item_index = ds_map_find_value(global.item_index_map, item_name);
            if (!is_undefined(item_index)) {
                var x_offset = (item_index < 21) ? item_index * 18 : (item_index - 21) * 18;
                var y_offset = (item_index < 21) ? 0 : 18;
                draw_sprite_part_ext(spr_inventory_items, 0, x_offset, y_offset, 18, 18, slot_x, slot_y, ui_scale, ui_scale, c_white, 1);
            } else {
                show_debug_message("No item index found for equipped item: " + string(item_name) + " in slot: " + slots[i]);
            }
        } else {
            show_debug_message("No item equipped or undefined in slot: " + slots[i]);
        }
    }
    
    // Character viewer positioning (based on exact coordinates: 31,21 to 105,135)
    var viewer_left = closed_x + 31 * ui_scale;
    var viewer_top = closed_y + 21 * ui_scale;
    var viewer_width = (105 - 31) * ui_scale; // 74 * ui_scale
    var viewer_height = (135 - 21) * ui_scale; // 114 * ui_scale

    // Center the player sprite within the viewer area
    var char_scale = 7; // Scale for visibility
    var scaled_width = 24 * char_scale; // Assuming player sprite is 24x24
    var scaled_height = 24 * char_scale;
    var draw_x = viewer_left + (viewer_width - scaled_width) / 2;
    var draw_y = viewer_top + (viewer_height - scaled_height) / 2;

    // Default frame settings
    var frame_x = 0; // DOWN direction
    var frame_width = 24;
    var frame_height = 24;

    switch (global.current_skin) {
        case "player":
            // Draw walking pose for regular player
            var frame_y = 0; // Walking pose from spr_player_body
            draw_sprite_part_ext(spr_player_body, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, c_white, 1);
            draw_sprite_part_ext(spr_player_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, global.player_color, 1);
            break;
    
        case "tube":
            // Draw sitting pose for tube
            var frame_y = 72; // Sitting pose from spr_player_body
            draw_sprite_part_ext(spr_tube_sheet, 0, 24, 0, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, c_white, 1);
            draw_sprite_part_ext(spr_player_body, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, c_white, 1);
            draw_sprite_part_ext(spr_player_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, global.player_color, 1);
            break;
            
        case "toboggan":
            // Draw sitting pose for toboggan
            var frame_y = 72; // Sitting pose from spr_player_body
            draw_sprite_part_ext(spr_toboggan_sheet, 0, 24, 0, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, c_white, 1);
            draw_sprite_part_ext(spr_player_body, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, c_white, 1);
            draw_sprite_part_ext(spr_player_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, global.player_color, 1);
            break;    
        
        case "icetruck":
            // Draw icetruck with penguin inside (simplified preview)
            frame_width = 48; // Icetruck sprite size
            frame_height = 48;
            var frame_y = 0; // DOWN direction frame
            draw_sprite_part_ext(spr_icetruck_base, 0, frame_x, frame_y, frame_width, frame_height, draw_x - 40, draw_y - 25, char_scale - 2, char_scale - 2, c_white, 1);
            draw_sprite_part_ext(spr_icetruck_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x - 40, draw_y - 25, char_scale - 2, char_scale - 2, obj_player_icetruck.icetruck_tint, 1);
            draw_sprite_part_ext(spr_icetruck_penguin_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x - 40, draw_y - 20, char_scale - 2, char_scale - 2, global.player_color, 1);
            draw_sprite_part_ext(spr_icetruck_window, 0, frame_x, frame_y, frame_width, frame_height, draw_x - 40, draw_y - 25, char_scale - 2, char_scale - 2, c_white, 1);
            break;
    }
    
    // Draw equipped items in clothing slots
    var clothing_slots = [[9, 20], [9, 40], [9, 60], [9, 80], [9, 100], [9, 120]];
    var slots = ["head", "face", "neck", "body", "hand", "feet"];
    for (var i = 0; i < array_length(slots); i++) {
        var slot_x = closed_x + clothing_slots[i][0] * ui_scale;
        var slot_y = closed_y + clothing_slots[i][1] * ui_scale;
        var item_name = global.equipped_items[? slots[i]];
        if (!is_undefined(item_name) && item_name != -1) {
            var item_index = ds_map_find_value(global.item_index_map, item_name);
            if (!is_undefined(item_index)) {
                var x_offset = (item_index < 21) ? item_index * 18 : (item_index - 21) * 18;
                var y_offset = (item_index < 21) ? 0 : 18;
                draw_sprite_part_ext(spr_inventory_items, 0, x_offset, y_offset, 18, 18, slot_x, slot_y, ui_scale, ui_scale, c_white, 1);
            } else {
                show_debug_message("No item index found for equipped item: " + string(item_name) + " in slot: " + slots[i]);
            }
        } else {
            show_debug_message("No item equipped or undefined in slot: " + slots[i]);
        }
    }

    if (global.inventory_open_state == "open") {
        draw_sprite_ext(spr_inventory_open, 0, open_x, open_y, ui_scale, ui_scale, 0, c_white, 1);
        
        // Draw inventory grid
        var grid_start = [3, 6];
        var grid_size = [7, 6];
        for (var row = 0; row < grid_size[1]; row++) {
            for (var col = 0; col < grid_size[0]; col++) {
                var slot_index = row * grid_size[0] + col;
                if (slot_index < 42 && obj_inventory.inventory[slot_index] != -1) {
                    var item_index = obj_inventory.inventory[slot_index];
                    var x_offset = (item_index < 21) ? item_index * 18 : (item_index - 21) * 18;
                    var y_offset = (item_index < 21) ? 0 : 18;
                    draw_sprite_part_ext(
                        spr_inventory_items, 0, x_offset, y_offset, 18, 18,
                        open_x + (grid_start[0] + col * 20) * ui_scale,
                        open_y + (grid_start[1] + row * 20) * ui_scale,
                        ui_scale, ui_scale, c_white, 1
                    );
                }
            }
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Mouse_4.gml
/// Mouse Left Pressed Event for obj_inventory_expanded
var item_index = inventory_get_item_index_at_mouse();
if (item_index != -1) {
    show_debug_message("Mouse clicked on expanded inventory item at index: " + string(item_index));
    inventory_click_handler(item_index);
} else {
    show_debug_message("No item found at clicked expanded inventory slot.");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Step_0.gml
// obj_inventory_expanded: Step Event
var ui_scale = 2.2;
var gui_mouse_x = device_mouse_x_to_gui(0);
var gui_mouse_y = device_mouse_y_to_gui(0);

// Closed inventory positioning
var closed_width = sprite_get_width(spr_inventory_closed) * ui_scale;
var closed_height = sprite_get_height(spr_inventory_closed) * ui_scale;
var closed_x = (display_get_gui_width() / 2) - closed_width - 0;
var closed_y = (display_get_gui_height() - closed_height) / 2;

// Open inventory positioning
var open_width = sprite_get_width(spr_inventory_open) * ui_scale;
var open_height = sprite_get_height(spr_inventory_open) * ui_scale;
var open_x = closed_x + closed_width - 35;
var open_y = closed_y;

if (global.inventory_visible) {
    if (global.inventory_open_state == "closed") {
        // Define "Open Expanded Inventory" button area
        var open_left = closed_x + 117 * ui_scale;
        var open_top = closed_y + 61 * ui_scale;
        var open_right = closed_x + 125 * ui_scale;
        var open_bottom = closed_y + 93 * ui_scale;

        if (mouse_check_button_pressed(mb_left) &&
            gui_mouse_x >= open_left && gui_mouse_x <= open_right &&
            gui_mouse_y >= open_top && gui_mouse_y <= open_bottom) {
            show_debug_message("DEBUG: Opening expanded inventory.");
            global.inventory_open_state = "open";
        }
    } else if (global.inventory_open_state == "open") {
        // Define "Close Expanded Inventory" button area
        var close_left = open_x + 144 * ui_scale;
        var close_top = open_y + 47 * ui_scale;
        var close_right = open_x + 152 * ui_scale;
        var close_bottom = open_y + 79 * ui_scale;

        if (mouse_check_button_pressed(mb_left) &&
            gui_mouse_x >= close_left && gui_mouse_x <= close_right &&
            gui_mouse_y >= close_top && gui_mouse_y <= close_bottom) {
            show_debug_message("DEBUG: Closing expanded inventory.");
            global.inventory_open_state = "closed";
        }
    }

    // Define "Close All Expanded Inventory" button
    var close_all_left = closed_x + 47 * ui_scale;
    var close_all_top = closed_y + 3 * ui_scale;
    var close_all_right = closed_x + 89 * ui_scale;
    var close_all_bottom = closed_y + 11 * ui_scale;

    if (mouse_check_button_pressed(mb_left) &&
        gui_mouse_x >= close_all_left && gui_mouse_x <= close_all_right &&
        gui_mouse_y >= close_all_top && gui_mouse_y <= close_all_bottom) {
        show_debug_message("DEBUG: Closing all inventory.");
        global.inventory_visible = false;
        global.inventory_open_state = "closed";
        global.game_paused = false; // Unpause the game
        instance_destroy();
        exit;
    }

    // Equip item by clicking on inventory slot
    if (global.inventory_open_state == "open") {
    if (mouse_check_button_pressed(mb_left)) {
            show_debug_message("Mouse clicked at (" + string(gui_mouse_x) + ", " + string(gui_mouse_y) + ")");
            var grid_start = [3, 6];
            var grid_size = [7, 6];
            for (var row = 0; row < grid_size[1]; row++) {
                for (var col = 0; col < grid_size[0]; col++) {
                    var slot_x = open_x + (grid_start[0] + col * 20) * ui_scale;
                    var slot_y = open_y + (grid_start[1] + row * 20) * ui_scale;
                    var slot_width = 18 * ui_scale;
                    var slot_height = 18 * ui_scale;
                    if (gui_mouse_x >= slot_x && gui_mouse_x < slot_x + slot_width &&
                        gui_mouse_y >= slot_y && gui_mouse_y < slot_y + slot_height) {
                        show_debug_message("Clicked slot (" + string(col) + ", " + string(row) + ") at (" + string(slot_x) + ", " + string(slot_y) + ")");
                        var slot_index = row * grid_size[0] + col;
                        if (slot_index < 42) {
                            var item_index = obj_inventory.inventory[slot_index];
                            show_debug_message("Slot " + string(slot_index) + " contains item index: " + string(item_index));
                            if (item_index != -1) {
                                var item_name = "";
                                var keys = ds_map_keys_to_array(global.item_index_map);
                                for (var k = 0; k < array_length(keys); k++) {
                                    if (ds_map_find_value(global.item_index_map, keys[k]) == item_index) {
                                        item_name = keys[k];
                                        break;
                                    }
                                }
                                if (item_name != "") {
                                    show_debug_message("Item name found: " + item_name);
                                    var item_type = ds_map_find_value(global.item_type_map, item_index);
                                    show_debug_message("Item type: " + string(item_type));
                                    if (!is_undefined(item_type) && ds_map_exists(global.equipped_items, item_type)) {
                                        show_debug_message("Equipping " + item_name + " to " + item_type);
                                        var current_equipped = global.equipped_items[? item_type];
                                        if (current_equipped != -1) {
                                            var empty_slot = array_find_index(obj_inventory.inventory, function(val) { return val == -1; });
                                            if (empty_slot != -1) {
                                                obj_inventory.inventory[empty_slot] = ds_map_find_value(global.item_index_map, current_equipped);
                                            } else {
                                                show_debug_message("Inventory full, cannot unequip current item.");
                                                exit;
                                            }
                                        }
                                        global.equipped_items[? item_type] = item_name;
                                        obj_inventory.inventory[slot_index] = -1;
                                        show_debug_message("Equipped " + item_name + " as " + item_type);
                                    } else {
                                        show_debug_message("Cannot equip: type undefined or slot missing: " + string(item_type));
                                    }
                                } else {
                                    show_debug_message("No item name found for index: " + string(item_index));
                                }
                            } else {
                                show_debug_message("No item in slot " + string(slot_index));
                            }
                        }
                    }
                }
            }
        }
    }

    // Unequip item by clicking on equipped slot
    if (global.inventory_visible) {
        var clothing_slots = [
            [9, 20], [9, 40], [9, 60], [9, 80], [9, 100], [9, 120]
        ];
        var slots = ["head", "face", "neck", "body", "hand", "feet"];
        for (var i = 0; i < array_length(slots); i++) {
            var slot_x = closed_x + clothing_slots[i][0] * ui_scale;
            var slot_y = closed_y + clothing_slots[i][1] * ui_scale;
            var slot_width = 18 * ui_scale;
            var slot_height = 18 * ui_scale;
            if (mouse_check_button_pressed(mb_left) &&
                gui_mouse_x >= slot_x && gui_mouse_x < slot_x + slot_width &&
                gui_mouse_y >= slot_y && gui_mouse_y < slot_y + slot_height) {
                var item_name = global.equipped_items[? slots[i]];
                if (item_name != -1) {
                    var item_index = ds_map_find_value(global.item_index_map, item_name);
                    if (!is_undefined(item_index)) {
                        var empty_slot = array_find_index(obj_inventory.inventory, function(val) { return val == -1; });
                        if (empty_slot != -1) {
                            obj_inventory.inventory[empty_slot] = item_index;
                            global.equipped_items[? slots[i]] = -1;
                            show_debug_message("Unequipped " + slots[i] + " item: " + item_name);
                        } else {
                            show_debug_message("Inventory full, cannot unequip item.");
                        }
                    }
                }
            }
        }
    }
}

// Close inventory with "I" key
if (keyboard_check_pressed(ord("I"))) {
    show_debug_message("DEBUG: Closing inventory with 'I'.");
    global.game_paused = false;
    instance_destroy();
}

// Special actions and animation logic (unchanged)
if (keyboard_check_pressed(ord("H"))) {
    character_action = "dance";
    character_image_index = 0;
} else if (keyboard_check_pressed(ord("J"))) {
    character_action = "wave";
    character_image_index = 0;
} else if (keyboard_check_pressed(ord("K"))) {
    character_action = "none";
    character_image_index = 0;
} else if (keyboard_check_pressed(ord("B")) && obj_inventory.has_item("Jackhammer")) {
    character_action = "jackhammer";
    character_image_index = 0;
} else if (keyboard_check_pressed(ord("N")) && obj_inventory.has_item("Snow Shovel")) {
    character_action = "snowshovel";
    character_image_index = 0;
}

// Animate the character
if (character_action != "none") {
    var anim_speed = ds_map_find_value(global.player_instance.action_anim_speed, character_action);
    character_image_index += anim_speed;
    var frames = ds_map_find_value(global.player_instance.action_frame_data, character_action);
    if (character_image_index >= array_length(frames)) character_image_index = 0;
} else {
    character_image_index += 0.15; // Idle animation speed
    if (character_image_index >= 3) character_image_index = 0;
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_Jackhammer_item
File: Create_0.gml
event_inherited();
item_name = "Jackhammer";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_lamp
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_long_bush
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_lrg_boat
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_menu
File: Create_0.gml
if (!instance_exists(obj_new_game_button)) {
    instance_create_layer(room_width / 2, room_height / 2, "Instances", obj_new_game_button);
}
if (!instance_exists(obj_continue_button) && file_exists("savegame.sav")) {
    instance_create_layer(room_width / 2, room_height / 2 + 40, "Instances", obj_continue_button);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_menu
File: Step_0.gml
if (room == rm_main_menu) {
    if (!instance_exists(obj_new_game_button)) {
        instance_create_layer(room_width / 2, room_height / 2, "Instances", obj_new_game_button);
    }
    if (!instance_exists(obj_continue_button)) {
        if (file_exists("savegame.sav")) {
            instance_create_layer(room_width / 2, room_height / 2 + 40, "Instances", obj_continue_button);
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_settings
File: Create_0.gml
// obj_pause_menu create event
depth = -99990; // Ensure it's drawn above all other objects

// Disable player controls
global.player_controls_enabled = false;

width = display_get_width();
height = display_get_height();
op_border = 8;
op_space = 16;
pos = 0;

// Settings menu options
option[0, 0] = "Window Size";
option[0, 1] = "Brightness";
option[0, 2] = "Controls";
option[0, 3] = "Back";

menu_level = 0;
// Ensure menu_level is valid
if (menu_level < 0 || menu_level >= array_length(option)) {
    show_debug_message("ERROR: Invalid initial menu_level " + string(menu_level));
    menu_level = 0; // Reset to default
}
op_length = array_length(option[menu_level]); // Dynamically set op_length

// Pause the game
game_paused = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_settings
File: Draw_0.gml
draw_set_font(fnt_bumbastika_sml);

// Ensure menu_level is valid
if (menu_level < 0 || menu_level >= array_length(option)) {
    show_debug_message("ERROR: Invalid menu_level " + string(menu_level));
    return; // Exit the Draw Event
}

// Dynamically get width and height of menu
var _new_w = 0;
for (var i = 0; i < op_length; i++) {
    if (i < array_length(option[menu_level])) { // Check that index is within bounds
        var _op_w = string_width(option[menu_level][i]);
        _new_w = max(_new_w, _op_w);
    }
}
width = _new_w + op_border * 2;
height = op_border * 4.5 + string_height(option[menu_level][0]) * op_length;

// Center menu
x = camera_get_view_x(view_camera[0]) + (camera_get_view_width(view_camera[0]) - width) / 2;
y = camera_get_view_y(view_camera[0]) + (camera_get_view_height(view_camera[0]) - height) / 2;

// Draw the menu background
draw_sprite_ext(
    spr_pause_menu, 
    0, 
    x, 
    y, 
    width / sprite_get_width(spr_pause_menu), 
    height / sprite_get_height(spr_pause_menu), 
    0, 
    c_white, 
    1
);

// Draw the options
draw_set_valign(fa_top);
draw_set_halign(fa_center);
for (var i = 0; i < op_length; i++) {
    if (i < array_length(option[menu_level])) { // Check bounds again
        var _c = c_white;
        if (pos == i) { 
            _c = c_yellow; // Highlight the option being hovered over
        }
        draw_text_color(
            x + width / 2, 
            y + op_border + op_space * i, 
            option[menu_level][i], // Access using nested arrays
            _c, 
            _c, 
            _c, 
            _c, 
            1
        );
    } else {
        show_debug_message("ERROR: Invalid option index " + string(i) + " for menu_level " + string(menu_level));
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_settings
File: Step_0.gml
// Update op_length dynamically based on menu_level
op_length = array_length(option[menu_level]);

// Menu navigation using the mouse
var mouse_x_pos = device_mouse_x(0); // Get mouse x-coordinate
var mouse_y_pos = device_mouse_y(0); // Get mouse y-coordinate

var menu_width = 300; // Width of the menu
var menu_height = 40 * op_length + 20; // Height of the menu
var menu_top = y - menu_height / 2 + 20; // Top of the menu options
var menu_left = x - menu_width / 2; // Left of the menu

if (mouse_x_pos > menu_left && mouse_x_pos < menu_left + menu_width) {
    pos = floor((mouse_y_pos - menu_top) / 40); // Calculate option index
} else {
    pos = -1; // Mouse is not over the menu
}

// Ensure pos stays within bounds
if (pos < 0 || pos >= op_length) {
    pos = -1;
}

// Handle selection with mouse click
if (mouse_check_button_pressed(mb_left) && pos >= 0) {
    switch (menu_level) {
        case 0: // Main settings menu
             switch (pos) {
                case 0: 
                    break; // Window Size (placeholder)
                case 1: 
                    break; // Brightness (placeholder)
                case 2: 
                    break; // Controls (placeholder)
				case 3:	
					room_goto(rm_main_menu);
					break;
            }
            break;
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: Create_0.gml
// obj_map Create Event
depth = -9998; // Ensure it's drawn above all other objects

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: Draw_0.gml
// obj_map Draw Event
draw_self(); // Draw the full map sprite

// Draw markers or labels for clickable regions (halved size)
draw_set_color(c_red);
draw_rectangle(185 - 25, 228 - 25, 185 + 25, 228 + 25, false); // Town
draw_rectangle(55 - 25, 190 - 25, 55 + 25, 190 + 25, false); // Beach
draw_rectangle(155 - 25, 128 - 25, 155 + 25, 128 + 25, false); // Ski village
draw_rectangle(280 - 25, 250 - 25, 280 + 25, 250 + 25, false); // Snow fort
draw_rectangle(410 - 25, 277 - 25, 410 + 25, 277 + 25, false); // Welcome room
draw_rectangle(380 - 25, 230 - 25, 380 + 25, 230 + 25, false); // Plaza
draw_rectangle(395 - 25, 170 - 25, 395 + 25, 170 + 25, false); // Forest
draw_rectangle(400 - 25, 130 - 25, 400 + 25, 130 + 25, false); // Cove
draw_rectangle(135 - 25, 60 - 25, 135 + 25, 60 + 25, false); // Mountain top

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: KeyPress_27.gml
if (global.chat_active) {
    show_debug_message("Map interaction blocked: Chat is active.");
    exit; // Prevent interaction when the chat window is open
}

camera_set_view_size(global.camera, global.camera_width, global.camera_height); // Restore original camera view size
instance_destroy(id);
show_debug_message("Map closed.");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: KeyPress_77.gml
if (global.chat_active) {
    show_debug_message("Map interaction blocked: Chat is active.");
    exit;
}

if (variable_global_exists("last_room") && global.last_room != noone) {
    show_debug_message("Returning to previous room: " + string(global.last_room));
    var target_room = global.last_room;
    global.last_room = noone; // Reset after use

    // Ensure the player instance is recreated when switching back
    room_goto(target_room);
} else {
    show_debug_message("No previous room recorded. Returning to default.");
    room_goto(rm_welcome_room);
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: Mouse_4.gml
if (global.chat_active) {
    show_debug_message("Map interaction blocked: Chat is active.");
    exit; // Prevent interaction when the chat window is open
}

// obj_map Mouse Left Pressed Event
var click_x = device_mouse_x_to_gui(0);
var click_y = device_mouse_y_to_gui(0);

show_debug_message("Mouse clicked at: " + string(click_x) + ", " + string(click_y));

// Define clickable regions for different rooms (halved size)
if (click_x > 87 - 25 && click_x < 87 + 25 && click_y > 283 - 25 && click_y < 283 + 25) {
    // Move to Beach
    show_debug_message("Beach region clicked");
    room_goto(rm_beach);
} else if (click_x > 185 - 25 && click_x < 185 + 25 && click_y > 228 - 25 && click_y < 228 + 25) {
    // Move to town
    show_debug_message("Town region clicked");
    room_goto(rm_town);
} else if (click_x > 55 - 25 && click_x < 55 + 25 && click_y > 190 - 25 && click_y < 190 + 25) {
    // Move to beach
    show_debug_message("Beach region clicked");
    room_goto(rm_beach);
} else if (click_x > 155 - 25 && click_x < 155 + 25 && click_y > 128 - 25 && click_y < 128 + 25) {
    // Move to ski village
    show_debug_message("Ski village region clicked");
    room_goto(rm_ski_village);
} else if (click_x > 280 - 25 && click_x < 280 + 25 && click_y > 250 - 25 && click_y < 250 + 25) {
    // Move to snow fort
    show_debug_message("Snow fort region clicked");
    room_goto(rm_snow_fort);
} else if (click_x > 410 - 25 && click_x < 410 + 25 && click_y > 277 - 25 && click_y < 277 + 25) {
    // Move to welcome room
    show_debug_message("Welcome room region clicked");
    room_goto(rm_welcome_room);
} else if (click_x > 380 - 25 && click_x < 380 + 25 && click_y > 230 - 25 && click_y < 230 + 25) {
    // Move to plaza
    show_debug_message("Plaza region clicked");
    room_goto(rm_plaza);
} else if (click_x > 395 - 25 && click_x < 395 + 25 && click_y > 170 - 25 && click_y < 170 + 25) {
    // Move to forest
    show_debug_message("Forest region clicked");
    room_goto(rm_forest);
} else if (click_x > 400 - 25 && click_x < 400 + 25 && click_y > 130 - 25 && click_y < 130 + 25) {
    // Move to cove
    show_debug_message("Cove region clicked");
    room_goto(rm_cove);
} else if (click_x > 135 - 25 && click_x < 135 + 25 && click_y > 60 - 25 && click_y < 60 + 25) {
    // Move to mountain top
    show_debug_message("Mountain top region clicked");
    room_goto(rm_ski_mountaintop);
} else {
    show_debug_message("No region matched. Click ignored.");
}

function create_warp_instance(target_room) {
    // Create a warp instance at the correct position
    var inst = instance_create_depth(0, 0, -9999, obj_warp);

    // Ensure the player warps to a valid position
    if (instance_exists(global.player_instance)) {
        inst.target_x = global.player_instance.x;
        inst.target_y = global.player_instance.y;
    } else {
        inst.target_x = 320; // Default center of the room (fallback)
        inst.target_y = 240;
    }

    inst.target_rm = target_room;
    inst.target_face = 0; // Set default direction
    inst.target_instance = global.player_instance;

    show_debug_message("DEBUG: Creating warp to " + string(target_room) + 
        " at (" + string(inst.target_x) + ", " + string(inst.target_y) + ")");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: Mouse_5.gml
if (global.chat_active) {
    show_debug_message("Map interaction blocked: Chat is active.");
    exit;
}

if (variable_global_exists("last_room") && global.last_room != noone) {
    show_debug_message("Returning to previous room: " + string(global.last_room));
    var target_room = global.last_room;
    global.last_room = noone; // Reset after use
	room_goto(target_room);
} else {
    show_debug_message("No previous room recorded. Returning to default.");
    room_goto(rm_welcome_room);
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map_icon
File: Draw_64.gml
/// Draw GUI Event for obj_map_icon
draw_sprite_ext(
    sprite_index, image_index,
    10, display_get_height() - sprite_height - 10, // Fixed GUI position
    1, 1, 0, c_white, 1
);

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map_icon
File: Mouse_4.gml
if (room != rm_map) {
    if (instance_exists(global.player_instance)) {
        global.player_x = global.player_instance.x;
        global.player_y = global.player_instance.y;

        show_debug_message("DEBUG: Stored player position: (" + string(global.player_x) + ", " + string(global.player_y) + ")");
        
        // Hide the player instead of destroying
        global.player_instance.visible = false;
    } else {
        show_debug_message("WARNING: No player instance found before switching rooms! Using default coordinates.");
        
        // Set default safe position
        global.player_x = 170;
        global.player_y = 154;
    }

    show_debug_message("Switching to map room...");
    global.last_room = room;
    room_goto(rm_map);
}
else if (variable_global_exists("last_room") && global.last_room != noone) {
    show_debug_message("Returning to previous room: " + string(global.last_room));
    room_goto(global.last_room);

}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map_icon
File: Step_0.gml
//Step event
if (global.chat_active) exit;
depth = -1000;

// Position map icon in the corner of the screen
x = camera_get_view_x(global.camera);
y = camera_get_view_y(global.camera) + camera_get_view_height(global.camera) - sprite_height;

// Check if the mouse is hovering over the icon
if (position_meeting(mouse_x, mouse_y, id)) {
    image_index = 1; // Change to highlighted sprite
} else {
    image_index = 0; // Revert to normal sprite
}

// Hide player instead of destroying in UI rooms
var is_ui_room = (room == rm_init || room == rm_main_menu || room == rm_map || room == rm_sled_racing || room == rm_pause_menu || room == rm_settings_menu);

if (is_ui_room) {
    if (instance_exists(obj_map_icon)) {
        obj_map_icon.visible = false;
        show_debug_message("DEBUG: UI Room detected. Player instance hidden.");
    }
} else {
    if (instance_exists(obj_map_icon)) {
       obj_map_icon.visible = true;
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map_item
File: Create_0.gml
event_inherited();
item_name = "Map";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_animation
File: Create_0.gml
offset_y = 0;
scroll_distance = sprite_get_height(spr_main_menu) - room_height;
move_speed = 2;
animation_complete = false;
button_alpha = 0;
fade_speed = 0.02;
button_ids = [];
delay_timer = 120;
jetpack_y = 80;
puffle_y = 80;
jetpack_frame_speed = 0.5;
puffle_frame_speed = 0.5;
jetpack_image_index = 0;
puffle_image_index = 0;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_animation
File: Draw_0.gml
// Draw main menu sprite
draw_sprite(spr_main_menu, 0, 0, offset_y);
draw_sprite_ext(spr_menu_puffle, floor(puffle_image_index), 120, puffle_y, 1, 1, 0, c_white, 1);
draw_sprite_ext(spr_menu_jetpackguy, floor(jetpack_image_index), 60, jetpack_y, 1, 1, 0, c_white, 1);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_animation
File: Other_4.gml
button_ids = [];
var num_buttons = instance_number(obj_menu_button);
for (var i = 0; i < num_buttons; i++) {
    var btn = instance_find(obj_menu_button, i);
    if (btn != noone) {
        button_ids[i] = btn;
    }
}
show_debug_message("Number of buttons found: " + string(array_length(button_ids)));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_animation
File: Step_0.gml
// Existing logic for delay and scrolling
if (delay_timer > 0) {
    delay_timer -= 1;  // Countdown the delay timer
} else if (!animation_complete) {
    offset_y -= move_speed;  // Start scrolling after delay
    if (offset_y <= -scroll_distance) {
        offset_y = -scroll_distance;
        animation_complete = true;
    }
} else {
    if (button_alpha < 1) {
        button_alpha += fade_speed;  // Fade in buttons after animation
        if (button_alpha > 1) button_alpha = 1;
        
        for (var i = 0; i < array_length(button_ids); i++) {
            var btn_id = button_ids[i];
            if (instance_exists(btn_id)) {
                with (btn_id) {
                    image_alpha = other.button_alpha;
                }
            }
        }
    }
}

// Jetpack Guy Movement Logic
if (!animation_complete) {
    // Move `spr_menu_jetpackguy` upward as `offset_y` decreases
    jetpack_y = 80 - (offset_y * -1);
}

// Puffle Movement Logic
if (!animation_complete) {
    // Move `spr_menu_puffle` upward as `offset_y` decreases
    puffle_y = 80 - (offset_y * -1);
}

// Jetpack Guy Animation Logic
jetpack_image_index += jetpack_frame_speed;
if (jetpack_image_index >= sprite_get_number(spr_menu_jetpackguy)) {
    jetpack_image_index = 0;
}

// Puffle Animation Logic
puffle_image_index += puffle_frame_speed;
if (puffle_image_index >= sprite_get_number(spr_menu_puffle)) {
    puffle_image_index = 0;
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Create_0.gml
// Create Event in obj_menu_button
btn_action = "";             // Action to perform (set via creation code)
btn_text = "";               // Text to display (set via creation code)
btn_font = fnt_bonkfatty;    // Font for button text
text_color = c_black;        // Text color
image_speed = 0;             // Prevent automatic frame switching
image_index = 0;             // Start on frame 0 (normal state)

// Set initial alpha based on room
if (room == rm_main_menu) {
    image_alpha = 0;         // Start invisible for fade-in
} else {
    image_alpha = 1;         // Visible in other rooms
}

// Show "Continue" button only if save file exists
if (btn_action == "continue") {
    visible = file_exists("savegame.sav");
} else {
    visible = true;          // Other buttons are visible by default
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Draw_0.gml
if (mouse_check_button(mb_left) && position_meeting(mouse_x, mouse_y, id)) {
    image_index = 1;  // Show frame 1 when clicked
} else {
    image_index = 0;  // Revert to frame 0 when not clicked
}
draw_self();

// Set alpha for text to match button
draw_set_alpha(image_alpha);

// Set text alignment
draw_set_halign(fa_center);
draw_set_valign(fa_middle);

// Calculate text position
var text_x = x + sprite_width / 2;
var text_y = y + sprite_height / 2;

// Draw the button text
draw_set_color(text_color);
draw_set_font(btn_font);
draw_text_ext(text_x, text_y, btn_text, -1, sprite_width - 100);

// Reset alpha and alignment
draw_set_alpha(1);
draw_set_halign(fa_left);
draw_set_valign(fa_top);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Mouse_10.gml
hover = true;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Mouse_11.gml
hover = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Mouse_4.gml
// Left Pressed Event in obj_menu_button
if (btn_action == "new_game") {
    room_goto(rm_colorpicker_menu);  // Go to color picker for new game
} else if (btn_action == "continue") {
    load_game();                  // Call the load_game function to resume saved game
} else if (btn_action == "play") {
    room_goto(rm_init);           // Existing action for play
} else if (btn_action == "start") {
    room_goto(rm_saveload);  // Redirect to rm_saveload instead of rm_colour_picker
} else if (btn_action == "settings") {
    room_goto(rm_settings_menu);  // Existing action for settings
} else if (btn_action == "exit") {
    game_end();                   // Existing action for exit
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_controller
File: Create_0.gml
global.menu_state = "none"; // Possible values: "none", "puffle_menu", "name_puffle"
global.selected_puffle = noone;
global.menu_index = 0; // Selected option
name = "";
owner = noone;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_controller
File: Draw_64.gml
if (global.menu_state == "puffle_menu") {
    draw_set_color(c_black);
    draw_rectangle(100, 100, 300, 200, false); // Menu background
    draw_set_color(c_white);
    draw_text(150, 120, "Adopt");
    draw_text(150, 140, "Cancel");
    draw_text(130, 120 + global.menu_index * 20, ">"); // Cursor
}

if (global.menu_state == "name_puffle") {
    draw_set_color(c_black);
    draw_rectangle(100, 100, 300, 200, false);
    draw_set_color(c_white);
    draw_text(150, 140, "Press Enter to name your puffle");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_controller
File: Step_0.gml
if (global.menu_state == "puffle_menu") {
    // Menu options
    var options = ["Adopt", "Cancel"];
    var choice = -1;
    
    // Simple keyboard navigation (expand for mouse if needed)
    if (keyboard_check_pressed(vk_down)) global.menu_index = min(global.menu_index + 1, 1);
    if (keyboard_check_pressed(vk_up)) global.menu_index = max(global.menu_index - 1, 0);
    if (keyboard_check_pressed(vk_enter)) choice = global.menu_index;
    
    // Handle choice
    if (choice == 0) { // Adopt
        global.menu_state = "name_puffle";
        global.menu_index = 0; // Reset for next menu
    } else if (choice == 1) { // Cancel
        global.menu_state = "none";
        global.selected_puffle = noone;
    }
}

if (global.menu_state == "name_puffle") {
    if (keyboard_check_pressed(vk_enter)) {
        var puffle_name = get_string("Enter a name for your puffle:", "Puffle");
        if (puffle_name != "") {
            with (global.selected_puffle) {
                name = puffle_name;
                owner = obj_player; // Mark as adopted
            }
            obj_player.puffle_os -= 1; // Consume one Puffle-O
            global.menu_state = "none";
            global.selected_puffle = noone;
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_minershardhat_item
File: Create_0.gml
event_inherited();
item_name = "Miners Hard Hat";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_musicmanager
File: Create_0.gml
//global volume control
global.masterVolume = 1;
global.musicVolume = 1;

//info for the song that we are currently playing / trying to play
songInstance = noone;
songAsset = noone;
targetSongAsset = noone;
endFadeOutTime = 0;//how many frames to fade out the song currently playing
startFadeInTime = 0;//how many frames to fade in the new song
fadeInInstVol = 1;//the volume of songInstance

//for fading music out and stopping songs that are no longer playing
fadeOutInstances = array_create(0);//audio instances to fade out
fadeOutInstVol = array_create(0);//the volume of each indiviual audio instance
fadeOutInstTime = array_create(0);//how fast the fadeout should happen
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_musicmanager
File: Other_4.gml
// Play the correct music

if room == rm_welcome_room
|| room == rm_plaza
|| room == rm_shore
{
	set_song_ingame( bg_music, 60, 0 );
}

//For other rooms that require different music
//if room == rm_template
//{
//	set_song_ingame( bg_music, 3*60 );
//}

//if room == rm_template
//{
//	set_song_ingame( bg_music, 2*60, 2*60 );
//}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_musicmanager
File: Step_0.gml
var _finalVol = global.musicVolume*global.masterVolume;

//Play the target song
if songAsset != targetSongAsset
{
	//Tell the old song to fade out
	if audio_is_playing( songInstance )
	{
		//add out songInstance to our array of songs to fade out
		array_push( fadeOutInstances, songInstance );
		//add the songInstance's starting volume (so theres no adrupt change in volume)
		array_push( fadeOutInstVol, fadeInInstVol );
		//add the fadeOutInstance's fade out frames
		array_push( fadeOutInstTime, endFadeOutTime );
		
		//reset the songInstance and songAsset variables
		songInstance = noone;
		songAsset = noone;
	}
	
	
	//Play the song if the old song has faded out
	if array_length( fadeOutInstances) == 0
	{
		if audio_exists( targetSongAsset)
		{
			//Play the song and store its instance in a variable
			songInstance = audio_play_sound( targetSongAsset, 4, true );
	
			//Start the song's volume at 0
			audio_sound_gain( songInstance, 0, 0 );
			fadeInInstVol = 0;
		}
	
	//Set the songAssest to match the targetSongAsset
	songAsset = targetSongAsset;
	}
}


//Volume Control
	//Main song volume
	if audio_is_playing( songInstance )
	{
		//Fade the song in
		if startFadeInTime > 0
		{
			if fadeInInstVol < 1 { fadeInInstVol += 1/startFadeInTime; } else fadeInInstVol = 1
		}
		//Immediately start the song if the fade in time is 0 framces
		else
		{
			fadeInInstVol = 1;
		}
	
		//Actually set the gain
		audio_sound_gain( songInstance, fadeInInstVol*_finalVol, 0 )
	}
	
	//Fading songs out
	for(var i = 0; i < array_length(fadeOutInstances); i++ )
	{
		//Fade the volume
		if fadeOutInstTime[i] > 0
		{
			if	fadeOutInstVol[i] > 0 {fadeOutInstVol[i] -= 1/fadeOutInstTime[i]; }
		}
		//Immediately cut volume to 0 otherwuse
		else
		{
			fadeOutInstVol[i] = 0;
		}
		
		//Actually set the gain
		audio_sound_gain( fadeOutInstances[i], fadeOutInstVol[i]*_finalVol, 0 );
		
		//Stop the song when it's volume is at 0 and remove it from ALL arrays
		if fadeOutInstVol[i] <= 0
		{
			//stop the song	
			if audio_is_playing( fadeOutInstances[i] ) { audio_stop_sound( fadeOutInstances[i] ); };
			//remove it from the arrays
			array_delete( fadeOutInstances, i, 1);
			array_delete( fadeOutInstVol, i, 1);
			array_delete( fadeOutInstTime, i, 1);
			//set the loop back 1 since we just deleted an entry
			i--;
		}
	}
	
	
	
	
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_new_game_button
File: Create_0.gml
depth = -1000;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_new_game_button
File: Mouse_4.gml
room_goto(rm_colour_picker);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc
File: Alarm_0.gml
if (npc_portrait != "") {
    sprite_index = npc_portrait;
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc
File: Create_0.gml
// Movement settings
xspd = 0;
yspd = 0;
move_spd = 0;
move_x = 0;
move_y = 0;
is_moving = false;
collision_delay = 0;
stuck_timer = 0;
wait_timer = 3;
last_x = x;
last_y = y;
face = DOWN;


// NPC Settings
npc_name = "NPC";  // Default name
if (variable_global_exists("player_colors") && array_length(global.player_colors) > 0) {
    npc_color = global.player_colors[irandom(array_length(global.player_colors) - 1)];
} else {
    npc_color = c_white; // Fallback to white if colors are not defined
}
is_static = true;  // If true, NPC doesn't move

// Dialogue and quest-related variables
quest_active = false;
quest_complete = false;
current_dialogue_index = -1;
dialogue = ["Hello there!", "I have nothing to say."];
player_interacting = false;

// Quest System
is_quest_giver = false;
quest_given = false;
quest_item = "";
quest_quantity = 0;  // Default to 0, set in creation code if needed
quest_stage = 0;  // 0 = not started, 1 = completed
reward_item = "";

// Sprite setup (mirroring obj_player)
sprite_body = spr_player_body;
sprite_color = spr_player_colour;
mask_index = spr_player_down;
image_speed = 0;
image_index = 0;

// Frame data for walking (same as obj_player)
frame_data = array_create(8);
frame_data[DOWN] = [0, 0, 24, 24, 0, 24, 24, 24, 0, 48, 24, 24];
frame_data[UP] = [24, 0, 24, 24, 24, 24, 24, 24, 24, 48, 24, 24];
frame_data[DOWN_LEFT] = [48, 0, 24, 24, 48, 24, 24, 24, 48, 48, 24, 24];
frame_data[DOWN_RIGHT] = [72, 0, 24, 24, 72, 24, 24, 24, 72, 48, 24, 24];
frame_data[LEFT] = [96, 0, 24, 24, 96, 24, 24, 24, 96, 48, 24, 24];
frame_data[RIGHT] = [120, 0, 24, 24, 120, 24, 24, 24, 120, 48, 24, 24];
frame_data[UP_RIGHT] = [144, 0, 24, 24, 144, 24, 24, 24, 144, 48, 24, 24];
frame_data[UP_LEFT] = [168, 0, 24, 24, 168, 24, 24, 24, 168, 48, 24, 24];

// Depth sorting
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc
File: Draw_0.gml
// Calculate drawing position
var draw_x = x - 12;  // Center 24x24 sprite
var draw_y = y - 12;
var frame_index = floor(image_index) mod 3;  // 3 frames per direction
var frame_x = frame_data[face][frame_index * 4];
var frame_y = frame_data[face][frame_index * 4 + 1];
var frame_width = frame_data[face][frame_index * 4 + 2];
var frame_height = frame_data[face][frame_index * 4 + 3];

// Draw body and colored overlay
draw_sprite_part_ext(sprite_body, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, c_white, 1);
draw_sprite_part_ext(sprite_color, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, npc_color, 1);

// Depth sorting
depth = -y;  // Consistent with set_depth()

// Draw the dialogue box if active
if (current_dialogue_index >= 0) {
    // Text and box parameters
    var margin = 8; // Padding around the text
    var max_width = 200; // Maximum width for the dialogue box
    var text_scale = 0.50; // Scale the text smaller

    // Calculate text dimensions
	draw_set_font(fnt_acme_secretagent_bold);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    var text_width = string_width(dialogue[current_dialogue_index]) * text_scale;
    var text_height = string_height(dialogue[current_dialogue_index]) * text_scale;

    // Calculate box dimensions (add padding around the text)
    var box_width = min(max_width, text_width + margin * 2);
    var box_height = text_height + margin * 2;

    // Position the box
    var box_x = x - box_width / 2;
    var box_y = y - sprite_height - box_height - 0.5;

    // Draw 9-slice sprite background
    draw_sprite_stretched(
        spr_chat,     // Sprite
        0,                       // Sub-image index
        box_x,                   // X position
        box_y,                   // Y position
        box_width,               // Scaled width
        box_height               // Scaled height
    );

    // Draw the scaled text
    var text_x = box_x + box_width / 2;
    var text_y = box_y + box_height / 2;
    draw_set_color(c_black);
    draw_text_transformed(text_x, text_y, dialogue[current_dialogue_index], text_scale, text_scale, 0);
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc
File: Step_0.gml
// In obj_npc Step Event
if (place_meeting(x, y, global.player_instance)) {
    if (keyboard_check_pressed(ord("E"))) {
        if (!instance_exists(obj_chat_window)) {
            var chat = instance_create_layer(0, 0, "UI", obj_chat_window);
            chat.dialog_data = dialog_data;  // Assign this NPC's unique dialog_data
            global.chat_npc = id;            // Set this NPC as the chat target
            global.chat_active = true;       // Make the chat window visible
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc_old
File: Alarm_0.gml
// Alarm[0] Event
// Reset moving state to allow the NPC to pick a new target
is_moving = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc_old
File: Create_0.gml
xspd = 0;
yspd = 0;

move_spd = 0.5; // Lower speed for smoother movement
move_x = 0;
move_y = 0;
is_moving = false;
collision_delay = 0; // Timer for delaying after a collision
stuck_timer = 0; // Timer to handle stuck state
wait_timer = 3; //Timer to handle how long to pause before walking
last_x = x;      // Tracks previous position for stuck detection
last_y = y;      // Tracks previous position for stuck detection

// Initialize movement variables
target_x = x; // Default to current position
target_y = y; // Default to current position
is_moving = false;
move_speed = 1; // Default movement speed

sprite[RIGHT] = spr_player_right;
sprite[UP] = spr_player_up;
sprite[LEFT] = spr_player_left;
sprite[DOWN] = spr_player_down;
sprite[UP_RIGHT] = spr_player_up_right;
sprite[UP_LEFT] = spr_player_up_left;
sprite[DOWN_RIGHT] = spr_player_down_right;
sprite[DOWN_LEFT] = spr_player_down_left;

face = DOWN;

sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;

// Random initial direction
direction = choose(0, 45, 90, 135, 180, 225, 270, 315);
change_direction_timer = fps * 2; // Change direction every 2 seconds

phrases = ["Hello there!", "Nice to meet you!", "What brings you here?", "Have a great day!", "Stay safe!"];
current_phrase = ""; // Will hold the currently displayed phrase
talk_timer = 0; // Timer for how long the phrase is displayed
interact_pause = 0; // Timer to pause movement after interaction


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc_old
File: Draw_0.gml
// Draw NPC as usual
draw_self();

// Ensure chat box is drawn above everything
if (talk_timer > 0) {
    // Text setup
    var text = current_phrase;
    var text_scale = 0.5; // Scale factor for text
    var text_padding = 10; // Padding around the text

    // Calculate text dimensions
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    var text_width = string_width(text) * text_scale; // Scaled width of the text
    var text_height = string_height(text) * text_scale; // Scaled height of the text

    // Calculate box dimensions (add padding around the text)
    var box_width = max(64, text_width + text_padding * 2); // Minimum width for aesthetics
    var box_height = text_height + text_padding * 2;

    // Position the box
    var box_x = x - box_width / 2;
    var box_y = y - sprite_height - box_height - 10;

    // Draw 9-slice sprite background
    draw_sprite_stretched(
        spr_menu,     // Sprite
        0,                       // Sub-image index
        box_x,                   // X position
        box_y,                   // Y position
        box_width,               // Scaled width
        box_height               // Scaled height
    );

    // Draw the scaled text
    var text_x = box_x + box_width / 2;
    var text_y = box_y + box_height / 2;
    draw_set_color(c_black);
    draw_text_transformed(text_x, text_y, text, text_scale, text_scale, 0);
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc_old
File: Step_0.gml
// Step Event for obj_npc
if (!sliding) {
    // Normal movement logic
    var move_x = lengthdir_x(move_spd, direction);
    var move_y = lengthdir_y(move_spd, direction);

    // Handle collisions with walls
    if (place_meeting(x + move_x, y, obj_wall)) {
        direction = 360 - direction; // Reverse direction on x-axis
    }
    if (place_meeting(x, y + move_y, obj_wall)) {
        direction = 180 - direction; // Reverse direction on y-axis
    }

    // Check for collision with obj_slippery to start sliding
    if (place_meeting(x + move_x, y, obj_slippery) || place_meeting(x, y + move_y, obj_slippery)) {
        sliding = true;
        slide_dir_x = sign(move_x);
        slide_dir_y = sign(move_y);
        slide_speed = move_spd * 1.5; // Initial slide speed, adjust as necessary
    } else {
        // Move the NPC normally
        x += move_x;
        y += move_y;
    }

    // Decrease the timer for changing direction
    change_direction_timer--;
    if (change_direction_timer <= 0) {
        direction = choose(0, 45, 90, 135, 180, 225, 270, 315);
        change_direction_timer = fps * 2; // Reset the timer
    }
} else {
    // Sliding logic
    var slide_move_x = slide_dir_x * slide_speed;
    var slide_move_y = slide_dir_y * slide_speed;

    // Decelerate slide over time
    slide_speed *= 0.98; // Adjust this value to control sliding deceleration

    // Stop sliding if speed is low enough
    if (abs(slide_speed) < 0.1) {
        sliding = false;
        slide_move_x = 0;
        slide_move_y = 0;
    }

    // Move the NPC while sliding
    x += slide_move_x;
    y += slide_move_y;
}

// Update the sprite based on direction
if (slide_speed > 0) {
    if (slide_dir_y < 0) {
        if (slide_dir_x < 0) { face = UP_LEFT; }
        if (slide_dir_x > 0) { face = UP_RIGHT; }
        if (slide_dir_x == 0) { face = UP; }
    }
    if (slide_dir_y > 0) {
        if (slide_dir_x < 0) { face = DOWN_LEFT; }
        if (slide_dir_x > 0) { face = DOWN_RIGHT; }
        if (slide_dir_x == 0) { face = DOWN; }
    }
    if (slide_dir_y == 0) {
        if (slide_dir_x > 0) { face = RIGHT; }
        if (slide_dir_x < 0) { face = LEFT; }
    }
} else {
    if (direction == 0) face = RIGHT;
    else if (direction == 45) face = UP_RIGHT;
    else if (direction == 90) face = UP;
    else if (direction == 135) face = UP_LEFT;
    else if (direction == 180) face = LEFT;
    else if (direction == 225) face = DOWN_LEFT;
    else if (direction == 270) face = DOWN;
    else if (direction == 315) face = DOWN_RIGHT;
}
sprite_index = sprite[face];

// Depth
depth = -bbox_bottom;

// Debugging logs

show_debug_message("NPC Direction: " + string(direction));
show_debug_message("NPC Face: " + string(face));
show_debug_message("NPC Position: " + string(x) + ", " + string(y));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_obstacle
File: Create_0.gml
// Create Event for obj_obstacle
move_speed = 5; // Speed at which obstacles move upwards

// Step Event for obj_obstacle
y += move_speed;

// Destroy the obstacle if it goes off the top of the screen
if (y < -sprite_height) {
    instance_destroy();
}

//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_obstacle
File: Step_0.gml
if (global.game_started) {
    y -= move_speed; // Move upwards

    // Reset position if off-screen
    if (y < -sprite_height) {
        y = room_height + sprite_height; // Reset to below the room
        x = irandom_range(0, room_width - sprite_width); // Randomize horizontal position
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_obstacle_controller
File: Alarm_0.gml
instance_create_layer(irandom_range(0, room_width - sprite_get_width(spr_long_bush)), room_height, "Instances", obj_obstacle);
alarm[0] = 30; // Reset alarm
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_obstacle_controller
File: Create_0.gml
alarm[0] = 30; // Spawn obstacle every 30 steps (adjust for difficulty)
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_parallax_background
File: Create_0.gml
depth = 10000;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_parallax_background
File: Draw_0.gml
var _camx = camera_get_view_x(global.camera);  // Use global.camera explicitly
var _camy = camera_get_view_y(global.camera);

var _p = 0.5;  // Parallax factor (adjust as needed)

if (sprite_exists(bg_sky)) {
    draw_sprite(bg_sky, 0, _camx * _p, _camy * _p);
} else {
    show_debug_message("ERROR: bg_sky sprite does not exist!");
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_party_hat
File: Create_0.gml
event_inherited();
item_name = "Party Hat";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pause_menu
File: Create_0.gml
// Create Event in obj_pause_menu
depth = -99990; // Ensure pause menu is drawn on top
global.is_pause_menu_active = false;
global.inventory_visible = false; 

image_speed = 0.5; // Menu animation speed

op_border = 8;
op_space = 16;
pos = 0;

// Pause menu options
option[0, 0] = "Back to Game";
option[0, 1] = "Settings";
option[0, 2] = "Quit Game";
option[0, 3] = "Save Game"; // Added "Save Game" option

// Settings menu options
option[1, 0] = "Window Size";
option[1, 1] = "Brightness";
option[1, 2] = "Controls";
option[1, 3] = "Back";

menu_level = 0; 
op_length = array_length(option[menu_level]); // Set initial length dynamically
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pause_menu
File: Draw_0.gml
// Only draw when the pause menu is active
if (!global.is_pause_menu_active) {
    exit;
}

draw_set_font(fnt_bumbastika_sml);

// Ensure menu_level is valid
// Ensure menu_level is valid
if (menu_level < 0 || menu_level >= array_length(option)) return;

// Dynamically calculate menu width
var _new_w = 0;
for (var i = 0; i < op_length; i++) {
    if (i < array_length(option[menu_level])) {
        _new_w = max(_new_w, string_width(option[menu_level][i]));
    }
}
width = _new_w + op_border * 2;
height = op_border * 4 + string_height(option[menu_level][0]) * op_length;

// Center menu
x = camera_get_view_x(view_camera[0]) + (camera_get_view_width(view_camera[0]) - width) / 2;
y = camera_get_view_y(view_camera[0]) + (camera_get_view_height(view_camera[0]) - height) / 2;

// Draw the menu background
draw_sprite_ext(
    spr_pause_menu, 
    floor(image_index), // Use image_index for animation
    x, 
    y, 
    width / sprite_get_width(spr_pause_menu), 
    height / sprite_get_height(spr_pause_menu), 
    0, 
    c_white, 
    1
);

// Draw menu options
draw_set_valign(fa_top);
draw_set_halign(fa_center);
for (var i = 0; i < op_length; i++) {
    if (i < array_length(option[menu_level])) {
        var color = (pos == i) ? c_yellow : c_white; // Highlight selection
        draw_text_color(x + width / 2, y + op_border + op_space * i, option[menu_level][i], color, color, color, color, 1);
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pause_menu
File: Step_0.gml

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pause_menu
File: Step_2.gml
// End Step Event in obj_pause_menu
// Only process inputs when the pause menu is active
if (!global.is_pause_menu_active) {
    exit;
}

// Skip if click was already handled by another UI element
if (global.click_handled) {
    exit;
}

// Skip input processing if inventory or expanded HUD is visible
if (global.inventory_visible || global.is_expanded) {
    exit;
}

// Update menu options dynamically
op_length = array_length(option[menu_level]);

// Mouse Position Adjusted to GUI Coordinates
var menu_width = 300;
var menu_height = op_length * 40 + 20;
var menu_top = y - menu_height / 2 + 20;
var menu_left = x - menu_width / 2;

if (mouse_x > menu_left && mouse_x < menu_left + menu_width) {
    pos = floor((mouse_y - menu_top) / 40);
} else {
    pos = -1;
}

// Ensure pos is within valid bounds
if (pos < 0 || pos >= op_length) pos = -1;

// Handle menu selection with mouse click
if (mouse_check_button_pressed(mb_left) && pos >= 0) {
    switch (menu_level) {
        case 0: // Main Pause Menu
            switch (pos) {
                case 0: // Resume Game
                    global.is_pause_menu_active = false;
                    global.player_controls_enabled = true;
                    show_debug_message("Game Resumed");
                    break;
                case 1: // Go to Settings
                    menu_level = 1;
                    break;
                case 2: // Quit Game
                    show_debug_message("Calling game_end from obj_pause_menu Quit Game button");
                    game_end();
                    break;
                case 3: // Save Game
                    save_game(); // Call the save function
                    break;
            }
            break;
        case 1: // Settings Menu
            switch (pos) {
                case 0: 
                    break; // Window Size (placeholder)
                case 1: 
                    break; // Brightness (placeholder)
                case 2: 
                    break; // Controls (placeholder)
                case 3: // Back to Pause Menu
                    menu_level = 0;
                    break;
            }
            break;
    }
}

show_debug_message("Pause menu active: " + string(global.is_pause_menu_active) + ", Click handled: " + string(global.click_handled));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pickup_item
File: Create_0.gml
// obj_pickup_item Create Event
is_savable = true;
item_name = ""; // Set in creation code or instance variables

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pickup_item
File: Step_0.gml
// obj_pickup_item Step Event
if (keyboard_check_pressed(ord("E")) && distance_to_object(global.player_instance) < 16) {
    if (instance_exists(obj_inventory)) {
        var added = obj_inventory.add_to_inventory(item_name);
        if (added) {
            show_debug_message(item_name + " added to inventory.");
            instance_destroy();
        } else {
            show_debug_message("Inventory full.");
        }
    }
}
set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pizzaslice_item
File: Create_0.gml
event_inherited();
item_name = "Pizza Slice";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player
File: Create_0.gml
// Core variables
xspd = 0;
yspd = 0;
move_spd = 1;
state = "walking";
if (!variable_global_exists("player_color")) { global.player_color = c_white; }
if (variable_global_exists("last_player_color")) { global.player_color = global.last_player_color; } else { global.player_color = c_white; }

// Sliding variables
sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;

// Driving variables
driving = false;
original_sprite = sprite_index;

// Set direction and sprites
face = DOWN;
sprite_body = spr_player_body; // Default sprite
sprite_color = spr_player_colour;
show_debug_message("global.player_color before setting: " + string(global.player_color));
image_blend = global.player_color;
show_debug_message("Applied player color: " + string(global.player_color));
mask_index = spr_player_down;
throw_anim_base = "";  // "down_right" or "up_right"
throw_flip = false;    // Whether to flip the sprite horizontally

// Frame data for walking (192x72 sprite sheet: 3 frames per direction)
frame_data = array_create(8);
frame_data[DOWN] = [0, 0, 24, 24, 0, 24, 24, 24, 0, 48, 24, 24];
frame_data[UP] = [24, 0, 24, 24, 24, 24, 24, 24, 24, 48, 24, 24];
frame_data[DOWN_LEFT] = [48, 0, 24, 24, 48, 24, 24, 24, 48, 48, 24, 24];
frame_data[DOWN_RIGHT] = [72, 0, 24, 24, 72, 24, 24, 24, 72, 48, 24, 24];
frame_data[LEFT] = [96, 0, 24, 24, 96, 24, 24, 24, 96, 48, 24, 24];
frame_data[RIGHT] = [120, 0, 24, 24, 120, 24, 24, 24, 120, 48, 24, 24];
frame_data[UP_RIGHT] = [144, 0, 24, 24, 144, 24, 24, 24, 144, 48, 24, 24];
frame_data[UP_LEFT] = [168, 0, 24, 24, 168, 24, 24, 24, 168, 48, 24, 24];

// Special actions system
action_state = "none";  // "none", "dance", "wave", "sit", "jackhammer", "snowshovel", "throw"
action_timer = 0;
action_duration = 0;
sit_delay = 0;
image_index = 0;              // Current animation frame
image_speed = 0;              // Animation speed


// Frame data and sprite maps for special actions
action_frame_data = ds_map_create();
action_sprite_body = ds_map_create();
action_sprite_color = ds_map_create();
action_anim_speed = ds_map_create();

// Sit (8 frames, 24x24, y=72 in spr_player_body)
ds_map_add(action_frame_data, "sit", [
    [0, 72, 24, 24], [24, 72, 24, 24], [48, 72, 24, 24], [72, 72, 24, 24],
    [96, 72, 24, 24], [120, 72, 24, 24], [144, 72, 24, 24], [168, 72, 24, 24]
]);
ds_map_add(action_sprite_body, "sit", spr_player_body);
ds_map_add(action_sprite_color, "sit", spr_player_colour);
ds_map_add(action_anim_speed, "sit", 0); // Static

// Wave (16 frames, 24x24, y=96-120 in spr_player_body)
ds_map_add(action_frame_data, "wave", [
    [0, 96, 24, 24], [24, 96, 24, 24], [48, 96, 24, 24], [72, 96, 24, 24],
    [96, 96, 24, 24], [120, 96, 24, 24], [144, 96, 24, 24], [168, 96, 24, 24],
    [0, 120, 24, 24], [24, 120, 24, 24], [48, 120, 24, 24], [72, 120, 24, 24],
    [96, 120, 24, 24], [120, 120, 24, 24], [144, 120, 24, 24], [168, 120, 24, 24]
]);
ds_map_add(action_sprite_body, "wave", spr_player_body);
ds_map_add(action_sprite_color, "wave", spr_player_colour);
ds_map_add(action_anim_speed, "wave", 0.1); // ~5 FPS

// Dance (56 frames, 24x24, y=144-288 in spr_player_body)
ds_map_add(action_frame_data, "dance", [
    [0, 144, 24, 24], [24, 144, 24, 24], [48, 144, 24, 24], [72, 144, 24, 24], [96, 144, 24, 24], [120, 144, 24, 24], [144, 144, 24, 24], [168, 144, 24, 24],
    [0, 168, 24, 24], [24, 168, 24, 24], [48, 168, 24, 24], [72, 168, 24, 24], [96, 168, 24, 24], [120, 168, 24, 24], [144, 168, 24, 24], [168, 168, 24, 24],
    [0, 192, 24, 24], [24, 192, 24, 24], [48, 192, 24, 24], [72, 192, 24, 24], [96, 192, 24, 24], [120, 192, 24, 24], [144, 192, 24, 24], [168, 192, 24, 24],
    [0, 216, 24, 24], [24, 216, 24, 24], [48, 216, 24, 24], [72, 216, 24, 24], [96, 216, 24, 24], [120, 216, 24, 24], [144, 216, 24, 24], [168, 216, 24, 24],
    [0, 240, 24, 24], [24, 240, 24, 24], [48, 240, 24, 24], [72, 240, 24, 24], [96, 240, 24, 24], [120, 240, 24, 24], [144, 240, 24, 24], [168, 240, 24, 24],
    [0, 264, 24, 24], [24, 264, 24, 24], [48, 264, 24, 24], [72, 264, 24, 24], [96, 264, 24, 24], [120, 264, 24, 24], [144, 264, 24, 24], [168, 264, 24, 24],
    [0, 288, 24, 24], [24, 288, 24, 24], [48, 288, 24, 24], [72, 288, 24, 24], [96, 288, 24, 24], [120, 288, 24, 24], [144, 288, 24, 24], [168, 288, 24, 24]
]);
ds_map_add(action_sprite_body, "dance", spr_player_body);
ds_map_add(action_sprite_color, "dance", spr_player_colour);
ds_map_add(action_anim_speed, "dance", 0.125); // ~4 FPS

// Jackhammer (50 frames, 32x24, spr_player_body_jackhammer)
ds_map_add(action_frame_data, "jackhammer", [
    [0, 0, 32, 24], [32, 0, 32, 24], [64, 0, 32, 24], [96, 0, 32, 24], [128, 0, 32, 24], [160, 0, 32, 24],
    [0, 24, 32, 24], [32, 24, 32, 24], [64, 24, 32, 24], [96, 24, 32, 24], [128, 24, 32, 24], [160, 24, 32, 24],
    [0, 48, 32, 24], [32, 48, 32, 24], [64, 48, 32, 24], [96, 48, 32, 24], [128, 48, 32, 24], [160, 48, 32, 24],
    [0, 72, 32, 24], [32, 72, 32, 24], [64, 72, 32, 24], [96, 72, 32, 24], [128, 72, 32, 24], [160, 72, 32, 24],
    [0, 96, 32, 24], [32, 96, 32, 24], [64, 96, 32, 24], [96, 96, 32, 24], [128, 96, 32, 24], [160, 96, 32, 24],
    [0, 120, 32, 24], [32, 120, 32, 24], [64, 120, 32, 24], [96, 120, 32, 24], [128, 120, 32, 24], [160, 120, 32, 24],
    [0, 144, 32, 24], [32, 144, 32, 24], [64, 144, 32, 24], [96, 144, 32, 24], [128, 144, 32, 24], [160, 144, 32, 24],
    [0, 168, 32, 24], [32, 168, 32, 24], [64, 168, 32, 24], [96, 168, 32, 24], [128, 168, 32, 24], [160, 168, 32, 24],
    [0, 192, 32, 24], [32, 192, 32, 24], [64, 192, 32, 24], [96, 192, 32, 24], [128, 192, 32, 24], [160, 192, 32, 24]
]);
ds_map_add(action_sprite_body, "jackhammer", spr_player_body_jackhammer);
ds_map_add(action_sprite_color, "jackhammer", spr_player_colour_jackhammer);
ds_map_add(action_anim_speed, "jackhammer", 0.15); // ~3.33 FPS

// Snow Shovel (16 frames, 24x48, spr_player_body_snowshovel)
ds_map_add(action_frame_data, "snowshovel", [
    [0, 0, 24, 48], [24, 0, 24, 48], [48, 0, 24, 48], [72, 0, 24, 48], [96, 0, 24, 48], [120, 0, 24, 48], [144, 0, 24, 48], [168, 0, 24, 48],
    [0, 48, 24, 48], [24, 48, 24, 48], [48, 48, 24, 48], [72, 48, 24, 48], [96, 48, 24, 48], [120, 48, 24, 48], [144, 48, 24, 48], [168, 48, 24, 48]
]);
ds_map_add(action_sprite_body, "snowshovel", spr_player_body_snowshovel);
ds_map_add(action_sprite_color, "snowshovel", spr_player_colour_snowshovel);
ds_map_add(action_anim_speed, "snowshovel", 0.1); // ~5 FPS

// Throw (8 frames, 24x24, y=312 in spr_player_body - adjust if needed)
ds_map_add(action_frame_data, "throw", [
    [0, 0, 24, 24], [24, 0, 24, 24], [48, 0, 24, 24], [72, 0, 24, 24],
    [96, 0, 24, 24], [120, 0, 24, 24], [144, 0, 24, 24], [168, 0, 24, 24]
]);
ds_map_add(action_sprite_body, "throw", spr_throwsnowball_body);
ds_map_add(action_sprite_color, "throw", spr_throwsnowball_colour);
ds_map_add(action_anim_speed, "throw", 0.25); // ~2 FPS

// Debugging
show_debug_message("obj_player: Initialized. Driving state: " + string(driving));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player
File: Draw_0.gml
if (!variable_global_exists("equipped_items") || !ds_exists(global.equipped_items, ds_type_map)) {
    show_debug_message("WARNING: global.equipped_items is missing or not a ds_map. Reinitializing.");
    global.equipped_items = ds_map_create();
    ds_map_add(global.equipped_items, "head", -1);
    ds_map_add(global.equipped_items, "face", -1);
    ds_map_add(global.equipped_items, "neck", -1);
    ds_map_add(global.equipped_items, "body", -1);
    ds_map_add(global.equipped_items, "hand", -1);
    ds_map_add(global.equipped_items, "feet", -1);
}

var draw_x = x;
var draw_y = y;
var frame_x, frame_y, frame_width, frame_height;
var xscale = 1; // For flipping based on direction

if (action_state == "none") {
    // Walking animation
    var frame_index = floor(image_index) mod 3;
    frame_x = frame_data[face][frame_index * 4];
    frame_y = frame_data[face][frame_index * 4 + 1];
    frame_width = frame_data[face][frame_index * 4 + 2];
    frame_height = frame_data[face][frame_index * 4 + 3];
    draw_x = x - frame_width / 2;
    draw_y = y - frame_height / 2;
	
	// Draw the walking sprite (body and colored overlay)
    draw_sprite_part_ext(sprite_body, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, c_white, 1);
    draw_sprite_part_ext(sprite_color, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, global.player_color, 1);
} else {
    // Special actions (including throw)
    var frames = ds_map_find_value(action_frame_data, action_state);
    var frame_count = array_length(frames);
    var frame_index = floor(image_index) mod frame_count;
    var frame_data_array = frames[frame_index];
    if (action_state == "sit") {
        // Static sitting frame based on direction
        var sit_frame_map = [6, 4, 2, 0, 7, 5, 1, 3]; // RIGHT=0 maps to RIGHT=6, etc.
        frame_index = clamp(sit_frame_map[face], 0, frame_count - 1);
        show_debug_message("Face: " + string(face) + ", Sitting Frame: " + string(frame_index));
    } else {
        // Animated actions (dance, wave, jackhammer, snowshovel, throw)
        frame_index = floor(image_index) mod frame_count;
    }
    // Access the sub-array for the current frame
    frame_x = frame_data_array[0];
    frame_y = frame_data_array[1];
    frame_width = frame_data_array[2];
    frame_height = frame_data_array[3];
    
    // Get sprites for current action
    var current_sprite_body = ds_map_find_value(action_sprite_body, action_state);
    var current_sprite_color = ds_map_find_value(action_sprite_color, action_state);
    
    // Calculate drawing position
    var draw_x = x - (frame_width / 2 * xscale);
    var draw_y = y - frame_height / 2;
    
    // Flip sprite for left-facing directions
    if (face == LEFT || face == UP_LEFT || face == DOWN_LEFT) {
        xscale = -1;
    } else {
        xscale = 1;
    }
    
    // Draw body and color overlay
    draw_sprite_part_ext(current_sprite_body, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, c_white, 1);
    draw_sprite_part_ext(current_sprite_color, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, global.player_color, 1);
}

// Draw equipped items
if (ds_exists(global.equipped_items, ds_type_map) && ds_exists(global.item_sprite_map, ds_type_map)) {
    // Head item
    var head_item = global.equipped_items[? "head"];
    if (!is_undefined(head_item) && head_item != -1) {
        var sprite = ds_map_find_value(global.item_sprite_map, head_item);
        if (!is_undefined(sprite)) {
            draw_sprite(sprite, face, x, y - 12); // Offset for head
        }
    }
    // Face item
    var face_item = global.equipped_items[? "face"];
    if (!is_undefined(face_item) && face_item != -1) {
        var sprite = ds_map_find_value(global.item_sprite_map, face_item);
        if (!is_undefined(sprite)) {
            draw_sprite(sprite, face, x, y - 6); // Offset for face
        }
    }
    // Body item
    var body_item = global.equipped_items[? "body"];
    if (!is_undefined(body_item) && body_item != -1) {
        var sprite = ds_map_find_value(global.item_sprite_map, body_item);
        if (!is_undefined(sprite)) {
            draw_sprite(sprite, face, x, y); // Offset for body
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player
File: Step_0.gml
if (global.is_game_paused) {
    exit;
}

if (global.is_game_paused && instance_exists(obj_inventory_expanded)) {
    if (action_state != "none") {
        var frames = ds_map_find_value(action_frame_data, action_state);
        if (!is_undefined(frames)) {
            image_speed = ds_map_find_value(action_anim_speed, action_state);
            image_index += image_speed;
            var frame_count = array_length(frames);
            if (image_index >= frame_count) image_index = 0;
        } else {
            show_debug_message("Error: No frame data for action_state " + action_state);
            action_state = "none";
        }
    } else {
        image_index += 0.15;  // Walking animation
        if (image_index >= 3) image_index = 0;
    }
} else if (global.is_game_paused) {
    exit;
}

if (instance_exists(obj_inventory)) { if (has_item("Wrench")) {} }

if (global.is_pause_menu_active) { exit; }

// Handle special actions (only when not driving)
if (!driving && action_state == "none") {
    if (keyboard_check_pressed(ord("H"))) {  // H for Dance
        action_state = "dance";
        action_timer = 0;
        action_duration = 224;  // 56 frames * 4 steps per frame (at 0.25 speed)
        image_index = 0;
        show_debug_message("Starting dance");
    }
    else if (keyboard_check_pressed(ord("J"))) {  // J for Wave
        action_state = "wave";
        action_timer = 0;
        action_duration = 80;  // 16 frames * 5 steps per frame (at 0.2 speed)
        image_index = 0;
        show_debug_message("Starting wave");
    }
    else if (keyboard_check_pressed(ord("K"))) {  // K for Sit
        action_state = "sit";
        action_timer = 0;
        action_duration = -1;  // Infinite until toggled off
        image_index = 0;
        image_speed = 0;       // Static sitting pose
        sit_delay = 5;         // 5-frame delay before toggle-off is allowed
        show_debug_message("Starting sit");
	    }
	}
    else if (keyboard_check_pressed(ord("B"))) {  // B for Jackhammer
        if (instance_exists(obj_inventory) && obj_inventory.has_item("Jackhammer")) {
            action_state = "jackhammer";
            action_timer = 0;
            action_duration = 150;  // 50 frames * 3 steps per frame (at 0.3 speed)
            image_index = 0;
            show_debug_message("Starting jackhammer");
        } else {
            show_debug_message("Cannot start jackhammer: Jackhammer not in inventory.");
        }
    }
    else if (keyboard_check_pressed(ord("N"))) {  // N for Snow Shovel
        if (instance_exists(obj_inventory) && obj_inventory.has_item("Snow Shovel")) {
            action_state = "snowshovel";
            action_timer = 0;
            action_duration = 80;  // 16 frames * 5 steps per frame (at 0.2 speed)
            image_index = 0;
            show_debug_message("Starting snow shovel");
        } else {
            show_debug_message("Cannot start snow shovel: Snow Shovel not in inventory.");
        }
    }
    else if (keyboard_check_pressed(ord("O"))) {
	    action_state = "throw";
	    action_timer = 0;
	    action_duration = 24; // Total number of frames in throw animation
	    image_index = 0;
	    image_speed = ds_map_find_value(action_anim_speed, "throw");
	    show_debug_message("Starting throw");

        // Set xscale based on facing direction (your logic)
        xscale = (face == LEFT || face == UP_LEFT || face == DOWN_LEFT) ? -1 : 1;

        // Create snowball projectile
        var snowball = instance_create_layer(x, y, "Instances", obj_snowball);
        switch (face) {
            case RIGHT: snowball.direction = 0; break;
            case LEFT: snowball.direction = 180; break;
            case UP: snowball.direction = 90; break;
            case DOWN: snowball.direction = 270; break;
            case UP_RIGHT: snowball.direction = 45; break;
            case UP_LEFT: snowball.direction = 135; break;
            case DOWN_RIGHT: snowball.direction = 315; break;
            case DOWN_LEFT: snowball.direction = 225; break;
        }
    }


// Manage all special actions
// Handle special actions like throw
if (action_state != "none") {
    image_speed = ds_map_find_value(action_anim_speed, action_state); // Speed for this action
    image_index += image_speed;
    var frames = ds_map_find_value(action_frame_data, action_state);  // Frame data for the action
    var frame_count = array_length(frames);                          // Total frames in the action
    
    if (image_index >= frame_count) {
        action_state = "none";  // Reset to idle
        image_index = 0;        // Reset animation
        image_speed = 0;        // Stop animation
        show_debug_message("Action completed");
    }
    xspd = 0;  // Prevent movement during action
    yspd = 0;
}


// Handle existing interactions (only when not in an action)
if (action_state == "none") {
    if (keyboard_check_pressed(ord("R"))) { // Repair Ice Truck
        if (place_meeting(x, y, obj_icetruck_broken) && 
            (obj_inventory.has_item("Wrench") || obj_inventory.has_item("Battery"))) {
            show_debug_message("Repairing ice truck...");
            if (obj_inventory.has_item("Battery")) {
                show_debug_message("DEBUG: Battery detected in inventory. Attempting to remove...");
                obj_inventory.remove_item("Battery");
            }
            show_debug_message("Battery removed after repair.");
            with (instance_place(x, y, obj_icetruck_broken)) instance_destroy();
            instance_create_layer(x, y, "Instances", obj_icetruck);
            show_debug_message("Ice truck repaired!");
        }
    }

    if (keyboard_check_pressed(ord("T"))) { // Enter/Exit Tube
        if (instance_exists(obj_controller)) {
            if (global.current_skin == "player" && obj_inventory.has_item("Tube")) {
                obj_controller.switch_skin("tube");
                show_debug_message("Entered tube mode.");
            } else if (global.current_skin == "tube") {
                obj_controller.switch_skin("player");
                show_debug_message("Exited tube mode.");
            }
        } else {
            show_debug_message("ERROR: obj_controller not found for tube switch.");
        }
    }
    
    if (keyboard_check_pressed(ord("T"))) { // Enter/Exit Toboggan
        if (instance_exists(obj_controller)) {
            if (global.current_skin == "player" && obj_inventory.has_item("Toboggan")) {
                obj_controller.switch_skin("toboggan");
                show_debug_message("Entered toboggan mode.");
            } else if (global.current_skin == "toboggan") {
                obj_controller.switch_skin("player");
                show_debug_message("Exited toboggan mode.");
            }
        } else {
            show_debug_message("ERROR: obj_controller not found for Toboggan switch.");
        }
    }

    if (keyboard_check_pressed(ord("E"))) { // Enter/Exit Ice Truck
        var truck_nearby = instance_exists(obj_icetruck) && distance_to_object(obj_icetruck) < 16;
        if (instance_exists(obj_controller)) {
            if (truck_nearby && global.current_skin == "player") {
                obj_controller.switch_skin("icetruck");
            } else if (global.current_skin == "icetruck") {
                obj_controller.switch_skin("player");
            }
        } else {
            show_debug_message("ERROR: obj_controller not found for ice truck switch.");
        }
    }

    if (instance_exists(obj_inventory)) { if (obj_inventory.has_item("Fishing Rod")) {} }
}

// Player interaction (Press "E" near puffle)
if (distance_to_object(global.player_instance) < 24 && keyboard_check_pressed(ord("E"))) {
    if (state == PuffleState.IDLE) {
        if (obj_inventory.has_item("Puffle O") || obj_inventory.has_item("Box Puffle O")) {
            state = PuffleState.EATING;
            idle_timer = 0;
            persistent = true;
            if (obj_inventory.has_item("Puffle O")) {
                obj_inventory.remove_item("Puffle O");
            } else {
                obj_inventory.remove_item("Box Puffle O");
            }
            show_debug_message("Puffle is eating.");
        } else {
            show_debug_message("Player needs a Puffle O or Box Puffle O's to befriend the puffle.");
        }
    } else if (state == PuffleState.EATING) {
        show_debug_message("Puffle is currently eating. Try again later.");
    } else if (state != PuffleState.FOLLOWING) {
        state = PuffleState.FOLLOWING;
        show_debug_message("Puffle befriended and now following player.");
    } else {
        show_debug_message("Puffle is already following you.");
    }
}

// Handle movement (only when not in an action)
if (action_state == "none") {
    var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
    var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
    var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
    var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

    if (!sliding) {
        xspd = (right_key - left_key) * move_spd;
        yspd = (down_key - up_key) * move_spd;
    } else {
        xspd = slide_dir_x * slide_speed;
        yspd = slide_dir_y * slide_speed;
        slide_speed *= 0.98;
        if (abs(slide_speed) < 0.1) { sliding = false; xspd = 0; yspd = 0; }
    }

    if (instance_exists(obj_pauser)) { xspd = 0; yspd = 0; }

    if (yspd < 0) {
        if (xspd < 0) { face = UP_LEFT; } else if (xspd > 0) { face = UP_RIGHT; } else { face = UP; }
    } else if (yspd > 0) {
        if (xspd < 0) { face = DOWN_LEFT; } else if (xspd > 0) { face = DOWN_RIGHT; } else { face = DOWN; }
    } else {
        if (xspd > 0) { face = RIGHT; } else if (xspd < 0) { face = LEFT; }
    }

    xspd = handle_collision("x", xspd);
    yspd = handle_collision("y", yspd);
    if (irandom(1) == 0) {
        x += handle_collision("x", xspd * move_spd);
        y += handle_collision("y", yspd * move_spd);
    } else {
        y += handle_collision("y", yspd * move_spd);
        x += handle_collision("x", xspd * move_spd);
    }

    if (xspd != 0 || yspd != 0) { image_speed = 0.15; } else { image_speed = 0; image_index = 0; }
    if (image_index >= 3) { image_index = 0; }
}

var is_sled_room = (room == rm_sled_racing);
if (is_sled_room) {
    if (instance_exists(obj_player)) {
        with (obj_player) {
            visible = false; // Hide the inventory
        }
        show_debug_message("DEBUG: Player hidden in Sled Racing room.");
    }
} else {
    if (instance_exists(obj_player)) {
        with (obj_player) {
            visible = true; // Show the inventory
        }
    }
}

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_base
File: Destroy_0.gml
global.player_x = x;
global.player_y = y;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_base
File: Step_0.gml
// obj_player_base Step
global.player_x = x;
global.player_y = y;

xspd = handle_collision("x", xspd);
yspd = handle_collision("y", yspd);
x += xspd;
y += yspd;
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_base
File: Step_2.gml
global.player_x = x;
global.player_y = y;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_colourpicker
File: Create_0.gml
// Create Event
scale = 2; // General scale factor
panel_width = sprite_get_width(spr_colourpicker_panel) * scale;
panel_height = sprite_get_height(spr_colourpicker_panel) * scale;
x = (display_get_gui_width() - panel_width) / 2; // Center horizontally
y = (display_get_gui_height() - panel_height) / 2; // Center vertically
start_x = 100;   // Starting x position (overridden later)
depth = -10000;  // Ensure itâ€™s drawn on top
is_destroying = false; // Flag to prevent drawing after destruction



// Define colors (unchanged)
var c_notblack = make_color_rgb(51, 59, 70);
var c_bluer = make_color_rgb(41, 82, 172);
var c_brown = make_color_rgb(150, 102, 36);
var c_cyan = make_color_rgb(7, 167, 163);
var c_emerald = make_color_rgb(7, 106, 68);
var c_greener = make_color_rgb(6, 155, 77);
var c_lavender = make_color_rgb(176, 126, 194);
var c_lightblue = make_color_rgb(8, 153, 211);
var c_mint = make_color_rgb(189, 252, 201);
var c_oranger = make_color_rgb(232, 94, 28);
var c_pink = make_color_rgb(234, 20, 160);
var c_purpler = make_color_rgb(102, 49, 158);
var c_reder = make_color_rgb(210, 13, 48);
var c_salmon = make_color_rgb(233, 98, 110);
var c_yellower = make_color_rgb(234, 194, 25);

colors = [
    c_notblack, c_bluer, c_brown, c_cyan, c_emerald,
    c_greener, c_lavender, c_lightblue, c_mint, c_oranger,
    c_pink, c_purpler, c_reder, c_salmon, c_yellower
];

sprites = [
    spr_colouricon_black, spr_colouricon_blue, spr_colouricon_brown, spr_colouricon_cyan, spr_colouricon_emerald,
    spr_colouricon_green, spr_colouricon_lavendar, spr_colouricon_lightblue, spr_colouricon_mint, spr_colouricon_orange,
    spr_colouricon_pink, spr_colouricon_purple, spr_colouricon_red, spr_colouricon_salmon, spr_colouricon_yellow
];

// Grid positioning for color icons
icon_size = 20 * scale;  // Intended size of icons in pixels (e.g., 30 with scale 1.5)
spacing = 5 * scale;     // Spacing between icons
var cols = 5;
var rows = 3;
var grid_width = (cols * icon_size) + ((cols - 1) * spacing);
var grid_height = (rows * icon_size) + ((rows - 1) * spacing);
start_x = x + 108 * scale + (135 * scale - grid_width) / 2;
start_y = y + 35 * scale + (115 * scale - grid_height) / 2;

// Calculate icon_scale for proper sizing
var original_icon_width = sprite_get_width(sprites[0]); // Assuming all icons have the same size
icon_scale = icon_size / original_icon_width; // Scale to fit icon_size
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_colourpicker
File: Draw_64.gml
// Draw GUI Event
if (is_destroying) return;

draw_sprite_ext(spr_colourpicker_panel, 0, x, y, scale, scale, 0, c_white, 1);

// Define and visualize the viewer area
var viewer_x = x + 9 * scale;
var viewer_y = y + 35 * scale;
var viewer_width = (83 - 9) * scale;
var viewer_height = (150 - 35) * scale;
draw_rectangle(viewer_x, viewer_y, viewer_x + viewer_width, viewer_y + viewer_height, true); // Outline the viewer area

// Draw player sprite with debugging
if (instance_exists(global.player_instance)) {
    var player_sprite = global.player_instance.sprite_index;
    show_debug_message("Player instance exists, sprite_index: " + string(player_sprite));
    if (player_sprite != -1) {
        var sprite_scale = min(viewer_width / sprite_get_width(player_sprite), viewer_height / sprite_get_height(player_sprite));
        var x_pos = viewer_x + viewer_width / 2 - sprite_get_xoffset(player_sprite) * sprite_scale;
        var y_pos = viewer_y + viewer_height / 2 - sprite_get_yoffset(player_sprite) * sprite_scale;
        
        // Debug output
        show_debug_message("viewer_x: " + string(viewer_x) + ", viewer_y: " + string(viewer_y));
        show_debug_message("viewer_width: " + string(viewer_width) + ", viewer_height: " + string(viewer_height));
        show_debug_message("sprite_scale: " + string(sprite_scale));
        show_debug_message("x_pos: " + string(x_pos) + ", y_pos: " + string(y_pos));
        show_debug_message("sprite origin: (" + string(sprite_get_xoffset(player_sprite)) + ", " + string(sprite_get_yoffset(player_sprite)) + ")");
        
        // Draw with test parameters
        draw_sprite_ext(player_sprite, 0, x_pos, y_pos, sprite_scale, sprite_scale, 0, c_white, 1);
    } else {
        show_debug_message("Player has no sprite assigned.");
    }
} else {
    show_debug_message("Player instance does not exist.");
}

// Draw color icons with adjusted scale
for (var i = 0; i < 15; i++) {
    var col = i mod 5;
    var row = i div 5;
    var icon_x = start_x + col * (icon_size + spacing);
    var icon_y = start_y + row * (icon_size + spacing);
    draw_sprite_ext(sprites[i], 0, icon_x, icon_y, icon_scale, icon_scale, 0, c_white, 1);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_colourpicker
File: Step_0.gml
// Step Event
if (mouse_check_button_pressed(mb_left)) {
    var mx = device_mouse_x_to_gui(0);
    var my = device_mouse_y_to_gui(0);
    
    // Close area
    if (point_in_rectangle(mx, my, x + 98 * scale, y + 1 * scale, x + 156 * scale, y + 11 * scale)) {
        is_destroying = true;
        instance_destroy();
        show_debug_message("Player color picker closed.");
        global.ui_manager.close_ui();
        global.click_handled = true;
        return;
    }
    
    // Color selection
    for (var i = 0; i < 15; i++) {
        var col = i mod 5;
        var row = i div 5;
        var icon_x = start_x + col * (icon_size + spacing);
        var icon_y = start_y + row * (icon_size + spacing);
        if (point_in_rectangle(mx, my, icon_x, icon_y, icon_x + icon_size, icon_y + icon_size)) {
            global.player_color = colors[i];
            if (instance_exists(global.player_instance)) {
                global.player_instance.image_blend = global.player_color;
            }
            is_destroying = true;
            instance_destroy();
            show_debug_message("Player color set to: " + string(colors[i]));
            global.ui_manager.close_ui();
            global.click_handled = true;
            break;
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_icetruck
File: Create_0.gml
// Core variables
xspd = 0;
yspd = 0;
move_spd = 3; // Adjust as needed for ice truck speed
state = "driving"; // Since this is the ice truck, assume driving state
if (!variable_global_exists("player_color")) { global.player_color = c_white; }

// Ice truck-specific tint
icetruck_tint = c_yellow; // Default tint for spr_icetruck_colour

// Direction
face = DOWN;

// Sprite definitions
sprite_base = spr_icetruck_base;
sprite_colour = spr_icetruck_colour;
sprite_penguin = spr_icetruck_penguin_colour;
sprite_window_tint = spr_icetruck_window
mask_index = spr_icetruck_down; // Use base sprite for collisions
sprite_index = spr_icetruck_base;

// Animation variables
image_index = 0; // Current frame
image_speed = 0.1; // Animation speed (adjust as needed)

// Frame data for driving (96x240 sprite sheet: 2 frames per direction)
frame_data = array_create(8); // Array for 8 directions
// [frame1_x, frame1_y, width, height, frame2_x, frame2_y, width, height]
frame_data[DOWN] = [0, 0, 48, 48, 48, 0, 48, 48];           // Row 1
frame_data[DOWN_RIGHT] = [0, 48, 48, 48, 48, 48, 48, 48];  // Row 2
frame_data[RIGHT] = [0, 96, 48, 48, 48, 96, 48, 48];       // Row 3
frame_data[UP_RIGHT] = [0, 144, 48, 48, 48, 144, 48, 48];  // Row 4
frame_data[UP] = [0, 192, 48, 48, 48, 192, 48, 48];        // Row 5
// Left-facing directions will use right-facing frames with flipping
frame_data[DOWN_LEFT] = frame_data[DOWN_RIGHT];
frame_data[LEFT] = frame_data[RIGHT];
frame_data[UP_LEFT] = frame_data[UP_RIGHT];

// Debugging
if (place_meeting(x, y, obj_wall)) {
    show_debug_message("Icetruck colliding with wall at position (" + string(x) + ", " + string(y) + ")");
}

show_debug_message("obj_player_icetruck: Initialized.");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_icetruck
File: Draw_0.gml
var draw_x = x;
var draw_y = y;
var frame_index = floor(image_index) mod 2; // 2 frames per direction
var frame_x = frame_data[face][frame_index * 4];
var frame_y = frame_data[face][frame_index * 4 + 1];
var frame_width = frame_data[face][frame_index * 4 + 2];
var frame_height = frame_data[face][frame_index * 4 + 3];

// Determine if flipping is needed
var xscale = 1;
if (face == LEFT || face == DOWN_LEFT || face == UP_LEFT) {
    xscale = -1;
}

// Center the sprite
draw_x -= (frame_width / 2) * xscale;
draw_y -= frame_height / 2;

// Draw all three layers
draw_sprite_part_ext(sprite_base, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, c_white, 1);
draw_sprite_part_ext(sprite_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, icetruck_tint, 1);
draw_sprite_part_ext(sprite_penguin, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, global.player_color, 1);
draw_sprite_part_ext(sprite_window_tint, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, c_white, 1);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_icetruck
File: Step_0.gml
// Step Event for obj_player_icetruck
// Prevent movement when paused or colour picker is open
if (global.is_pause_menu_active || instance_exists(obj_icetruck_colourpicker) || instance_exists(obj_inventory_expanded)) {
    show_debug_message("Paused or Colour Picker Open: " + string(instance_exists(obj_icetruck_colourpicker) + instance_exists(obj_inventory_expanded)));
    exit;
}

// Handle exiting the truck
if (keyboard_check_pressed(ord("E"))) {
    if (!place_meeting(x, y, obj_icetruck)) {
        var exit_x = x;
        var exit_y = y + 16;
        instance_destroy(id);
        global.player_instance = instance_create_layer(exit_x, exit_y, "Instances", obj_player);
        instance_create_layer(x, y, "Instances", obj_icetruck);
        global.current_skin = "player";
        show_debug_message("Exited ice truck. Current skin: " + global.current_skin);
    } else {
        show_debug_message("No space to exit!");
    }
}

// Handle movement input
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

xspd = (right_key - left_key) * move_spd;
yspd = (down_key - up_key) * move_spd;

// Update direction and animation
if (xspd != 0 || yspd != 0) {
    if (yspd < 0) {
        if (xspd < 0) { face = UP_LEFT; }
        else if (xspd > 0) { face = UP_RIGHT; }
        else { face = UP; }
    } else if (yspd > 0) {
        if (xspd < 0) { face = DOWN_LEFT; }
        else if (xspd > 0) { face = DOWN_RIGHT; }
        else { face = DOWN; }
    } else {
        if (xspd > 0) { face = RIGHT; }
        else if (xspd < 0) { face = LEFT; }
    }
    image_speed = 0.1;
    image_index += image_speed;
    if (image_index >= 2) image_index = 0;
} else {
    image_speed = 0;
    image_index = 0;
}

// Apply collision handling
// Apply collision handling
if (place_meeting(x + xspd, y, obj_wall)) xspd = 0;
if (place_meeting(x, y + yspd, obj_wall)) yspd = 0;
x += handle_collision("x", xspd);
y += handle_collision("y", yspd);

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_ninja
File: Create_0.gml
// Create Event for obj_player_ninja

// Core variables
xspd = 0;
yspd = 0;
move_spd = 3;

// Sliding variables
sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;

// Driving variables
driving = false;
ice_truck_sprite = spr_icetruck_facedown;
original_sprite = sprite_index;

// Set direction and sprites
face = DOWN;
init_sprites(spr_ninja_right, spr_ninja_up, spr_ninja_left, spr_ninja_down, spr_ninja_up_right, spr_ninja_up_left, spr_ninja_down_right, spr_ninja_down_left);

// Debugging
show_debug_message("obj_player_ninja: Initialized. Driving state: " + string(driving));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_ninja
File: Step_0.gml
// Step Event for obj_player
// Prevent player movement and interactions when paused
if (global.is_pause_menu_active) {
    exit; // This prevents the player from updating while paused
}

// Handle interaction with NPC
if (keyboard_check_pressed(ord("E"))) {
    var target_npc = instance_nearest(x, y, obj_npc_old); // Find the nearest NPC
    if (target_npc != noone && distance_to_object(target_npc) < 48) { // Check proximity
        target_npc.current_phrase = target_npc.phrases[irandom_range(0, array_length(target_npc.phrases) - 1)]; // Pick a random phrase
        target_npc.talk_timer = fps * 3; // Show the phrase for 3 seconds
        target_npc.interact_pause = fps * 3; // Pause NPC movement for 3 seconds
        show_debug_message("Player interacted with NPC. NPC says: " + target_npc.current_phrase);
    }
}

// Handle skin switching
if (keyboard_check_pressed(ord("E"))) {
    if (distance_to_object(obj_icetruck) < 32) {
        show_debug_message("E key pressed");
        obj_controller.switch_skin(global.current_skin == "player" ? "icetruck" : "player");
    } else if (distance_to_object(obj_tube) < 32) {
        show_debug_message("E key pressed");
        obj_controller.switch_skin(global.current_skin == "player" ? "tube" : "player");
    }
}

// Handle movement input
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

// Get xspd & yspd
if (!sliding) {
    xspd = (right_key - left_key) * move_spd;
    yspd = (down_key - up_key) * move_spd;
} else {
    // Continue sliding
    xspd = slide_dir_x * slide_speed;
    yspd = slide_dir_y * slide_speed;

    // Decelerate slide over time
    slide_speed *= 0.98; // Adjust this value to control sliding deceleration

    // Stop sliding if speed is low enough
    if (abs(slide_speed) < 0.1) {
        sliding = false;
        xspd = 0;
        yspd = 0;
    }
}

// Pause
if (instance_exists(obj_pauser)) {
    xspd = 0;
    yspd = 0;
}

// Set sprite
mask_index = sprite[DOWN];
if (yspd < 0) {
    if (xspd < 0) { face = UP_LEFT; }
    else if (xspd > 0) { face = UP_RIGHT; }
    else { face = UP; }
} else if (yspd > 0) {
    if (xspd < 0) { face = DOWN_LEFT; }
    else if (xspd > 0) { face = DOWN_RIGHT; }
    else { face = DOWN; }
} else {
    if (xspd > 0) { face = RIGHT; }
    else if (xspd < 0) { face = LEFT; }
}

sprite_index = sprite[face];

// Collisions
xspd = handle_collision("x", xspd);
yspd = handle_collision("y", yspd);

// Move the player
x += xspd;
y += yspd;

// Animate
if (xspd == 0 && yspd == 0) {
    image_index = 0;
}

// Depth
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_toboggan
File: Create_0.gml
xspd = 0;
yspd = 0;
move_spd = 1.5; // Same as tube, adjust if desired
sliding = true;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 3;
face = DOWN;
is_savable = true;

// Define sprite positions for spr_toboggan_sheet
toboggan_sprites = array_create(8);
toboggan_sprites[DOWN] = [0, 0];
toboggan_sprites[UP] = [24, 0];
toboggan_sprites[DOWN_RIGHT] = [48, 0];
toboggan_sprites[UP_LEFT] = [72, 0];
toboggan_sprites[LEFT] = [96, 0];
toboggan_sprites[RIGHT] = [120, 0];
toboggan_sprites[UP_RIGHT] = [144, 0];
toboggan_sprites[DOWN_LEFT] = [168, 0];

mask_index = spr_tube_down; // Create this sprite if not already present
sprite_index = spr_toboggan_sheet;
global.player_instance = id;
global.current_skin = "Toboggan";
show_debug_message("obj_player_toboggan: Initialized. Player instance ID: " + string(id));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_toboggan
File: Draw_0.gml
// Draw toboggan
var toboggan_x = toboggan_sprites[face][0];
var toboggan_y = toboggan_sprites[face][1];
draw_sprite_part(spr_toboggan_sheet, 0, toboggan_x, toboggan_y, 24, 24, x - 12, y - 12);

// Draw player sitting (reusing tube positions)
var sitting_sprites = array_create(8);
sitting_sprites[DOWN] = [0, 72];
sitting_sprites[DOWN_LEFT] = [24, 72];
sitting_sprites[LEFT] = [48, 72];
sitting_sprites[UP_LEFT] = [72, 72];
sitting_sprites[UP] = [96, 72];
sitting_sprites[UP_RIGHT] = [120, 72];
sitting_sprites[RIGHT] = [144, 72];
sitting_sprites[DOWN_RIGHT] = [168, 72];
var sit_x = sitting_sprites[face][0];
var sit_y = sitting_sprites[face][1];
draw_sprite_part_ext(spr_player_body, 0, sit_x, sit_y, 24, 24, x - 12, y - 12, 1, 1, c_white, 1);
draw_sprite_part_ext(spr_player_colour, 0, sit_x, sit_y, 24, 24, x - 12, y - 12, 1, 1, global.player_color, 1);

// Draw equipped head item with debug logging
if (ds_exists(global.equipped_items, ds_type_map)) {
    var head_item = global.equipped_items[? "head"];
    if (!is_undefined(head_item) && head_item != -1) {
        // Code to draw head item, e.g., using global.item_player_sprites
        var sprite = ds_map_find_value(global.item_player_sprites, head_item);
        if (!is_undefined(sprite)) {
            draw_sprite(sprite, 0, x, y - 12); // Adjust as needed
        }
    }
} else {
    show_debug_message("global.equipped_items is not a ds_map");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_toboggan
File: Step_0.gml
if (global.is_pause_menu_active) exit;

// Exit toboggan
if (keyboard_check_pressed(ord("T"))) {
    if (global.current_skin == "toboggan" && !global.skin_switching) {
        obj_inventory.add_to_inventory("Toboggan");
        show_debug_message("Exiting toboggan, switching back to player...");
        var old_instance = id;
        obj_controller.switch_skin("player");
        if (instance_exists(old_instance)) instance_destroy(old_instance);
    }
}

// Movement input
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);
xspd = (right_key - left_key) * move_spd;
yspd = (down_key - up_key) * move_spd;

// Pause check
if (instance_exists(obj_pauser)) {
    xspd = 0;
    yspd = 0;
}

// Update direction
if (xspd != 0 || yspd != 0) {
    if (xspd > 0 && yspd == 0) face = RIGHT;
    else if (xspd < 0 && yspd == 0) face = LEFT;
    else if (yspd > 0 && xspd == 0) face = DOWN;
    else if (yspd < 0 && xspd == 0) face = UP;
    else if (xspd > 0 && yspd > 0) face = DOWN_RIGHT;
    else if (xspd > 0 && yspd < 0) face = UP_RIGHT;
    else if (xspd < 0 && yspd > 0) face = DOWN_LEFT;
    else if (xspd < 0 && yspd < 0) face = UP_LEFT;
}

// Collision handling
if (place_meeting(x + xspd, y, obj_wall)) xspd = 0;
if (place_meeting(x, y + yspd, obj_wall)) yspd = 0;

// Apply movement
if (irandom(1) == 0) {
    x += handle_collision("x", xspd * move_spd);
    y += handle_collision("y", yspd * move_spd);
} else {
    y += handle_collision("y", yspd * move_spd);
    x += handle_collision("x", xspd * move_spd);
}

// Depth sorting
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_tube
File: Create_0.gml
// Create Event for obj_player_tube

// Core variables
xspd = 0;
yspd = 0;
move_spd = 1.5;
sliding = true;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 3;

// Set direction
face = DOWN;

// Define sprite positions for the tube
tube_sprites = array_create(8);
tube_sprites[UP] = [0, 0];        
tube_sprites[LEFT] = [0, 0];      
tube_sprites[DOWN] = [24, 0];     
tube_sprites[RIGHT] = [24, 0];    
tube_sprites[UP_LEFT] = [48, 0];  
tube_sprites[DOWN_RIGHT] = [48, 0];
tube_sprites[DOWN_LEFT] = [72, 0]; 
tube_sprites[UP_RIGHT] = [72, 0];

// Ensure a valid face direction
if (!array_length(tube_sprites[face])) {
    face = DOWN; // Default if invalid
}

mask_index = spr_tube_down; // Ensure collision works

// Set global player instance
global.player_instance = id;
global.current_skin = "tube";
sprite_index = spr_tube_sheet;
is_savable = true;

// Debugging
show_debug_message("obj_player_tube: Initialized. Player instance ID: " + string(id));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_tube
File: Draw_0.gml
// Get tube sprite position
var tube_x = tube_sprites[face][0];
var tube_y = tube_sprites[face][1];

// Draw tube
draw_sprite_part(spr_tube_sheet, 0, tube_x, tube_y, 24, 24, x, y);

// Draw player sitting inside the tube
var sitting_sprites = array_create(8);
sitting_sprites[DOWN] = [0, 72];
sitting_sprites[DOWN_LEFT] = [24, 72];
sitting_sprites[LEFT] = [48, 72];
sitting_sprites[UP_LEFT] = [72, 72];
sitting_sprites[UP] = [96, 72];
sitting_sprites[UP_RIGHT] = [120, 72];
sitting_sprites[RIGHT] = [144, 72];
sitting_sprites[DOWN_RIGHT] = [168, 72];

var sit_x = sitting_sprites[face][0];
var sit_y = sitting_sprites[face][1];

// Draw player sitting
draw_sprite_part_ext(spr_player_body, 0, sit_x, sit_y, 24, 24, x, y, 1, 1, c_white, 1);
draw_sprite_part_ext(spr_player_colour, 0, sit_x, sit_y, 24, 24, x, y, 1, 1, global.player_color, 1);

// Draw equipped head item with debug logging
if (ds_exists(global.equipped_items, ds_type_map)) {
    var head_item = global.equipped_items[? "head"];
    if (!is_undefined(head_item) && head_item != -1) {
        // Code to draw head item, e.g., using global.item_player_sprites
        var sprite = ds_map_find_value(global.item_player_sprites, head_item);
        if (!is_undefined(sprite)) {
            draw_sprite(sprite, 0, x, y - 12); // Adjust as needed
        }
    }
} else {
    show_debug_message("global.equipped_items is not a ds_map");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_tube
File: Step_0.gml
// Prevent player movement and interactions when paused
if (global.is_pause_menu_active) {
    exit; // This prevents the player from updating while paused
}

// Exit the tube
if (keyboard_check_pressed(ord("T"))) {
    if (global.current_skin == "tube" && !global.skin_switching) {
        obj_inventory.add_to_inventory("Tube");
        show_debug_message("Exiting tube, switching back to player...");
        var old_instance = id; // Store old instance ID
        obj_controller.switch_skin("player");
        // Destroy old instance only after switching
        if (instance_exists(old_instance)) {
            instance_destroy(old_instance);
        }
    }
}


// Handle movement input
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

xspd = (right_key - left_key) * move_spd;
yspd = (down_key - up_key) * move_spd;

// Disable movement if the game is paused
if (instance_exists(obj_pauser)) {
    xspd = 0;
    yspd = 0;
}

// Update tube direction and sprite only if moving
if (xspd != 0 || yspd != 0) {
    if (xspd > 0 && yspd == 0) face = RIGHT;
    else if (xspd < 0 && yspd == 0) face = LEFT;
    else if (yspd > 0 && xspd == 0) face = DOWN;
    else if (yspd < 0 && xspd == 0) face = UP;
    else if (xspd > 0 && yspd > 0) face = DOWN_RIGHT;
    else if (xspd > 0 && yspd < 0) face = UP_RIGHT;
    else if (xspd < 0 && yspd > 0) face = DOWN_LEFT;
    else if (xspd < 0 && yspd < 0) face = UP_LEFT;
}

// Collision handling
if (place_meeting(x + xspd, y, obj_wall)) xspd = 0;
if (place_meeting(x, y + yspd, obj_wall)) yspd = 0;

// Apply movement
if (irandom(1) == 0) {
    x += handle_collision("x", xspd * move_spd);
    y += handle_collision("y", yspd * move_spd);
} else {
    y += handle_collision("y", yspd * move_spd);
    x += handle_collision("x", xspd * move_spd);
}

// Ensure proper depth sorting
set_depth();

var is_sled_room = (room == rm_sled_racing);
if (is_sled_room) {
    if (instance_exists(obj_player_tube)) {
        with (obj_player_tube) {
            visible = false; // Hide the inventory
        }
        show_debug_message("DEBUG: Player Tube hidden in Sled Racing room.");
    }
} else {
    if (instance_exists(obj_player_tube)) {
        with (obj_player_tube) {
            visible = true; // Show the inventory
        }
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_plaza_complete
File: Step_0.gml
set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffle
File: Create_0.gml
// Movement variables
xspd = 0;
yspd = 0;
move_spd = 2;
direction = choose(0, 45, 90, 135, 180, 225, 270, 315);
direction_timer = 120; // Change direction every 2 seconds at 60 FPS

// Animation variables
face = DOWN;
image_index = 0;
image_speed = 0.1;

// AI State System
enum PuffleState {
    IDLE,
    FOLLOWING,
    PLAYING,
    EATING
}
state = PuffleState.IDLE; // Start in IDLE for testing
idle_timer = 0;
follow_distance = 32;
is_savable = true;
persistent = false;
color = "white";
following_player = false;
player_idle_timer = 0; // Timer for player inactivity

// Eating timer
eating_timer = 0;

// Ensure collision mask
sprite_index = spr_puffle; // Set sprite for collision detection

/// Set Random Puffle Color
var color_variations = [
    make_color_rgb(255, 0, 0),    // Red
    make_color_rgb(0, 0, 255),    // Blue
    make_color_rgb(0, 255, 0),    // Green
    make_color_rgb(255, 255, 0),  // Yellow
    make_color_rgb(128, 0, 128),  // Purple
    make_color_rgb(255, 192, 203),// Pink
    make_color_rgb(255, 165, 0),  // Orange
    make_color_rgb(255, 255, 255) // White
];

// Correct way to select a random color
image_blend = color_variations[irandom(array_length(color_variations) - 1)];

prev_face = face; // Add this line
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffle
File: Draw_0.gml
var sprite_data = get_puffle_sprite_data(face);
var base_subimage = sprite_data[0];
var xscale = sprite_data[1];
var anim_frame = floor(image_index) % 8;
var final_subimage = base_subimage + anim_frame;

var col = final_subimage % 8;
var row = floor(final_subimage / 8);
var left = col * 24;
var top = row * 24;

// Adjust draw_x based on xscale to center the sprite
var draw_x = x - (12 * xscale); // Shift left for xscale=1, right for xscale=-1
var draw_y = y - 12;

draw_sprite_part_ext(spr_puffle_walk, 0, left, top, 24, 24, draw_x, draw_y, xscale, 1, image_blend, 1);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffle
File: Other_4.gml
// Room Start Event for obj_puffle
if (following_player && variable_global_exists("player_instance") && instance_exists(global.player_instance)) {
    // Position puffle 16 pixels offset from player based on player's facing direction
    var offset_dist = 16;
    var offset_dir;
    switch (global.player_instance.face) {
        case RIGHT: offset_dir = 0; break;
        case LEFT: offset_dir = 180; break;
        case UP: offset_dir = 90; break;
        case DOWN: offset_dir = 270; break;
        default: offset_dir = 270; // Default to below player
    }
    x = global.player_instance.x + lengthdir_x(offset_dist, offset_dir);
    y = global.player_instance.y + lengthdir_y(offset_dist, offset_dir);

    // Prevent overlap with walls
    if (place_meeting(x, y, obj_wall)) {
        x = global.player_instance.x;
        y = global.player_instance.y;
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffle
File: Step_0.gml
// Exit if paused
if (global.is_pause_menu_active) exit;

// Ensure player_instance is valid
if (!instance_exists(global.player_instance)) {
    global.player_instance = instance_find(obj_player, 0);
    if (!instance_exists(global.player_instance)) {
        show_debug_message("Warning: No player instance found!");
        exit;
    }
}

// Player interaction: Feeding the puffle
if (distance_to_object(global.player_instance) < 24 && keyboard_check_pressed(ord("E"))) {
    if (!following_player) {
        if (obj_inventory.has_item("Puffle O") || obj_inventory.has_item("Box Puffle O")) {
            state = PuffleState.EATING;
            var dir_to_player = point_direction(x, y, global.player_instance.x, global.player_instance.y);
            var angle = round(dir_to_player / 45) % 8;
            var face_map = [RIGHT, UP_RIGHT, UP, UP_LEFT, LEFT, DOWN_LEFT, DOWN, DOWN_RIGHT];
            face = face_map[angle];
            eating_timer = 60;
            if (obj_inventory.has_item("Puffle O")) {
                obj_inventory.remove_item("Puffle O");
            } else {
                obj_inventory.remove_item("Box Puffle O");
            }
            show_debug_message("Puffle is eating.");
        } else {
            show_debug_message("Player needs a Puffle O or Box Puffle O to befriend the puffle.");
        }
    }
}

// Debugging state
//show_debug_message("Puffle state: " + string(state) + ", Position: (" + string(x) + ", " + string(y) + ")");

// New variable for player inactivity timer (initialized in Create event if not present)
if (!variable_instance_exists(id, "player_idle_timer")) player_idle_timer = 0;

// State-specific logic
switch (state) {
    case PuffleState.IDLE:
        xspd = 0;
        yspd = 0;
        idle_timer += 1;
        if (idle_timer >= 120) {
            var idle_behavior = choose("bounce", "roll", "look_around");
            if (idle_behavior == "bounce") {
                y -= 2;
                alarm[0] = 5;
            }
            if (idle_behavior == "roll") {
                image_angle += choose(-5, 5);
            }
            if (idle_behavior == "look_around") {
                face = choose(RIGHT, LEFT, UP, DOWN);
            }
            idle_timer = 0;
        }
        // Check if player starts moving again
        if (following_player && point_distance(0, 0, global.player_instance.xspd, global.player_instance.yspd) > 0.5) {
            state = PuffleState.FOLLOWING;
            player_idle_timer = 0;
            show_debug_message("Puffle resumes following player.");
        }
        break;

    case PuffleState.PLAYING:
        if (direction_timer <= 0 || place_meeting(x + xspd, y, obj_wall) || place_meeting(x, y + yspd, obj_wall)) {
            direction = choose(0, 45, 90, 135, 180, 225, 270, 315);
            direction_timer = 120;
        }
        xspd = lengthdir_x(move_spd, direction);
        yspd = lengthdir_y(move_spd, direction);
        direction_timer -= 1;
        break;

    case PuffleState.FOLLOWING:
        if (instance_exists(global.player_instance)) {
            // Target a position behind the player with some randomness
            var base_dist = 24; // Increased distance for looser following
            var offset_dir = (global.player_instance.face + 180) % 360; // Opposite of player's facing
            var random_offset = irandom_range(-8, 8); // Add natural variation
            var target_x = global.player_instance.x + lengthdir_x(base_dist, offset_dir) + random_offset;
            var target_y = global.player_instance.y + lengthdir_y(base_dist, offset_dir) + random_offset;
            var dist = point_distance(x, y, target_x, target_y);

            if (dist > 12) { // Minimum distance to start moving
                var dir = point_direction(x, y, target_x, target_y);
                var move_x = lengthdir_x(move_spd, dir);
                var move_y = lengthdir_y(move_spd, dir);
                xspd = lerp(xspd, move_x, 0.15); // Slightly higher acceleration for responsiveness
                yspd = lerp(yspd, move_y, 0.15);
            } else {
                xspd = lerp(xspd, 0, 0.3); // Faster deceleration when close
                yspd = lerp(yspd, 0, 0.3);
            }

            // Check if player is stationary
            if (point_distance(0, 0, global.player_instance.xspd, global.player_instance.yspd) < 0.1) {
                player_idle_timer += 1;
                if (player_idle_timer >= 180) { // 3 seconds at 60 FPS
                    state = PuffleState.IDLE;
                    player_idle_timer = 0;
                    show_debug_message("Puffle switched to idle state.");
                }
            } else {
                player_idle_timer = 0; // Reset timer if player moves
            }
        } else {
            xspd = 0;
            yspd = 0;
        }
        break;

    case PuffleState.EATING:
        xspd = 0;
        yspd = 0;
        if (eating_timer > 0) {
            eating_timer -= 1;
        } else {
            state = PuffleState.FOLLOWING;
            following_player = true;
            persistent = true;
            ds_list_add(global.following_puffles, id);
            show_debug_message("Puffle finished eating and is now following player.");
        }
        break;
}

// Collision Handling with Obstacle Avoidance
var old_x = x;
var old_y = y;
x += xspd;
if (place_meeting(x, y, obj_wall)) {
    x = old_x; // Revert x movement
    y += yspd;
    if (place_meeting(x, y, obj_wall)) {
        y = old_y; // Revert y movement
        // Try sliding around obstacle
        var slide_dir = point_direction(x, y, global.player_instance.x, global.player_instance.y) + choose(-90, 90);
        xspd = lengthdir_x(move_spd * 0.5, slide_dir);
        yspd = lengthdir_y(move_spd * 0.5, slide_dir);
    } else {
        // y movement succeeded, adjust xspd to avoid sticking
        xspd = lerp(xspd, 0, 0.2);
    }
} else {
    y += yspd;
    if (place_meeting(x, y, obj_wall)) {
        y = old_y; // Revert y if stuck
        xspd = lerp(xspd, 0, 0.2); // Slow down to prevent sticking
    }
}

// Animation Handling
if (xspd != 0 || yspd != 0) {
    var angle = point_direction(0, 0, xspd, yspd);
    var dir_index = round(angle / 45) % 8;
    var face_map = [RIGHT, UP_RIGHT, UP, UP_LEFT, LEFT, DOWN_LEFT, DOWN, DOWN_RIGHT];
    var new_face = face_map[dir_index];
    if (new_face != prev_face) {
        image_index = 0;  // Reset animation when direction changes
        prev_face = new_face;
    }
    face = new_face;
    image_speed = 0.15;
} else {
    image_speed = 0;
}
image_index += image_speed;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffleo_item
File: Create_0.gml
event_inherited();
item_name = "Puffle O";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pufflewhistle_item
File: Create_0.gml
event_inherited();
item_name = "Puffle Whistle";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_repair_ui
File: Create_0.gml
// Create Event for obj_repair_ui
visible = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_repair_ui
File: Draw_64.gml
// Draw GUI Event for obj_repair_ui
if (visible) {
    var ui_x = camera_get_view_x(view_camera[0]) + 20;
    var ui_y = camera_get_view_y(view_camera[0]) + 20;

    draw_set_color(c_white);
    draw_rectangle(ui_x, ui_y, ui_x + 150, ui_y + 50, false);
    draw_set_color(c_black);
    draw_text(ui_x + 10, ui_y + 10, "Press 'E' to Repair");

    // Draw required materials
    for (var i = 0; i < 3; i++) {
        draw_sprite(spr_inventory_items, 7 + i, ui_x + 10 + (i * 20), ui_y + 30);
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_repair_ui
File: Step_0.gml
// Step Event for obj_repair_ui
var b = instance_nearest(global.player_instance.x, global.player_instance.y, obj_building);

if (b != noone && distance_to_object(b) < 32 && b.repair_stage == 0) {
    visible = true;
} else {
    visible = false;
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_rocks
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_settings
File: CleanUp_0.gml
//font_delete(global.font_main);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_settings
File: Create_0.gml
global.font_main = fnt_bumbastika_sml;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sidewalk
File: Step_0.gml
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_signpost
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_signpostalt
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skilift
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpicker
File: Create_0.gml
depth = -1000; // Ensuring the skin picker is in front of everything

// Menu dimensions
menu_width = 109;
menu_height = 72;

// Position the skin picker around the current player instance or center it in the view
if (instance_exists(global.player_instance)) {
    x = global.player_instance.x - menu_width / 2;
    y = global.player_instance.y - menu_height / 2;
} else {
    x = view_xview[0] + (view_wview[0] - menu_width) / 2;
    y = view_yview[0] + (view_hview[0] - menu_height) / 2;
}

// Ensure the global skins array exists
if (!variable_global_exists("skins")) {
    global.skins = [
        {object: obj_player_icetruck, name: "Ice Truck"},
        {object: obj_player, name: "Penguin"},
        {object: obj_player_tube, name: "Tube"}
    ];
}

// Button properties
var button_width = 37.5; 
var button_height = 10; 
var button_padding = 2.5; 
var button_x = x + (menu_width - button_width) / 2; 
var button_y = y + button_padding; 

// Create buttons for each skin
for (var i = 0; i < array_length(global.skins); i++) {
    var skin = global.skins[i];
    var btn_skin = instance_create_layer(button_x, button_y, "Instances", obj_skinpickerbutton); // Reference obj_skinpickerbutton
    btn_skin.skin_object = skin.object; // Set the object to switch to
    btn_skin.skin_name = skin.name;    // Set the button label

    // Scale buttons
    btn_skin.image_xscale = button_width / sprite_get_width(spr_button);
    btn_skin.image_yscale = button_height / sprite_get_height(spr_button);

    button_y += button_height + button_padding; // Position the next button
}

// Create a Close button
var btn_close = instance_create_layer(button_x, button_y, "Instances", obj_skinpickerbutton);
btn_close.skin_object = noone; // No skin switch, just close
btn_close.skin_name = "Close"; 
btn_close.sprite_index = spr_button;

// Scale the Close button
btn_close.image_xscale = button_width / sprite_get_width(spr_button);
btn_close.image_yscale = button_height / sprite_get_height(spr_button);



Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpicker
File: Destroy_0.gml
// Destroy all button instances when the skin picker menu is destroyed
with (obj_skinpickerbutton) {
    instance_destroy(); // Destroy all buttons linked to this menu
}
shader_reset(); // Reset the shader to remove the blur effect

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpicker
File: Draw_0.gml
// Draw Event for obj_skinpicker
//if (shader_is_compiled(shd_blur)) {
    // Apply blur shader
//    var tex = surface_get_texture(application_surface);
//    shader_set(shd_blur);
 //   shader_set_uniform_i(shader_get_uniform(shd_blur, "texture"), tex);
//    draw_surface(application_surface, 0, 0);
//    shader_reset();
//}

// Draw the skin picker menu
draw_self();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpicker
File: KeyPress_80.gml
show_debug_message("Buttons left: " + string(instance_number(obj_skinpickerbutton)));
show_debug_message("Skinpickers left: " + string(instance_number(obj_skinpicker)));
show_debug_message("Skin picker buttons: " + string(instance_number(obj_skinpickerbutton)));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpickerbutton
File: Create_0.gml
depth = -1010; // Ensure buttons are in front of the skin picker

// Initialize button-specific variables
skin_object = noone; // The skin this button switches to
skin_name = "";      // The name displayed on the button

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpickerbutton
File: Draw_0.gml
// Draw Event for obj_button
draw_self(); // Draw the button sprite

// Draw the button text
draw_set_color(c_black); // Set text color to black
draw_set_halign(fa_center); // Center text horizontally
draw_set_valign(fa_middle); // Center text vertically

var button_width = sprite_width * image_xscale;
var button_height = sprite_height * image_yscale;

var text_x = x + button_width / 2;
var text_y = y + button_height / 2;

draw_text(text_x, text_y, skin_name); // Center the text
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpickerbutton
File: Mouse_4.gml
if (skin_object != noone) {
    obj_controller.switch_skin(skin_name);
}

// Destroy the skin picker menu if a valid skin was selected
if (skin_object != noone) {
    with (obj_skinpicker) {
        instance_destroy();
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_player
File: Create_0.gml
xspd = 0;
yspd = 0; // No vertical movement
move_spd = 5; // Adjust speed as needed
lives = 3; // Start with 3 lives
global.game_started = true; // Game starts immediately
game_timer = 10 * 60; // 10 seconds timer (assuming 60 FPS)
collision_cooldown = 0; // To prevent multiple hits quickly
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_player
File: Draw_0.gml
// Draw Event for obj_sled_player

draw_self(); // Draw the player sprite

if (global.game_started) {
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    draw_set_color(c_black);
    draw_text(10, 10, "Lives: " + string(lives));
    draw_text(10, 30, "Time: " + string(ceil(game_timer / 60))); // Display in seconds
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_player
File: Other_4.gml
// Room Start Event for obj_sled_player
global.player_instance = id;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_player
File: Step_0.gml
// Step Event for obj_sled_player

if (global.game_started) {
    game_timer -= 1; // Decrement timer each frame

    // Horizontal movement
    if (keyboard_check(vk_left) || keyboard_check(ord("A"))) {
        x -= move_spd; // Move left
    } 
    if (keyboard_check(vk_right) || keyboard_check(ord("D"))) {
        x += move_spd; // Move right
    }

    // Prevent movement outside room boundaries
    x = clamp(x, 0, room_width - sprite_width);
}
    // Check for collision with obstacles
if (global.game_started) {
    // Collision detection with cooldown
    if (collision_cooldown <= 0 && place_meeting(x, y, obj_obstacle)) {
        show_debug_message("Collision with obstacle!");
        lives -= 1; // Deduct one life
        collision_cooldown = 30; // Set cooldown (0.5 seconds at 60 FPS)
        // Optional: Add sound effect or visual feedback here
    } else {
        collision_cooldown -= 1; // Decrement cooldown
    }

    // Win condition: Survive 10 seconds with lives remaining
    if (game_timer <= 0 && lives > 0) {
        global.last_player_x = 55; // Set position for rm_ski_village
        global.last_player_y = 235;
        switch_skin("player"); // Switch back to obj_player
        room_goto(rm_ski_village); // Transition to rm_ski_village
    }

    // Lose condition: No lives remaining
    if (lives <= 0) {
        global.last_player_x = 245; // Set position for rm_ski_mountaintop
        global.last_player_y = 120;
        switch_skin("player"); // Switch back to obj_player
        room_goto(rm_ski_mountaintop); // Transition to rm_ski_mountaintop
    }
}


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_slippery
File: Create_0.gml
xspd = 0;
yspd = 0;

sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_slippery
File: Step_0.gml
if (place_meeting(x, y, obj_player) || place_meeting(x, y, obj_player_tube)) {
    if (!sliding) {
        sliding = true;
        
        // Get the player's last movement direction
        var player = instance_nearest(x, y, obj_player); // Get closest player
        if (!instance_exists(player)) player = instance_nearest(x, y, obj_player_tube);

        if (instance_exists(player)) {
            slide_dir_x = sign(player.xspd);
            slide_dir_y = sign(player.yspd);
            slide_speed = max(abs(player.xspd), abs(player.yspd)); // Carry over momentum
        }
    }
}

// **Sliding Deceleration Logic**
if (sliding) {
    x += slide_dir_x * slide_speed;
    y += slide_dir_y * slide_speed;

    // Reduce speed gradually
    slide_speed *= 0.95; 

    // Stop sliding when slow enough
    if (slide_speed < 0.1) {
        sliding = false;
        slide_speed = 0;
    }

    // **Collision Handling (Bounce Effect)**
    if (place_meeting(x + slide_dir_x * slide_speed, y, obj_wall)) {
        slide_dir_x = -slide_dir_x; // Reverse direction on X collision
        slide_speed *= 0.7; // Reduce speed slightly when bouncing
    }
    
    if (place_meeting(x, y + slide_dir_y * slide_speed, obj_wall)) {
        slide_dir_y = -slide_dir_y; // Reverse direction on Y collision
        slide_speed *= 0.7;
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_small_bushes
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_small_trees
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sml_boat
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowball
File: Create_0.gml
direction = 0;
speed = 3;
image_speed = 0;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowball
File: Draw_0.gml
draw_self();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowball
File: Step_0.gml
x += lengthdir_x(speed, direction);
y += lengthdir_y(speed, direction);

// Check for collision with walls or out of bounds
if (place_meeting(x, y, obj_wall) || x < 0 || x > room_width || y < 0 || y > room_height) {
    instance_destroy();
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowblaster_item
File: Create_0.gml
event_inherited();
item_name = "Snow Blaster";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowforts
File: Step_0.gml
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowshovel_item
File: Create_0.gml
event_inherited();
item_name = "Snow Shovel";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snow_item
File: Create_0.gml
event_inherited();
item_name = "Snow";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_spyphone_item
File: Create_0.gml
event_inherited();
item_name = "Spy Phone";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_stampbook_item
File: Create_0.gml
event_inherited();
item_name = "Stamp Book";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_starterdeck_item
File: Create_0.gml
event_inherited();
item_name = "Starter Deck";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tall_bush
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tall_trees
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_toboggan
File: Create_0.gml
item_name = "Toboggan";
face = DOWN;
is_savable = true;

// Define sprite positions for spr_toboggan_sheet
toboggan_sprites = array_create(8);
toboggan_sprites[DOWN] = [0, 0];         // DOWN
toboggan_sprites[UP] = [24, 0];          // UP
toboggan_sprites[DOWN_RIGHT] = [48, 0];  // DOWN_RIGHT
toboggan_sprites[UP_LEFT] = [72, 0];     // UP_LEFT
toboggan_sprites[LEFT] = [96, 0];        // LEFT
toboggan_sprites[RIGHT] = [120, 0];      // RIGHT
toboggan_sprites[DOWN_LEFT] = [144, 0];   // Same as DOWN_RIGHT, flipped in Draw
toboggan_sprites[UP_RIGHT] = [168, 0];    // Same as UP_LEFT, flipped in Draw
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_toboggan
File: Destroy_0.gml
instance_destroy(); // Destroy the current ice truck instance
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_toboggan
File: Draw_0.gml
var base_x = toboggan_sprites[face][0];
var base_y = toboggan_sprites[face][1];
var flip = (face == DOWN_LEFT || face == UP_RIGHT) ? -1 : 1;
draw_sprite_part_ext(spr_toboggan_sheet, 0, base_x, base_y, 24, 24, x - 12, y - 12, flip, 1, c_white, 1);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_toboggan
File: Step_0.gml
event_inherited();
item_name = "Toboggan";

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tourhat_item
File: Create_0.gml
event_inherited();
item_name = "Tour Hat";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tour_booth
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_town_complete
File: Step_0.gml
set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube
File: Create_0.gml
item_name = "Tube";

// Core variables
face = DOWN;

// Assign sprite sheet directions (indices for spr_tube_sheet)
tube_sprites = array_create(8);
tube_sprites[UP] = [0, 0];        // UP, LEFT
tube_sprites[LEFT] = [0, 0];
tube_sprites[DOWN] = [24, 0];     // DOWN, RIGHT
tube_sprites[RIGHT] = [24, 0];
tube_sprites[UP_LEFT] = [48, 0];  // UP_LEFT, DOWN_RIGHT
tube_sprites[DOWN_RIGHT] = [48, 0];
tube_sprites[DOWN_LEFT] = [72, 0]; // DOWN_LEFT, UP_RIGHT
tube_sprites[UP_RIGHT] = [72, 0];
is_savable = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube
File: Destroy_0.gml
instance_destroy(); // Destroy the current ice truck instance
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube
File: Draw_0.gml
// Get tube sprite position
var tube_x = tube_sprites[face][0];
var tube_y = tube_sprites[face][1];

// Draw tube
draw_sprite_part(spr_tube_sheet, 0, tube_x, tube_y, 24, 24, x, y);

// Draw player sitting inside the tube
var sitting_sprites = array_create(8);
sitting_sprites[DOWN] = [0, 72];
sitting_sprites[DOWN_LEFT] = [24, 72];
sitting_sprites[LEFT] = [48, 72];
sitting_sprites[UP_LEFT] = [72, 72];
sitting_sprites[UP] = [96, 72];
sitting_sprites[UP_RIGHT] = [120, 72];
sitting_sprites[RIGHT] = [144, 72];
sitting_sprites[DOWN_RIGHT] = [168, 72];

var sit_x = sitting_sprites[face][0];
var sit_y = sitting_sprites[face][1];
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube
File: Step_0.gml
event_inherited();
item_name = "Tube";

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube_tower_decoration
File: Create_0.gml
item_name = "Tube";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube_tower_decoration
File: Step_0.gml
event_inherited();
item_name = "Tube";

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui
File: Create_0.gml
// obj_ui_create.txt
// Initialize variables
ui_elements = []; // Array to store UI elements

// Example: Add a button to the UI
var button = {
    x: 100,
    y: 100,
    width: 200,
    height: 50,
    text: "Click Me",
    action: function() {
        show_message("Button Clicked!");
    }
};
array_push(ui_elements, button);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui
File: Draw_0.gml
// obj_ui_draw.txt
// Set font and alignment for UI text
draw_set_font(fnt_bumbastika_sml);
draw_set_halign(fa_center);
draw_set_valign(fa_middle);

// Draw UI elements
for (var i = 0; i < array_length(ui_elements); i++) {
    var elem = ui_elements[i];
    draw_rectangle(elem.x, elem.y, elem.x + elem.width, elem.y + elem.height, false);
    draw_text(elem.x + elem.width / 2, elem.y + elem.height / 2, elem.text);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui
File: Mouse_4.gml
// obj_ui_leftpressed.txt
// Get mouse position
var mouse_x_pos = device_mouse_x_to_gui(0);
var mouse_y_pos = device_mouse_y_to_gui(0);

// Check if any UI element is clicked
for (var i = 0; i < array_length(ui_elements); i++) {
    var elem = ui_elements[i];
    if (mouse_x_pos > elem.x && mouse_x_pos < elem.x + elem.width && mouse_y_pos > elem.y && mouse_y_pos < elem.y + elem.height) {
        // Execute the action associated with the UI element
        elem.action();
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui_manager
File: Create_0.gml
// obj_ui_manager Create Event
persistent = true; // Make persistent to stay across rooms
global.ui_manager = id;
active_ui = noone;  // Current UI instance
inventory_instance = instance_exists(obj_inventory) ? obj_inventory : instance_create_layer(0, 0, "UI", obj_inventory);
depth = -1000;  // Above all UI elements
show_debug_message("UI Manager initialized.");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui_manager
File: Step_0.gml
// obj_ui_manager Step Event
var is_ui_room = (room == rm_init || room == rm_main_menu || room == rm_map || room == rm_pause_menu || room == rm_settings_menu);
if (!is_ui_room && !global.is_pause_menu_active) {
    if (instance_exists(inventory_instance) && active_ui == noone) {
        inventory_instance.visible = true;
    }
}
if (active_ui != noone && !instance_exists(active_ui)) {
    active_ui = noone;  // Clear if destroyed
    if (instance_exists(inventory_instance)) {
        inventory_instance.visible = true;
        show_debug_message("UI Manager restored inventory visibility.");
    }
}

// Function to open UI
function open_ui(ui_object) {
    if (active_ui != noone && instance_exists(active_ui)) {
        instance_destroy(active_ui);
    }
    active_ui = instance_create_layer(0, 0, "UI", ui_object);
    show_debug_message("UI opened: " + object_get_name(ui_object));
    return active_ui;
}

// Function to close UI
function close_ui() {
    if (active_ui != noone && instance_exists(active_ui)) {
        instance_destroy(active_ui);
        active_ui = noone;
        show_debug_message("UI closed.");
        // Reactivate expanded HUD if it exists
        if (instance_exists(obj_hud_expanded)) {
            obj_hud_expanded.is_active = true;
            show_debug_message("Reactivated expanded HUD after closing UI.");
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_wall
File: Step_0.gml
set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Alarm_0.gml
/// Alarm[0] Event
global.warp_cooldown = false;
show_debug_message("DEBUG: Warp cooldown finished. Player can warp again.");

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Create_0.gml
// obj_warp: Create Event
target_rm = 0;
target_x = 0;
target_y = 0;
target_face = 0;
target_instance = noone;

global.warp_cooldown = true;
alarm[0] = room_speed / 2;

show_debug_message("obj_warp initialized. Target Room: " + string(target_rm));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Draw_0.gml
draw_sprite_tiled(sprite_index, image_index, 0, 0)
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Other_7.gml
/// Animation End Event for obj_warp
show_debug_message("DEBUG: obj_warp transition initiated. Moving player before room transition.");
global.player_instance = target_instance; // Update global instance
// Ensure the player moves before switching rooms
if (target_instance != noone) {
	global.warp_target_x = target_x;
	global.warp_target_y = target_y;
	global.warp_target_face = target_face;
    show_debug_message("Player successfully moved to new position.");
} else {
    show_debug_message("ERROR: Target instance not found during warp.");
}

// Perform the room transition
room_goto(target_rm);

// Restore camera settings
if (instance_exists(global.camera)) {
    view_set_camera(0, global.camera);
    camera_set_view_size(global.camera, 640, 480);
    show_debug_message("DEBUG: Camera viewport restored after room transition.");
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Step_0.gml
// Step Event for obj_warp
if (room == target_rm && image_index < 1) {
    instance_destroy();
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_block
File: Create_0.gml
target_rm = 0;
target_x = 0;
target_y = 0;
target_face = 0;
// Create Event for obj_warp
if (!variable_global_exists("warp_cooldown")) {
    global.warp_cooldown = false;
}



Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_block
File: Other_4.gml
// Check if a warp instance exists
if (instance_exists(obj_warp)) {
    var warp_inst = instance_find(obj_warp, 0);
    if (warp_inst != noone) {
        if (instance_exists(global.player_instance)) {
            global.player_instance.x = warp_inst.target_x;
            global.player_instance.y = warp_inst.target_y;
            // Optional: Adjust the player's facing direction
            if (is_real(warp_inst.target_face)) {
                global.player_instance.face = warp_inst.target_face;
            }
        } else {
            show_debug_message("WARNING: Player instance does not exist for warping.");
        }
        instance_destroy(warp_inst);
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_block
File: Step_0.gml
/// Step Event for obj_warp_block

// Handle Player Warping
if (instance_exists(global.player_instance) && place_meeting(x, y, global.player_instance) && !instance_exists(obj_warp)) 
{
    show_debug_message("DEBUG: obj_player detected on obj_warp_block. Warping...");
    
    var inst = instance_create_depth(0, 0, -9999, obj_warp);
    inst.target_x = self.target_x;   // Ensure correct target coordinates
    inst.target_y = self.target_y;
    inst.target_rm = self.target_rm;
    inst.target_face = self.target_face;
    inst.target_instance = global.player_instance; // Use global instance of player
	
}

// Handle Ice Truck Warping
if (instance_exists(obj_player_icetruck) && place_meeting(x, y, obj_player_icetruck) && !instance_exists(obj_warp)) 
{
    var inst = instance_create_depth(0, 0, -9999, obj_warp);
    inst.target_x = self.target_x;
    inst.target_y = self.target_y;
    inst.target_rm = self.target_rm;
    inst.target_face = obj_player_icetruck.face;
    inst.target_instance = instance_find(obj_player_icetruck, 0);

}

/// Step Event for obj_warp_block

// Handle Player Warping
if (instance_exists(global.player_instance) && place_meeting(global.player_instance.x, global.player_instance.y, id) && !instance_exists(obj_warp)) 
{
    show_debug_message("DEBUG: obj_player_tube detected on obj_warp_block. Warping...");

    var inst = instance_create_depth(0, 0, -9999, obj_warp);
    inst.target_x = self.target_x;   // Correctly assign the warp block's values
    inst.target_y = self.target_y;
    inst.target_rm = self.target_rm;
    inst.target_face = self.target_face;
    inst.target_instance = global.player_instance;

    // Debugging output to confirm correct values are passed
    show_debug_message("Warping obj_player_tube to Room: " + string(inst.target_rm) +
        " Position: (" + string(inst.target_x) + ", " + string(inst.target_y) + ") Facing: " + string(inst.target_face));
}



// Handle NPC Warping
if (instance_exists(obj_npc_old) && place_meeting(x, y, obj_npc_old) && !instance_exists(obj_warp)) 
{
    var inst = instance_create_depth(0, 0, -9999, obj_warp);
    inst.target_x = self.target_x;
    inst.target_y = self.target_y;
    inst.target_rm = self.target_rm;
    inst.target_face = obj_npc_old.face;
    inst.target_instance = instance_find(obj_npc_old, 0);

}

if (!global.warp_cooldown && instance_exists(global.player_instance) && place_meeting(global.player_instance.x, global.player_instance.y, id) && !instance_exists(obj_warp)) 
{
    var inst = instance_create_depth(0, 0, -9999, obj_warp);
    inst.target_x = self.target_x;
    inst.target_y = self.target_y;
    inst.target_rm = self.target_rm;
    inst.target_face = self.target_face;
    inst.target_instance = global.player_instance;
}


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_map
File: Create_0.gml
// obj_warp_map: Create Event
target_rm = noone;  // Set this in Creation Code
target_x = 0;  
target_y = 0;  
target_face = 0;  
depth = -9999;  // Ensure it's drawn on top
// Create Event for obj_warp
if (!variable_global_exists("warp_cooldown")) {
    global.warp_cooldown = false;
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_map
File: Mouse_4.gml
// obj_warp_map: Left Pressed Event (Handles Click to Warp)
if (target_rm != noone) {
    show_debug_message("Warping to Room: " + string(target_rm) + " at (" + string(target_x) + ", " + string(target_y) + ")");
    
    // Store last room before warping
    global.last_room = room;  
    
    // Create warp instance to handle transition
    var warp_inst = instance_create_depth(0, 0, -9999, obj_warp);
    warp_inst.target_rm = target_rm;
    warp_inst.target_x = target_x;
    warp_inst.target_y = target_y;
    warp_inst.target_face = target_face;
    warp_inst.target_instance = global.player_instance;

	global.camera_reset = true; // Ensure camera resets correctly
    // Room transition handling
    room_goto(target_rm);

    // Improved handling to check if player instance exists after room transition
    alarm[0] = 2;  // Set alarm to delay camera setup and check for player existence
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_wood_item
File: Create_0.gml
event_inherited();
item_name = "Wood";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_wrench_item
File: Step_0.gml
event_inherited();
item_name = "Wrench";
