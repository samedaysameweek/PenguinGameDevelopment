Folder: D:\PenguinIsleProject\Penguin Isles\scripts\draw_equipped_items
File: draw_equipped_items.gml
/// @function update_equipped_items_display()
/// @description Draws equipped items in their respective slots on the HUD.
function update_equipped_items_display() {
    if (!ds_exists(global.equipped_items, ds_type_map) || !ds_exists(global.item_sprite_map, ds_type_map)) {
        show_debug_message("Error: Required global maps not initialized.");
        return;
    }

    var gui_width = display_get_gui_width();
    var gui_height = display_get_gui_height();
    var slot_size = 32; // Size of each slot in pixels
    var start_x = gui_width - (6 * slot_size) - 10; // Right side, 6 slots
    var start_y = gui_height / 2 - (3 * slot_size); // Centered vertically

    var slots = ["head", "face", "neck", "body", "hand", "feet"];
    for (var i = 0; i < array_length(slots); i++) {
        var slot = slots[i];
        var item_name = ds_map_find_value(global.equipped_items, slot);
        var slot_x = start_x + (i mod 3) * slot_size;
        var slot_y = start_y + (i div 3) * slot_size;

	}
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\draw_item_card
File: draw_item_card.gml
/// @function draw_item_card(item, x, y)
/// @description Draws an item card with sprite, name, price,
/// @param {struct} item The item data to draw
/// @param {real} x The x position to draw at
/// @param {real} y The y position to draw at

function draw_item_card(item, card_x, card_y) {
    // Draw card background
    draw_set_color(c_dkgray);
    draw_rectangle(card_x, card_y, card_x + item_width, card_y + item_height, false);

    // Draw item sprite
    var sprite_scale = min((item_width - 20) / sprite_get_width(item.sprite),
                           (item_height * 0.6) / sprite_get_height(item.sprite));
    var sprite_x = card_x + item_width/2;
    var sprite_y = card_y + (item_height * 0.3);
    draw_sprite_ext(item.sprite, 0,
                    sprite_x, sprite_y,
                    sprite_scale, sprite_scale,
                    0, c_white, 1);

    // Draw item name
    draw_set_color(c_white);
    draw_set_halign(fa_center);
    draw_set_valign(fa_top);
    draw_set_font(fnt_shop_item);
    draw_text(card_x + item_width/2, card_y + item_height * 0.65, item.name);

    // Draw price
    var price_color = global.player_coins >= item.price ? c_lime : c_red;
    draw_set_color(price_color);
    draw_text(card_x + item_width/2, card_y + item_height * 0.8,
              string(item.price) + " coins");

    // Draw stock info if limited
    if (variable_struct_exists(item, "stock") && item.stock >= 0) {
        draw_set_color(c_yellow);
        draw_text(card_x + item_width/2, card_y + item_height * 0.9,
                  "Stock: " + string(item.stock));
    }

    // Draw seasonal tag if applicable
    if (variable_struct_exists(item, "seasonal") && item.seasonal) {
        draw_set_color(c_aqua);
        draw_text(card_x + item_width/2, card_y + 10, "Seasonal!");
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\equip_item
File: equip_item.gml
/// @function equip_item(slot, item_name)
/// @param {string} slot The name of the slot to equip the item to (e.g., "head", "body").
/// @param {string} item_name The name of the item to equip.
function equip_item(slot, item_name) {
    show_debug_message("Attempting to equip item: '" + item_name + "' to slot: '" + slot + "'");

    // Ensure the global map exists
    if (!ds_exists(global.equipped_items, ds_type_map)) {
        show_debug_message("ERROR: global.equipped_items map does not exist!");
        // Optionally re-initialize it here if needed, but it should be done in obj_initializer
        return;
    }

    // Ensure the slot key exists in the map
    if (ds_map_exists(global.equipped_items, slot)) {
        // Update the map with the item name
        global.equipped_items[? slot] = item_name;
        show_debug_message("Equipped '" + item_name + "' to slot '" + slot + "'.");
        // Display the current state of the map for debugging
        // show_debug_message("Current global.equipped_items: " + ds_map_write(global.equipped_items));

        // NOTE: Removed call to apply_equipped_items();
        // The player object's Draw event handles the visual update.

    } else {
        show_debug_message("ERROR: Invalid equipment slot specified: '" + slot + "'");
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\RoomStateManager
File: RoomStateManager.gml
/// @function RoomStateManager_Save()
/// @description Saves the current state of the room.
/// @param {real} room_id - ID of the room to save.
function RoomStateManager_Save(room_id) {
    var room_name = room_get_name(room_id);
    show_debug_message("[INFO] RoomStateManager: Saving state for room: " + room_name);

    if (!ds_exists(global.roomStates, ds_type_map)) {
        global.roomStates = ds_map_create();
    }

    var state_array = [];
    with (all) {
        if (variable_instance_exists(id, "is_savable") && is_savable) {
            var state_data = {
                object_index_name: object_get_name(object_index),
                x: x, y: y
            };
            array_push(state_array, state_data);
        }
    }

    if (ds_map_exists(global.roomStates, room_name)) {
        ds_map_replace(global.roomStates, room_name, state_array);
    } else {
        ds_map_add(global.roomStates, room_name, state_array);
    }

    show_debug_message("[INFO] RoomStateManager: Room state saved for: " + room_name);
    
    // Check if saved state exists for this room
    if (ds_map_exists(global.room_states, room_name)) {
        var state_array = ds_map_find_value(global.room_states, room_name);

        // Check if valid state array exists
        if (is_array(state_array)) {
            show_debug_message("Found state array for " + room_name + ". Size: " + string(array_length(state_array)));

             // --- Create instances from saved state ARRAY ---
             if (is_fresh_load) {
                  show_debug_message("Recreating instances from saved state array (Fresh Load)...");
                  for (var i = 0; i < array_length(state_array); i++) {
                         var state = state_array[i];
                         if (!is_struct(state)) { continue; }
                         if (!variable_struct_exists(state, "object_index_name")) { continue; }
                         var _obj_index_to_load = asset_get_index(state.object_index_name);
                         if (_obj_index_to_load == -1 || !object_exists(_obj_index_to_load)) { continue; }
                         if (object_is_ancestor(_obj_index_to_load, obj_player_base) || _obj_index_to_load == obj_controller || _obj_index_to_load == obj_ui_manager) {
                             show_debug_message("Load State: Skipping creation of reserved object (" + object_get_name(_obj_index_to_load) + ") found in save data.");
                             continue;
                         }

                 // Skip creating follower puffles from save state (they are persistent)
                var is_follower = (_obj_index_to_load == obj_puffle && variable_struct_exists(state, "following_player") && state.following_player);
                if (is_follower) { continue; }

                 // Create instance (Non-followers or other objects)
                        var inst = instance_create_layer(state.x, state.y, "Instances", _obj_index_to_load);
                        show_debug_message("Created instance from saved state: " + object_get_name(_obj_index_to_load));
                        if (instance_exists(inst)) { try {
                        inst.is_savable = true; // Mark loaded instance as savable

                        // Apply common properties if they exist in the struct AND the instance
                        if (variable_struct_exists(state, "face") && variable_instance_exists(inst, "face")) { inst.face = state.face; } else if(variable_instance_exists(inst, "face")) {inst.face = DOWN;} // default face if missing
                        if (variable_struct_exists(state, "image_xscale") && variable_instance_exists(inst, "image_xscale")) inst.image_xscale = state.image_xscale; else inst.image_xscale = 1;
                        if (variable_struct_exists(state, "image_yscale") && variable_instance_exists(inst, "image_yscale")) inst.image_yscale = state.image_yscale; else inst.image_yscale = 1;
                        if (variable_struct_exists(state, "image_blend") && variable_instance_exists(inst, "image_blend")) inst.image_blend = state.image_blend; else inst.image_blend = c_white;
                        if (variable_struct_exists(state, "image_alpha") && variable_instance_exists(inst, "image_alpha")) inst.image_alpha = state.image_alpha; else inst.image_alpha = 1;


                        // Object-specific properties
                        if (_obj_index_to_load == obj_icetruck || _obj_index_to_load == obj_icetruck_broken) {
                            if(variable_struct_exists(state, "icetruck_tint") && variable_instance_exists(inst,"icetruck_tint")) inst.icetruck_tint = state.icetruck_tint;
                            if(variable_struct_exists(state, "is_driveable") && variable_instance_exists(inst,"is_driveable")) inst.is_driveable = state.is_driveable;
                             // Ensure broken truck state aligns correctly
                            if (_obj_index_to_load == obj_icetruck_broken && variable_instance_exists(inst, "repair_required")) inst.repair_required = true;
                            if (_obj_index_to_load == obj_icetruck && variable_instance_exists(inst, "repair_required")) inst.repair_required = false;

                        } else if (object_get_parent(inst.object_index) == obj_pickup_item || inst.object_index == obj_dropped_item) { // General check for pickup items
                             if(variable_struct_exists(state, "item_name") && variable_instance_exists(inst,"item_name")) inst.item_name = state.item_name;
                        } else if (_obj_index_to_load == obj_puffle) { // Non-following puffles
                             if (variable_instance_exists(inst,"following_player")) inst.following_player = false;
                             if (variable_struct_exists(state, "puffle_color") && variable_instance_exists(inst,"color")) inst.color = state.puffle_color; // Apply color NAME
                             if (variable_struct_exists(state, "puffle_state") && variable_instance_exists(inst,"state")) inst.state = state.puffle_state;

                             // Apply blend from saved color name
                             if (variable_instance_exists(inst,"color")) {
                                switch (inst.color) {
                                    // Add color cases here to match names to colors
                                    case "red": inst.image_blend = make_color_rgb(255, 0, 0); break;
                                    // ... other colors ...
                                    default: inst.image_blend = c_white; break;
                                }
                             }
                        } else if (object_is_ancestor(_obj_index_to_load, obj_toboggan) || object_is_ancestor(_obj_index_to_load, obj_tube)) { // For Toboggan/Tube ITEMS
                             if(variable_struct_exists(state, "item_name") && variable_instance_exists(inst,"item_name")) inst.item_name = state.item_name;
                             if(variable_struct_exists(state, "face") && variable_instance_exists(inst,"face")) inst.face = state.face; // Restore item facing
                        }
                        // ... Add checks for other specific objects if needed ...

                         show_debug_message("Loaded " + state.object_index_name + " at (" + string(state.x) + ", " + string(state.y) + ")");

                     } catch (_err) {} }
                  }
                  show_debug_message("Finished creating instances for " + room_name + " (Fresh Load).");
            } else {
                 // If not a fresh load, we don't recreate everything from the save state,
                 // we just keep the instances that already exist in the room.
                                    show_debug_message("Normal Room Entry: Assuming instances persist or were recreated by GM.");
            }
} else {
             show_debug_message("Load State WARNING: Saved state for " + room_name + " is invalid (not an array).");
        }
    } else {
        show_debug_message("No state found for room: " + room_name + " in global.room_states.");
         // If fresh load, room is default empty. If normal entry, existing instances remain.
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_array_clone_recursive
File: scr_array_clone_recursive.gml
/// @function array_clone_recursive(source_array)
/// @description Recursively clones an array, including nested structs and arrays.
/// @param {Array} source_array The array to clone.
/// @returns {Array} A deep copy of the array.
function array_clone_recursive(source_array) {
    if (!is_array(source_array)) return source_array; // Return non-arrays as is

    var _new_array = [];
    var _len = array_length(source_array);

    for (var i = 0; i < _len; i++) {
        var _value = source_array[i];

        if (is_struct(_value)) {
            array_push(_new_array, struct_clone_recursive(_value)); // Clone nested struct
        } else if (is_array(_value)) {
            array_push(_new_array, array_clone_recursive(_value)); // Clone nested array
        } else {
            array_push(_new_array, _value); // Copy primitive
        }
    }
    return _new_array;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_array_duplicate_recursive
File: scr_array_duplicate_recursive.gml
/// @function scr_array_duplicate_recursive(source_array)
/// @description Recursively duplicates an array, including nested structs and arrays.
/// @param {Array} source_array The array to duplicate.
/// @returns {Array} A deep copy of the array.
function scr_array_duplicate_recursive(source_array) {
    if (!is_array(source_array)) return source_array; // Return non-arrays as is

    var _new_array = [];
    var _len = array_length(source_array);

    for (var i = 0; i < _len; i++) {
        var _value = source_array[i];

        if (is_struct(_value)) {
            array_push(_new_array, struct_clone(_value)); // Clone nested struct
        } else if (is_array(_value)) {
            array_push(_new_array, scr_array_duplicate_recursive(_value)); // Clone nested array
        } else {
            array_push(_new_array, _value); // Copy primitive
        }
    }
    return _new_array;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_array_to_array_recursive
File: scr_array_to_array_recursive.gml
/// @function array_to_array_recursive(source_array)
/// @description Recursively checks an array for nested DS maps/lists and converts them.
///              Clones nested structs and arrays found within.
/// @param {Array} source_array The source array to process.
/// @returns {Array} A new array with DS structures converted, or a deep clone if none found.
function array_to_array_recursive(source_array) {
	if (!is_array(source_array)) return source_array; // Return non-arrays as is

	var _new_array = [];
	var _len = array_length(source_array);

	for (var i = 0; i < _len; i++) {
		var _value = source_array[i];

        // --- REVISED LOGIC for array_to_array_recursive ---
        if (is_struct(_value)) {
            // Found a struct -> Deep Clone it
            array_push(_new_array, struct_clone_recursive(_value)); // << Clone structs
        }
		else if (is_array(_value)) {
			// Found a nested array -> Recursively process it
			array_push(_new_array, array_to_array_recursive(_value));
		}
        else if (is_real(_value)) { // Check if it *could* be a DS ID
             // Only convert if it's CONFIRMED to be a DS map/list ID
            if (ds_exists(_value, ds_type_map)) {
                 array_push(_new_array, ds_map_to_struct_recursive(_value)); // Convert map ID -> struct
            } else if (ds_exists(_value, ds_type_list)) {
                 array_push(_new_array, ds_list_to_array_recursive(_value)); // Convert list ID -> array
            } else {
                 // Just a number -> Copy it
                 array_push(_new_array, _value);
            }
        }
		else {
             // Primitive (string, bool, etc.) -> Copy it directly
			 if(is_undefined(_value)) { show_debug_message("DEBUG (array->array): Skipping undefined value at index: " + string(i)); }
             else { array_push(_new_array, _value); }
		}
        // --- END REVISED LOGIC ---
	}
	return _new_array;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_array_to_ds_list_recursive
File: scr_array_to_ds_list_recursive.gml
/// @function array_to_ds_list_recursive(array_data)
/// @description Recursively converts an Array (including nested structs/arrays) into a DS List.
/// @param {Array} array_data The Array to convert.
/// @returns {Id.DsList} A DS List representation of the array, or undefined if input is invalid.
function array_to_ds_list_recursive(array_data) {
    if (!is_array(array_data)) {
        show_debug_message("WARNING: array_to_ds_list_recursive called with non-array data: " + string(array_data));
        return undefined;
    }

    var _list = ds_list_create();
    var _len = array_length(array_data);

    for (var i = 0; i < _len; i++) {
        var _value = array_data[i];

        if (is_struct(_value)) {
            // Convert nested struct
            ds_list_add(_list, struct_to_ds_map_recursive(_value));
        } else if (is_array(_value)) {
            // Recursively convert nested array
            ds_list_add(_list, array_to_ds_list_recursive(_value));
        } else {
            // Copy primitive value or simple struct/array
             // Handle potential 'undefined' from JSON parsing
             if (is_undefined(_value)) {
                 show_debug_message("DEBUG (array_to_ds_list): Skipping undefined value at index: " + string(i));
             } else {
                ds_list_add(_list, _value);
             }
        }
    }
    return _list;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_camera_easing
File: scr_camera_easing.gml
/// Easing function for smooth camera transitions
function easing_out_quad(t) {
    return t * (2 - t);
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_convert_gui_to_world
File: scr_convert_gui_to_world.gml
/// scr_convert_gui_to_world()
/// Converts GUI mouse coordinates to world coordinates
var world_x = camera_get_view_x(view_camera[0]) + (mouse_x / display_get_gui_width()) * camera_get_view_width(view_camera[0]);
var world_y = camera_get_view_y(view_camera[0]) + (mouse_y / display_get_gui_height()) * camera_get_view_height(view_camera[0]);

return [world_x, world_y];

Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_ds_list_to_array_recursive
File: scr_ds_list_to_array_recursive.gml
/// @function ds_list_to_array_recursive(list_id)
/// @description Recursively converts a DS List (including nested maps/lists) into an array.
/// @param {Id.DsList} list_id The ID of the DS List to convert.
/// @returns {Array} An array representation of the list, or undefined if input is invalid.
function ds_list_to_array_recursive(list_id) {
    if (!ds_exists(list_id, ds_type_list)) {
         // It's possible this function might be (incorrectly) called with an array already
        if (is_array(list_id)) {
            show_debug_message("WARNING: ds_list_to_array_recursive called with an ARRAY - checking contents instead: " + string(list_id));
            return array_to_array_recursive(list_id); // Process if it's already an array
        }
        show_debug_message("WARNING: ds_list_to_array_recursive called with invalid list ID or non-array: " + string(list_id));
        return undefined;
    }

    var _array = [];
    var _list_size = ds_list_size(list_id);

    for (var i = 0; i < _list_size; i++) {
        var _value = ds_list_find_value(list_id, i);

        // --- REVISED LOGIC ---
        if (is_real(_value)) { // Check if it might be a DS ID
            if (ds_exists(_value, ds_type_map)) {
                 // Value IS a nested DS Map ID -> Convert recursively to STRUCT
                 array_push(_array, ds_map_to_struct_recursive(_value));
            } else if (ds_exists(_value, ds_type_list)) {
                 // Value IS a nested DS List ID -> Convert recursively to ARRAY
                 array_push(_array, ds_list_to_array_recursive(_value));
            } else {
                 // Value is a real number, but not a known DS ID -> Copy directly
                 array_push(_array, _value);
            }
        }
        // *** Check for actual GML struct BEFORE checking for array ***
        else if (is_struct(_value)) {
            // Value is already a struct -> Deep clone it recursively
            array_push(_array, struct_clone_recursive(_value)); // <<< Correct handling
        }
        else if (is_array(_value)) {
             // Value is an array -> Check its contents recursively
             array_push(_array, array_to_array_recursive(_value)); // <<< Ensure THIS helper exists and is correct
        }
        else {
            // Value is a primitive (string, bool, undefined) -> Copy directly
            if(is_undefined(_value)) { show_debug_message("DEBUG (ds_list->array): Skipping undefined at index: " + string(i)); }
            else { array_push(_array, _value); }
        }
         // --- END REVISED LOGIC ---

    }
    return _array;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_ds_map_to_struct_recursive
File: scr_ds_map_to_struct_recursive.gml
/// @function ds_map_to_struct_recursive(map_id)
/// @description Recursively converts a DS Map (including nested maps/lists) into a struct.
/// @param {Id.DsMap} map_id The ID of the DS Map to convert.
/// @returns {Struct} A struct representation of the map, or undefined if input is invalid.
function ds_map_to_struct_recursive(map_id) {
    if (!ds_exists(map_id, ds_type_map)) {
        // It's possible this function might be (incorrectly) called with a struct already
        if (is_struct(map_id)) {
            show_debug_message("WARNING: ds_map_to_struct_recursive called with a STRUCT - cloning instead: " + string(map_id));
            return struct_clone_recursive(map_id); // Clone if it's already a struct
        }
        show_debug_message("WARNING: ds_map_to_struct_recursive called with invalid map ID or non-struct: " + string(map_id));
        return undefined;
    }

    var _struct = {};
    var _key = ds_map_find_first(map_id);

    while (!is_undefined(_key)) {
        var _value = ds_map_find_value(map_id, _key);

        // --- REVISED LOGIC ---
        if (is_real(_value)) { // Check if it *could* be a DS ID
            if (ds_exists(_value, ds_type_map)) {
                 // Value IS a nested DS Map ID -> Convert recursively
                 _struct[$ _key] = ds_map_to_struct_recursive(_value);
            } else if (ds_exists(_value, ds_type_list)) {
                 // Value IS a nested DS List ID -> Convert recursively to ARRAY
                 _struct[$ _key] = ds_list_to_array_recursive(_value); // Correct helper
            } else {
                 // Value is a real number, but not a known DS ID -> Copy directly
                 _struct[$ _key] = _value;
            }
        }
        // *** Check for actual GML array BEFORE checking for struct ***
        else if (is_array(_value)) {
             // Value is an ARRAY -> Recursively check its contents for DS types using array_to_array_recursive
             // We assume the goal is to have a final structure of nested structs and arrays,
             // so we recursively ensure any DS types within the array are converted.
              _struct[$ _key] = array_to_array_recursive(_value); // <<<< Ensure THIS helper function exists and is correct
        }
        else if (is_struct(_value)) {
            // Value is already a struct -> Deep clone it recursively
             _struct[$ _key] = struct_clone_recursive(_value);
        }
        else {
            // Value is a primitive (string, bool, undefined, etc.) -> Copy directly
             if(is_undefined(_value)) { show_debug_message("DEBUG (ds_map->struct): Skipping undefined for key: " + _key); }
             else { _struct[$ _key] = _value; }
        }
        // --- END REVISED LOGIC ---

        _key = ds_map_find_next(map_id, _key);
    }
    return _struct;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_handle_collision
File: scr_handle_collision.gml
// scripts/scr_handle_collision/scr_handle_collision.gml
function handle_collision(axis, speed) {
    var sign_speed = sign(speed);
    var abs_speed = abs(speed);
    var move_dist = 0;
    var step = abs_speed; // Start step size based on absolute speed

    if (abs_speed == 0) return 0; // No speed, no movement needed

    // Iteratively check smaller steps for precision
    while (step > 0.5) {  // Precision threshold (adjust if needed)
        var check_x = x;
        var check_y = y;
        if (axis == "x") {
            check_x += (move_dist + step) * sign_speed;
        } else { // axis == "y"
            check_y += (move_dist + step) * sign_speed;
        }

        if (!place_meeting(check_x, check_y, obj_wall)) {
            // If this step is clear, add it to the distance we can move
            move_dist += step;
        }
        // Halve the step size for the next iteration
        step /= 2;
    }

    // Apply the final calculated movement directly to the instance's coordinates
    if (axis == "x") {
        x += move_dist * sign_speed;
    } else { // axis == "y"
        y += move_dist * sign_speed;
    }

    // Return the actual distance moved (can be useful, but we won't use it for direct position update)
    return move_dist * sign_speed;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_initialize_item_data
File: scr_initialize_item_data.gml
/// @function scr_initialize_item_data()
/// @description Defines all static item properties and populates the lookup maps.
///              Should be called ONLY ONCE at game start.
function scr_initialize_item_data() {

    show_debug_message("--- Running scr_initialize_item_data ---");

    // 1. Define Master Item Data Structure
    //    Using a struct where keys are item names. Each item has its properties.
    //    index: Numerical ID for inventory arrays/saving. MUST BE UNIQUE.
    //    type:  Equipment slot ("head", "face", "body", etc.) or "none" if not equippable.
    //    sprite: Sprite used when EQUIPPED (e.g., spr_player_betahat). Use 'undefined' or a placeholder for non-equippables if needed.
    //    object: Object created when DROPPED (e.g., obj_beta_hat). Use 'undefined' if item cannot be dropped as an object.
    //    inv_sprite: (Optional) Sprite specifically for inventory display (if different from equipped/drop). Defaults to using index on spr_inventory_items.
    //    price: (Optional) Cost in coins for shop system.
    //    description: (Optional) Text description for UI.
    global.item_definitions = {
        // Name             : { index: #, type: "slot/none", sprite: spr_,                object: obj_, /* optional... */ }
        "Beta Hat"          : { index: 0,  type: "head", sprite: spr_player_betahat,     object: obj_beta_hat },
        "Party Hat"         : { index: 1,  type: "head", sprite: spr_player_partyhat,    object: obj_party_hat },
        "Wrench"            : { index: 2,  type: "none", sprite: undefined,              object: obj_wrench_item },
        "Tube"              : { index: 3,  type: "none", sprite: undefined,              object: obj_tube },
        "Toboggan"          : { index: 4,  type: "none", sprite: undefined,              object: obj_toboggan },
        "Battery"           : { index: 5,  type: "none", sprite: undefined,              object: obj_battery },
        "Spy Phone"         : { index: 6,  type: "none", sprite: undefined,              object: obj_spyphone_item },
        "Broken Spy Phone"  : { index: 7,  type: "none", sprite: undefined,              object: obj_broken_spyphone_item },
        "EPF Phone"         : { index: 8,  type: "none", sprite: undefined,              object: obj_epfphone_item },
        "Fishing Rod"       : { index: 9,  type: "none", sprite: undefined,              object: obj_fishing_rod },
        "Jackhammer"        : { index: 10, type: "none", sprite: undefined,              object: obj_Jackhammer_item },
        "Snow Shovel"       : { index: 11, type: "none", sprite: undefined,              object: obj_snowshovel_item },
        "Pizza Slice"       : { index: 12, type: "none", sprite: undefined,              object: obj_pizzaslice_item },
        "Puffle O"          : { index: 13, type: "none", sprite: undefined,              object: obj_puffleo_item },
        "Box Puffle O"      : { index: 14, type: "none", sprite: undefined,              object: obj_boxpuffleo_item },
        "Fish"              : { index: 15, type: "none", sprite: undefined,              object: undefined },
        "Mullet"            : { index: 16, type: "none", sprite: undefined,              object: undefined },
        "Wood"              : { index: 17, type: "none", sprite: undefined,              object: obj_wood_item },
        "Snow"              : { index: 18, type: "none", sprite: undefined,              object: undefined },
        "Snow Blaster"      : { index: 19, type: "none", sprite: undefined,              object: obj_snowblaster_item },
        "Ghost Costume"     : { index: 20, type: "body", sprite: spr_ghostcostume_sheet, object: obj_ghostcostume_item },
        "Black Sun Glasses" : { index: 21, type: "face", sprite: spr_blkglasses_sheet,   object: obj_blacksunglasses_item },
        "Black Hoodie"      : { index: 22, type: "body", sprite: spr_blkhoodie_sheet,    object: obj_blackhoodie_item },
        "Miners Hard Hat"   : { index: 23, type: "head", sprite: spr_minerhat_sheet,     object: obj_minershardhat_item },
        "Tour Hat"          : { index: 24, type: "head", sprite: spr_tourhat_sheet,      object: obj_tourhat_item },
        // Add future items here following the { index: #, type: "", sprite: spr_, object: obj_ } format
    };
    show_debug_message("Defined global.item_definitions struct.");

    // 2. Ensure Helper Lookup Maps Exist (Create if they don't)
    //    These provide faster lookups and are used by existing code.
    if (!variable_global_exists("item_index_map") || !ds_exists(global.item_index_map, ds_type_map)) { global.item_index_map = ds_map_create(); show_debug_message("Created global.item_index_map");}
    if (!variable_global_exists("item_type_map") || !ds_exists(global.item_type_map, ds_type_map)) { global.item_type_map = ds_map_create(); show_debug_message("Created global.item_type_map");}
    if (!variable_global_exists("item_sprite_map") || !ds_exists(global.item_sprite_map, ds_type_map)) { global.item_sprite_map = ds_map_create(); show_debug_message("Created global.item_sprite_map");}
    if (!variable_global_exists("item_object_map") || !ds_exists(global.item_object_map, ds_type_map)) { global.item_object_map = ds_map_create(); show_debug_message("Created global.item_object_map");}
    show_debug_message("Ensured item lookup maps exist.");

    // 3. Clear and Populate Helper Maps from the Master Definition
    ds_map_clear(global.item_index_map);
    ds_map_clear(global.item_type_map);
    ds_map_clear(global.item_sprite_map);
    ds_map_clear(global.item_object_map);

    var item_names = variable_struct_get_names(global.item_definitions);
    for (var i = 0; i < array_length(item_names); i++) {
        var name = item_names[i];
        var data = global.item_definitions[$ name]; // Get the struct for this item

        // Populate index map (Name -> Index)
        // Essential for inventory array which stores indices
        if (variable_struct_exists(data, "index")) {
            ds_map_add(global.item_index_map, name, data.index);
        } else {
            show_debug_message("CRITICAL WARNING: Item '" + name + "' missing 'index' property!");
        }

        // Populate type map (Name -> Slot Type)
        // Used for equipping items to the correct slot
        if (variable_struct_exists(data, "type") && data.type != "none") {
            ds_map_add(global.item_type_map, name, data.type);
        }

        // Populate sprite map (Name -> Sprite Resource for EQUIPPED view)
        // Used by player draw event
        if (variable_struct_exists(data, "sprite") && !is_undefined(data.sprite)) {
            if (sprite_exists(data.sprite)) {
                 ds_map_add(global.item_sprite_map, name, data.sprite);
            } else {
                 show_debug_message("WARNING: Sprite " + string(data.sprite) + " for item '" + name + "' does not exist!");
                 // Maybe add a default/placeholder sprite here?
                 // ds_map_add(global.item_sprite_map, name, spr_placeholder_item);
            }
        }

        // Populate object map (Name -> Object Resource for DROPPED view)
        // Used by inventory_drop_active_item
        if (variable_struct_exists(data, "object") && !is_undefined(data.object)) {
            if (object_exists(data.object)) {
                 ds_map_add(global.item_object_map, name, data.object);
            } else {
                show_debug_message("WARNING: Object " + object_get_name(data.object) + " for item '" + name + "' does not exist!");
                 // Maybe add a default/placeholder object?
                 // ds_map_add(global.item_object_map, name, obj_generic_dropped_item);
            }
        }
    }
    show_debug_message("Populated item lookup maps (Index, Type, Sprite, Object).");
    show_debug_message("--- Finished scr_initialize_item_data ---");
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_init_globals
File: scr_init_globals.gml
/// @function init_globals()
/// @description Initializes global variables and ensures essential DYNAMIC structures exist.
///              Only sets default *game state* values for a new game.
///              Static item data is handled separately by scr_initialize_item_data().
function init_globals() {
    show_debug_message("--- Running init_globals (Refactored) ---");

    // --- Section 1: Ensure Essential Flags/Variables Exist (Run Always) ---
    if (!variable_global_exists("is_loading_game")) { global.is_loading_game = false; }
    if (!variable_global_exists("player_instance")) { global.player_instance = noone; }
    if (!variable_global_exists("inventory_expanded")) { global.inventory_expanded = false; show_debug_message("Ensured global.inventory_expanded exists."); }
    if (!variable_global_exists("game_paused")) { global.game_paused = false; show_debug_message("Ensured global.game_paused exists."); }
    if (!variable_global_exists("is_pause_menu_active")) { global.is_pause_menu_active = false; show_debug_message("Ensured global.is_pause_menu_active exists."); }
    if (!variable_global_exists("player_controls_enabled")) { global.player_controls_enabled = true; show_debug_message("Ensured global.player_controls_enabled exists."); }
    if (!variable_global_exists("colour_picker_active")) { global.colour_picker_active = false; show_debug_message("Ensured global.colour_picker_active exists."); }
    // Keep party_hat_visible/beta_hat_visible for now, but they might be redundant if relying purely on equipped_items
    if (!variable_global_exists("party_hat_visible")) { global.party_hat_visible = false; show_debug_message("Ensured global.party_hat_visible exists."); }
    if (!variable_global_exists("beta_hat_visible")) { global.beta_hat_visible = false; show_debug_message("Ensured global.beta_hat_visible exists."); }
    if (!variable_global_exists("skin_switching")) { global.skin_switching = false; show_debug_message("Ensured global.skin_switching exists."); }

    // --- Section 2: Ensure Core DYNAMIC Data Structures Exist (Run Always) ---
    //                 (Don't clear here if loading, only ensure existence)
    //                 Item lookup maps (item_index_map etc.) are handled by scr_initialize_item_data
    if (!variable_global_exists("following_puffles") || !ds_exists(global.following_puffles, ds_type_list)) { if (variable_global_exists("following_puffles") && ds_exists(global.following_puffles, ds_type_list)) ds_list_destroy(global.following_puffles); global.following_puffles = ds_list_create(); show_debug_message("Ensured global.following_puffles list exists."); }
    if (!variable_global_exists("room_states") || !ds_exists(global.room_states, ds_type_map)) { if (variable_global_exists("room_states") && ds_exists(global.room_states, ds_type_map)) ds_map_destroy(global.room_states); global.room_states = ds_map_create(); show_debug_message("Ensured global.room_states map exists."); }
    if (!variable_global_exists("active_quests") || !ds_exists(global.active_quests, ds_type_list)) { if (variable_global_exists("active_quests") && ds_exists(global.active_quests, ds_type_list)) ds_list_destroy(global.active_quests); global.active_quests = ds_list_create(); show_debug_message("Ensured global.active_quests list exists."); }
    if (!variable_global_exists("completed_quests") || !ds_exists(global.completed_quests, ds_type_list)) { if (variable_global_exists("completed_quests") && ds_exists(global.completed_quests, ds_type_list)) ds_list_destroy(global.completed_quests); global.completed_quests = ds_list_create(); show_debug_message("Ensured global.completed_quests list exists."); }
    // Inventory array (ensure it exists, size might be set here or defaults later)
    if (!variable_global_exists("inventory") || !is_array(global.inventory)) {
	    global.inventory = array_create(INVENTORY_SIZE, -1); // Use macro
	    show_debug_message("Ensured global.inventory array exists (Size " + string(INVENTORY_SIZE) + ").");
	}
    // Equipped items map (ensure it exists with base slots)
    if (!variable_global_exists("equipped_items") || !ds_exists(global.equipped_items, ds_type_map)) { if (variable_global_exists("equipped_items") && ds_exists(global.equipped_items, ds_type_map)) ds_map_destroy(global.equipped_items); global.equipped_items = ds_map_create(); ds_map_add(global.equipped_items, "head", -1); ds_map_add(global.equipped_items, "face", -1); ds_map_add(global.equipped_items, "neck", -1); ds_map_add(global.equipped_items, "body", -1); ds_map_add(global.equipped_items, "hand", -1); ds_map_add(global.equipped_items, "feet", -1); show_debug_message("Ensured global.equipped_items map exists with slots."); }

    // --- Camera Initialization (Run Always) ---
    if (!variable_global_exists("camera") || !is_real(global.camera) || global.camera < 0) {
        if (variable_global_exists("camera")) { show_debug_message("init_globals: global.camera holds invalid value (" + string(global.camera) + "). Recreating camera."); }
        else { show_debug_message("init_globals: global.camera variable does not exist. Creating camera."); }
        global.camera = camera_create();
        view_set_camera(0, global.camera);
        show_debug_message("init_globals: Created new global.camera. ID: " + string(global.camera));
    } else {
        show_debug_message("init_globals: Valid global.camera already exists. ID: " + string(global.camera));
        if (view_get_camera(0) != global.camera) {
            view_set_camera(0, global.camera);
            show_debug_message("init_globals: Ensured view 0 uses existing global.camera.");
        }
    }

    // --- Section 3: Loading Check ---
    if (variable_global_exists("is_loading_game") && global.is_loading_game == true) {
        show_debug_message("init_globals: Skipping NEW GAME default value assignments during game load.");
        exit; // Don't set new game defaults if loading
    }

    // --- Section 4: Default Value Assignments (Only for NEW GAME) ---
    show_debug_message("init_globals: Setting default values for NEW GAME.");
    global.player_x = 170;
    global.player_y = 154;
    global.warp_target_x = undefined;
    global.warp_target_y = undefined;
    global.warp_target_face = undefined;
    global.player_health = 100;
    global.score = 0;
    global.repair_complete = false; // Used by obj_inventory check
    global.player_color = make_color_rgb(7, 167, 163); // Default starting color (Cyan)
	global.inventory = array_create(INVENTORY_SIZE, -1); // Use macro

    // Clear DYNAMIC data structures specifically for a NEW game
    if (ds_exists(global.following_puffles, ds_type_list)) { ds_list_clear(global.following_puffles); }
    // Clear room_states map and destroy any contained lists
    if (ds_exists(global.room_states, ds_type_map)) {
         var _keys = ds_map_keys_to_array(global.room_states);
         for (var i = 0; i < array_length(_keys); i++) {
             var _list = global.room_states[? _keys[i]];
             if (ds_exists(_list, ds_type_list)) { ds_list_destroy(_list); }
         }
         ds_map_clear(global.room_states);
     }
    if (ds_exists(global.active_quests, ds_type_list)) { ds_list_clear(global.active_quests); }
    if (ds_exists(global.completed_quests, ds_type_list)) { ds_list_clear(global.completed_quests); }
    // Reset inventory array
    global.inventory = array_create(42, -1);
    // Reset equipped items map
    if (ds_exists(global.equipped_items, ds_type_map)) {
        ds_map_clear(global.equipped_items);
        ds_map_add(global.equipped_items, "head", -1); ds_map_add(global.equipped_items, "face", -1); ds_map_add(global.equipped_items, "neck", -1); ds_map_add(global.equipped_items, "body", -1); ds_map_add(global.equipped_items, "hand", -1); ds_map_add(global.equipped_items, "feet", -1);
    }

    show_debug_message("Finished setting default values via init_globals.");
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_init_sprites
File: scr_init_sprites.gml
function init_sprites(right, up, left, down, up_right, up_left, down_right, down_left) {
    sprite[RIGHT] = right;
    sprite[UP] = up;
    sprite[LEFT] = left;
    sprite[DOWN] = down;
    sprite[UP_RIGHT] = up_right;
    sprite[UP_LEFT] = up_left;
    sprite[DOWN_RIGHT] = down_right;
    sprite[DOWN_LEFT] = down_left;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_load_game
File: scr_load_game.gml
/// @function load_game()
/// @description Loads the game state from savegame.sav
/// @returns {Bool} True if loading was successful, false otherwise.
function load_game() {
    show_debug_message("[INFO] --- Running load_game ---");
    var _load_successful = false;
    var _load_data = undefined; // Initialize to ensure scope

    // --- 1. Check for and Read Save File ---
    if (!file_exists("savegame.sav")) {
        show_debug_message("[ERROR] Load Game: No save file found.");
        return false;
    }

    var _file = file_text_open_read("savegame.sav");
    if (_file == -1) {
        show_debug_message("[ERROR] Load Game: Failed to open save file.");
        return false;
    }

    var _json_string = "";
    try { // Wrap file reading in try...catch
        while (!file_text_eof(_file)) {
            _json_string += file_text_readln(_file);
        }
    } catch (_err) {
        show_debug_message("[ERROR] Load Game: Exception during file read: " + string(_err));
        file_text_close(_file); // Ensure file is closed on error
        return false;
    } finally {
        if (_file != -1) file_text_close(_file); // Ensure file is closed normally
    }


    if (_json_string == "") {
        show_debug_message("[ERROR] Load Game: Save file is empty or read failed.");
        return false;
    }

    // --- 2. Parse JSON Data (with error check) ---
    try {
         _load_data = json_parse(_json_string);
    } catch (_parse_error) {
         show_debug_message("[ERROR] Load Game: Failed to parse JSON string: " + string(_parse_error));
         try { show_message_async("Failed to load save data:\nInvalid format."); } catch (ex) {}
         return false; // Exit if JSON is invalid
    }

    // --- NEW: Validate _load_data structure ---
    if (!is_struct(_load_data)) {
        show_debug_message("[ERROR] Load Game: Parsed data is not a struct.");
         try { show_message_async("Failed to load save data:\nIncorrect structure."); } catch (ex) {}
        return false; // Exit if not a struct
    }
    // --- END NEW VALIDATION ---


    // --- 3. Validate Save Data Structure and Version ---
    // Use try...catch for the entire loading process for safety
    try {
        // *** CHECK INVENTORY EXISTENCE AND TYPE ***
        // Original crash point validation
        if (!variable_struct_exists(_load_data, "inventory") || !is_array(_load_data.inventory)) {
            // This specific check might now be redundant due to later checks,
            // but kept for clarity on the original crash point.
            // We'll rely on the check within the main game_state section later.
             show_debug_message("Load Game NOTE: Initial check for root-level 'inventory' array (may be outdated format or nested now).");
            // Do NOT throw error here yet, proceed to check game_state
        }
        // *** END CHECK ***


        if (!variable_struct_exists(_load_data, "save_format_version")) throw "Save data missing 'save_format_version'.";
        var _save_version = _load_data.save_format_version;
        show_debug_message("Load Game: Found save version: " + _save_version);
        // ... (version compatibility checks) ...

        if (!variable_struct_exists(_load_data, "game_state")) throw "Save data missing 'game_state' struct.";
        var _game_state = _load_data.game_state;
        if (!is_struct(_game_state)) throw "'game_state' is not a struct.";

        // *** Set Loading Flag ***
        if (!variable_global_exists("is_loading_game") || !global.is_loading_game) {
             show_debug_message("Load Game: Setting global.is_loading_game = true");
             global.is_loading_game = true;
        }

        // --- 4. Ensure Core Global Structures Exist BEFORE loading into them ---
        // (Your existing init checks seem fine here)
        if (!variable_global_exists("inventory") || !is_array(global.inventory)) {
            show_debug_message("Load Game Init: Initializing global.inventory.");
            global.inventory = array_create(INVENTORY_SIZE, -1);
        }
        if (!variable_global_exists("equipped_items") || !ds_exists(global.equipped_items, ds_type_map)) {
             show_debug_message("Load Game Init: Initializing global.equipped_items.");
             if (variable_global_exists("equipped_items") && ds_exists(global.equipped_items, ds_type_map)) ds_map_destroy(global.equipped_items);
             global.equipped_items = ds_map_create();
             ds_map_add(global.equipped_items, "head", -1); ds_map_add(global.equipped_items, "face", -1); ds_map_add(global.equipped_items, "neck", -1);
             ds_map_add(global.equipped_items, "body", -1); ds_map_add(global.equipped_items, "hand", -1); ds_map_add(global.equipped_items, "feet", -1);
        }
         if (!variable_global_exists("room_states") || !ds_exists(global.room_states, ds_type_map)) {
             show_debug_message("Load Game Init: Initializing global.room_states.");
              if (variable_global_exists("room_states") && ds_exists(global.room_states, ds_type_map)) ds_map_destroy(global.room_states);
             global.room_states = ds_map_create();
         }
         // (Add similar checks for active_quests, completed_quests, following_puffles if needed)


        // --- 5. Restore Game State ---

        // -- Restore Player Data --
        if (!variable_struct_exists(_game_state, "player_data")) throw "Game state missing 'player_data'.";
        var _player_data = _game_state.player_data;
        if (!is_struct(_player_data)) throw "'player_data' is not a struct.";
        global.player_x = _player_data.x ?? 100;
        global.player_y = _player_data.y ?? 100;
        global.last_player_face = _player_data.face ?? DOWN;
        global.current_skin = _player_data.skin ?? "player";
        global.player_color = _player_data.color ?? c_white;
        global.last_player_color = global.player_color; // Ensure last_player_color is updated on load
        show_debug_message("Load Game: Restored player data (Pos: " + string(global.player_x) + "," + string(global.player_y) + " Skin: " + global.current_skin + ")");


        // -- Restore Target Room --
        if (!variable_struct_exists(_game_state, "current_room_name")) throw "Game state missing 'current_room_name'.";
        var _room_name = _game_state.current_room_name;
        var _room_id = asset_get_index(_room_name);
        if (room_exists(_room_id)) {
            global.target_room = _room_id;
            show_debug_message("Load Game: Target room set to " + _room_name);
        } else {
            show_debug_message("Load Game WARNING: Saved room '" + _room_name + "' does not exist! Defaulting to Welcome Room.");
            global.target_room = rm_welcome_room; // Choose a safe default
        }

        // -- Restore Inventory --
        // <<< MOVE THE INVENTORY EXISTENCE CHECK HERE >>>
        if (!variable_struct_exists(_game_state, "inventory")) throw "Game state missing 'inventory'.";
        var _loaded_inv = _game_state.inventory;
        // <<< ADD is_array CHECK HERE >>>
        if (!is_array(_loaded_inv)) {
            throw "Invalid 'inventory' data format (not an array).";
        }
        // Now we know _loaded_inv exists and is an array
        var _debug_inv_str = "Load Game DEBUG: Raw loaded inventory array: [";
        for(var i=0; i<min(10, array_length(_loaded_inv)); i++) { _debug_inv_str += string(_loaded_inv[i]) + ","; }
        if(array_length(_loaded_inv) > 10) _debug_inv_str += "...";
        _debug_inv_str += "]";
        show_debug_message(_debug_inv_str);

        var _copy_length = min(array_length(_loaded_inv), INVENTORY_SIZE);
        if (!variable_global_exists("inventory") || !is_array(global.inventory) || array_length(global.inventory) != INVENTORY_SIZE) {
             global.inventory = array_create(INVENTORY_SIZE, -1);
        }
        show_debug_message("Load Game: Copying " + string(_copy_length) + " inventory items from save...");
        for (var i = 0; i < _copy_length; i++) {
             // Sanitize input: Ensure we only store numbers (indices) or -1
             global.inventory[i] = (is_real(_loaded_inv[i]) && _loaded_inv[i] >= -1) ? floor(_loaded_inv[i]) : -1;
        }
        for (var i = _copy_length; i < INVENTORY_SIZE; i++) { // Ensure remaining slots are empty
             global.inventory[i] = -1;
        }
        show_debug_message("Load Game: Inventory array copy complete.");
        // (Verbose log of final global inventory is good for debugging, keep it)
        show_debug_message("Load Game DEBUG: Final Global Inventory Contents:");
        var _inv_string = "";
        for (var i=0; i < INVENTORY_SIZE; i++){
             _inv_string += "["+string(i)+":"+string(global.inventory[i])+"]";
             if ((i+1) % 10 == 0 || i == INVENTORY_SIZE -1) { show_debug_message(_inv_string); _inv_string = ""; }
             else if (i < INVENTORY_SIZE - 1) { _inv_string += ", "; }
         }

        // -- Restore Equipped Items --
        if (!variable_struct_exists(_game_state, "equipped_items")) throw "Game state missing 'equipped_items'.";
        var _loaded_equipped = _game_state.equipped_items;
        if (!is_struct(_loaded_equipped)) throw "Invalid 'equipped_items' data format (not a struct).";
        if (ds_exists(global.equipped_items, ds_type_map)) ds_map_destroy(global.equipped_items);
        global.equipped_items = ds_map_create();
        var _keys = variable_struct_get_names(_loaded_equipped);
        for (var i=0; i<array_length(_keys); i++) {
             var _key = _keys[i];
             ds_map_add(global.equipped_items, _key, _loaded_equipped[$ _key]);
        }
        show_debug_message("Load Game: Restored equipped items map.");


        // -- Restore Room States -- (REVISED logic from your provided code seems okay here)
        if (!variable_struct_exists(_game_state, "room_states")) throw "Game state missing 'room_states'.";
        var _loaded_room_states_struct = _game_state.room_states;
        if (!is_struct(_loaded_room_states_struct)) throw "Invalid 'room_states' data format (not a struct).";

        show_debug_message("Load Game: Reconstructing global.room_states DS Map with *arrays* of state structs...");
        // Destroy old DS map and contained DS lists (if any)
        if (ds_exists(global.room_states, ds_type_map)) {
            var _old_keys = ds_map_keys_to_array(global.room_states);
            for(var i = 0; i < array_length(_old_keys); i++) {
                var _old_item = ds_map_find_value(global.room_states, _old_keys[i]);
                if(ds_exists(_old_item, ds_type_list)) ds_list_destroy(_old_item);
                // Arrays don't need explicit destroy
            }
            ds_map_destroy(global.room_states);
        }
        // Create new map
        global.room_states = ds_map_create();
        if (!ds_exists(global.room_states, ds_type_map)) throw "Failed to create global.room_states DS Map during load!";
        // Populate new map with arrays from loaded struct
        var _room_names = variable_struct_get_names(_loaded_room_states_struct);
        for (var i = 0; i < array_length(_room_names); i++) {
            var _room_name_key = _room_names[i];
            var _loaded_object_array = _loaded_room_states_struct[$ _room_name_key];
            if (is_array(_loaded_object_array)) {
                ds_map_add(global.room_states, _room_name_key, _loaded_object_array); // Add the array directly
                 show_debug_message("  - Stored state *array* for room '" + _room_name_key + "' (Size: " + string(array_length(_loaded_object_array)) + ")");
            } else {
                show_debug_message("Load Game WARNING: Data for room '" + _room_name_key + "' in save file was not an array. Storing empty array.");
                ds_map_add(global.room_states, _room_name_key, []);
            }
        }
         show_debug_message("Load Game: Finished reconstructing global.room_states map (now contains arrays).");


        // -- Restore Quests --
        // (Your existing quest loading logic seems okay, ensure DS lists are created if they don't exist)
         if (variable_struct_exists(_game_state, "active_quests")) { /* ... */ }
         if (variable_struct_exists(_game_state, "completed_quests")) { /* ... */ }

        // -- Restore Other Global Flags --
        global.repair_complete = _game_state.repair_complete_flag ?? false;
         // Add restoration for other saved global flags here...

         _load_successful = true;

    } catch (_error) {
        show_debug_message("Load Game ERROR during data loading: " + string(_error));
         try { show_message_async("Error loading game data:\n" + string(_error)); } catch (ex) {} // Show user feedback if possible
        _load_successful = false;
    }


    // --- 6. Finalization ---
    if (_load_successful) {
        show_debug_message("[DEBUG] Load Game: JSON parsed successfully.");
    } else {
        show_debug_message("[DEBUG] Load Game: JSON parsed failed.");
         global.is_loading_game = false; // Reset flag on failure
    }
    // Clean up parsed data struct if it exists
    // No direct 'delete' for structs, just let it go out of scope or set to noone if needed.
    _load_data = undefined;

    return _load_successful;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_macros
File: scr_macros.gml
#macro RIGHT 0
#macro UP 1
#macro LEFT 2
#macro DOWN 3
#macro UP_RIGHT 4
#macro UP_LEFT 5
#macro DOWN_RIGHT 6
#macro DOWN_LEFT 7

#macro INVENTORY_SIZE 42

#macro PB_DOWN 0
#macro PB_DOWN_LEFT 1
#macro PB_LEFT 2
#macro PB_UP_LEFT 3
#macro PB_UP 4
#macro PB_UP_RIGHT 5
#macro PB_RIGHT 6
#macro PB_DOWN_RIGHT 7

Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_music_function
File: scr_music_function.gml
function set_song_ingame( _song, _fadeOutCurrentSong = 0, _fadeIn = 0 )
{
	//_song = set to any song (including "noone" to stop or fade the track out)
	//_fadeOutCurrentSong = time (in frames) the current song (if playing) will take to fade out
	//_fadeIn = time (in frames) the target song (if not "noone" will take to fade in

	with ( obj_musicmanager )
	{
		targetSongAsset = _song;
		endFadeOutTime = _fadeOutCurrentSong;
		startFadeInTime = _fadeIn;
	}
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_puffle
File: scr_puffle.gml
/// @function get_puffle_sprite_data(direction)
/// @param direction - The facing direction (e.g., DOWN, LEFT)
/// @returns Array [base_subimage, xscale]
function get_puffle_sprite_data(direction) {
    switch (direction) {
        case DOWN: return [0, 1];       // Row 1: Subimages 0-7
        case DOWN_LEFT: return [8, 1];  // Row 2: Subimages 8-15
        case LEFT: return [16, 1];      // Row 3: Subimages 16-23
        case UP_LEFT: return [24, 1];   // Row 4: Subimages 24-31
        case UP: return [32, 1];        // Row 5: Subimages 32-39
        case DOWN_RIGHT: return [8, -1]; // Use Down-Left, flipped
        case RIGHT: return [16, -1];    // Use Left, flipped
        case UP_RIGHT: return [24, -1]; // Use Up-Left, flipped
        default: return [0, 1];         // Default to Down
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_save_game
File: scr_save_game.gml
/// @description Saves the current game state to savegame.sav
function save_game() {
    show_debug_message("--- Running save_game ---");

    // Ensure all necessary global structures exist
    if (!ds_exists(global.room_states, ds_type_map)) global.room_states = ds_map_create();

    var _current_room_name = room_get_name(room);
    var _state_array = [];

    // Collect state from all savable instances
    with (all) {
        if (object_index == obj_controller || object_index == obj_ui_manager) continue;

        if (variable_instance_exists(id, "is_savable") && is_savable) {
            var _state_data = {
                object_index_name: object_get_name(object_index),
                x: x, y: y,
                image_xscale: image_xscale ?? 1,
                image_yscale: image_yscale ?? 1,
                image_blend: image_blend ?? c_white,
                image_alpha: image_alpha ?? 1,
            };
            array_push(_state_array, _state_data);
        }
    }

    // Update global.room_states
    if (ds_map_exists(global.room_states, _current_room_name)) {
        ds_map_replace(global.room_states, _current_room_name, _state_array);
    } else {
        ds_map_add(global.room_states, _current_room_name, _state_array);
    }

    show_debug_message("Saved room state for: " + _current_room_name);


    // --- Prepare Data Structures for Saving ---
    var _equipped_items_struct = ds_map_to_struct_recursive(global.equipped_items);

    show_debug_message("save_game: Manually converting global.room_states map (containing arrays) to struct...");
    var _room_states_struct = {};
    var _map_keys = ds_map_keys_to_array(global.room_states);
    for (var i = 0; i < array_length(_map_keys); i++) {
        var _key = _map_keys[i];
        var _value = ds_map_find_value(global.room_states, _key);
        if (is_array(_value)) {
             _room_states_struct[$ _key] = array_clone_recursive(_value);
        } else {
            show_debug_message("save_game WARNING: Expected array for room '" + _key + "', found " + typeof(_value) + ". Storing empty array.");
            _room_states_struct[$ _key] = [];
        }
    }
    show_debug_message("save_game: Finished manually converting room states.");

    var _following_puffles_array = ds_list_to_array_recursive(global.following_puffles); // Placeholder
    var _active_quests_array = ds_list_to_array_recursive(global.active_quests);
    var _completed_quests_array = ds_list_to_array_recursive(global.completed_quests);

    // --- REMOVED: Intermediate inventory variable assignment ---
    // var _inventory_to_save = global.inventory; // REMOVED

    // --- Prepare Main Save Data Struct ---
		var _save_data = {
        save_format_version: "0.2.3", // Increment version for inventory fix
        save_timestamp: date_current_datetime(),
        game_state: {
        inventory: scr_array_duplicate_recursive(global.inventory), // Use the new function
        room_states: ds_map_to_struct_recursive(global.room_states),
            player_data: {
                x: global.player_instance.x,
                y: global.player_instance.y,
                face: variable_instance_exists(global.player_instance, "face") ? global.player_instance.face : DOWN,
                skin: global.current_skin,
                color: global.player_color,
             },
            current_room_name: _current_room_name,
            // *** CHANGE: Clone the inventory array directly here ***
            equipped_items: _equipped_items_struct,
            following_puffles: _following_puffles_array,
            active_quests: _active_quests_array,
            completed_quests: _completed_quests_array,
            repair_complete_flag: global.repair_complete ?? false,
            // Add other global vars
        }
    };

    // *** ADDED: Debug log to show inventory state *just before* stringify ***
    var _inv_debug_str = "Save Game DEBUG: Inventory state before stringify: [";
    // Ensure global.inventory exists and is an array before trying to access it
    if (variable_global_exists("inventory") && is_array(global.inventory)) {
        for(var i=0; i<min(10, array_length(global.inventory)); i++) {
             _inv_debug_str += string(global.inventory[i]) + ",";
        }
        if(array_length(global.inventory) > 10) { _inv_debug_str += "..."; }
    } else {
        _inv_debug_str += "ERROR: global.inventory is missing or not an array!";
    }
     _inv_debug_str += "]";
     show_debug_message(_inv_debug_str);
     // *** END DEBUG LOG ***


    // --- Convert to JSON and Save ---
    var _json_string = json_stringify(_save_data);

    // File writing and cleanup
    if (_json_string == "") { /* error msg */ return; }
    var _file = file_text_open_write("savegame.sav");
    if (_file != -1) {
	file_text_write_string(_file, _json_string);
	file_text_close(_file);
        show_debug_message("Game saved successfully to savegame.sav (using inv clone)."); // Update log
    } else { /* error msg */ }

    show_debug_message("Game saved successfully.");
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_set_depth
File: scr_set_depth.gml
// scr_set_depth.gml
function set_depth() {
    depth = -bbox_bottom;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_struct_clone_recursive
File: scr_struct_clone_recursive.gml
/// @function struct_clone_recursive(source_struct)
/// @description Recursively clones a struct, including nested structs and arrays.
/// @param {Struct} source_struct The struct to clone.
/// @returns {Struct} A deep copy of the struct.
function struct_clone_recursive(source_struct) {
    if (!is_struct(source_struct)) return source_struct; // Return non-structs as is

    var _new_struct = {};
    var _keys = variable_struct_get_names(source_struct);

    for(var i=0; i < array_length(_keys); i++) {
        var _key = _keys[i];
        var _value = source_struct[$ _key];

        if (is_struct(_value)) {
            _new_struct[$ _key] = struct_clone_recursive(_value); // Clone nested struct
        } else if (is_array(_value)) {
            _new_struct[$ _key] = array_clone_recursive(_value); // Clone nested array
        } else {
            _new_struct[$ _key] = _value; // Copy primitive
        }
    }
    return _new_struct;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_struct_to_ds_map_recursive
File: scr_struct_to_ds_map_recursive.gml
/// @function struct_to_ds_map_recursive(struct_data)
/// @description Recursively converts a Struct (including nested structs/arrays) into a DS Map.
/// @param {Struct} struct_data The Struct to convert.
/// @returns {Id.DsMap} A DS Map representation of the struct, or undefined if input is invalid.
function struct_to_ds_map_recursive(struct_data) {
    if (!is_struct(struct_data)) {
        show_debug_message("WARNING: struct_to_ds_map_recursive called with non-struct data: " + string(struct_data));
        return undefined;
    }

    var _map = ds_map_create();
    var _keys = variable_struct_get_names(struct_data);

    for (var i = 0; i < array_length(_keys); i++) {
        var _key = _keys[i];
        var _value = struct_data[$ _key];

        if (is_struct(_value)) {
            // Recursively convert nested struct
            ds_map_add(_map, _key, struct_to_ds_map_recursive(_value));
        } else if (is_array(_value)) {
            // Convert nested array
            ds_map_add(_map, _key, array_to_ds_list_recursive(_value)); // Call list conversion helper
        } else {
            // Copy primitive value or simple struct/array (no deep copy needed for primitives)
             // Handle potential 'undefined' from JSON parsing if a key existed with null value
             if (is_undefined(_value)) {
                  // Decide how to handle undefined - often skip, add as -1, or add as "undefined" string
                  // Skipping is often safest if the receiving code expects optional values.
                   show_debug_message("DEBUG (struct_to_ds_map): Skipping undefined value for key: " + _key);
             } else {
                 ds_map_add(_map, _key, _value);
             }
        }
    }
    return _map;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\unequip_item
File: unequip_item.gml
/// @function unequip_item(slot)
/// @param {string} slot The name of the slot to unequip the item from
function unequip_item(slot) {
    // Ensure the global map exists
    if (!ds_exists(global.equipped_items, ds_type_map)) {
        show_debug_message("ERROR: global.equipped_items map does not exist!");
        return;
    }

    // Ensure the slot key exists in the map
    if (ds_map_exists(global.equipped_items, slot)) {
        var current_item = global.equipped_items[? slot];
        if (current_item != -1 && !is_undefined(current_item)) {
            global.equipped_items[? slot] = -1; // Set slot to empty (-1)
            show_debug_message("Unequipped item from slot '" + slot + "'.");
            // Display the current state of the map for debugging
            // show_debug_message("Current global.equipped_items: " + ds_map_write(global.equipped_items));

             // NOTE: Removed call to apply_equipped_items();
             // The player object's Draw event handles the visual update.

        } else {
            show_debug_message("Slot '" + slot + "' was already empty.");
        }
    } else {
        show_debug_message("ERROR: Invalid equipment slot specified: '" + slot + "'");
    }
}
