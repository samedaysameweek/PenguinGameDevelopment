Folder: D:\PenguinIsleProject\Penguin Isles\scripts\draw_equipped_items
File: draw_equipped_items.gml
/// @function update_equipped_items_display()
/// @description Draws equipped items in their respective slots on the HUD.
function update_equipped_items_display() {
    if (!ds_exists(global.equipped_items, ds_type_map) || !ds_exists(global.item_sprite_map, ds_type_map)) {
        show_debug_message("Error: Required global maps not initialized.");
        return;
    }

    var gui_width = display_get_gui_width();
    var gui_height = display_get_gui_height();
    var slot_size = 32; // Size of each slot in pixels
    var start_x = gui_width - (6 * slot_size) - 10; // Right side, 6 slots
    var start_y = gui_height / 2 - (3 * slot_size); // Centered vertically

    var slots = ["head", "face", "neck", "body", "hand", "feet"];
    for (var i = 0; i < array_length(slots); i++) {
        var slot = slots[i];
        var item_name = ds_map_find_value(global.equipped_items, slot);
        var slot_x = start_x + (i mod 3) * slot_size;
        var slot_y = start_y + (i div 3) * slot_size;

	}
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\draw_item_card
File: draw_item_card.gml
/// @function draw_item_card(item, x, y)
/// @description Draws an item card with sprite, name, price,
/// @param {struct} item The item data to draw
/// @param {real} x The x position to draw at
/// @param {real} y The y position to draw at

function draw_item_card(item, card_x, card_y) {
    // Draw card background
    draw_set_color(c_dkgray);
    draw_rectangle(card_x, card_y, card_x + item_width, card_y + item_height, false);

    // Draw item sprite
    var sprite_scale = min((item_width - 20) / sprite_get_width(item.sprite),
                           (item_height * 0.6) / sprite_get_height(item.sprite));
    var sprite_x = card_x + item_width/2;
    var sprite_y = card_y + (item_height * 0.3);
    draw_sprite_ext(item.sprite, 0,
                    sprite_x, sprite_y,
                    sprite_scale, sprite_scale,
                    0, c_white, 1);

    // Draw item name
    draw_set_color(c_white);
    draw_set_halign(fa_center);
    draw_set_valign(fa_top);
    draw_set_font(fnt_shop_item);
    draw_text(card_x + item_width/2, card_y + item_height * 0.65, item.name);

    // Draw price
    var price_color = global.player_coins >= item.price ? c_lime : c_red;
    draw_set_color(price_color);
    draw_text(card_x + item_width/2, card_y + item_height * 0.8,
              string(item.price) + " coins");

    // Draw stock info if limited
    if (variable_struct_exists(item, "stock") && item.stock >= 0) {
        draw_set_color(c_yellow);
        draw_text(card_x + item_width/2, card_y + item_height * 0.9,
                  "Stock: " + string(item.stock));
    }

    // Draw seasonal tag if applicable
    if (variable_struct_exists(item, "seasonal") && item.seasonal) {
        draw_set_color(c_aqua);
        draw_text(card_x + item_width/2, card_y + 10, "Seasonal!");
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\equip_item
File: equip_item.gml
/// @function equip_item(slot, item_name)
/// @param {string} slot The name of the slot to equip the item to (e.g., "head", "body").
/// @param {string} item_name The name of the item to equip.
function equip_item(slot, item_name) {
    show_debug_message("Attempting to equip item: '" + item_name + "' to slot: '" + slot + "'");

    // Ensure the global map exists
    if (!ds_exists(global.equipped_items, ds_type_map)) {
        show_debug_message("ERROR: global.equipped_items map does not exist!");
        // Optionally re-initialize it here if needed, but it should be done in obj_initializer
        return;
    }

    // Ensure the slot key exists in the map
    if (ds_map_exists(global.equipped_items, slot)) {
        // Update the map with the item name
        global.equipped_items[? slot] = item_name;
        show_debug_message("Equipped '" + item_name + "' to slot '" + slot + "'.");
        // Display the current state of the map for debugging
        // show_debug_message("Current global.equipped_items: " + ds_map_write(global.equipped_items));

        // NOTE: Removed call to apply_equipped_items();
        // The player object's Draw event handles the visual update.

    } else {
        show_debug_message("ERROR: Invalid equipment slot specified: '" + slot + "'");
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\load_room_state
File: load_room_state.gml
/// @function load_room_state(room_id, is_fresh_load)
/// @description Loads room state (Backward compatibility function)
/// @param {Real} room_id Room ID to load state for
/// @param {Bool} is_fresh_load Whether this is a fresh game load
function load_room_state(room_id, is_fresh_load) {
    var room_name = room_get_name(room_id);
    show_debug_message("[LEGACY] load_room_state: Calling for room " + room_name);
    
    // Call our new function if it exists
    if (script_exists(asset_get_index("RoomStateManager_LoadState"))) {
        show_debug_message("[LEGACY] load_room_state: Using RoomStateManager_LoadState");
        RoomStateManager_LoadState(room_name, is_fresh_load);
    } 
    // Otherwise, use the existing room_states logic
    else {
        show_debug_message("[LEGACY] load_room_state: Using fallback implementation");
        
        // Ensure room_states exists
        if (!variable_global_exists("room_states")) {
            global.room_states = ds_map_create();
            show_debug_message("[LEGACY] load_room_state: Created missing global.room_states map");
        }
        
        // Check if saved state exists for this room
        if (ds_exists(global.room_states, ds_type_map) && ds_map_exists(global.room_states, room_name)) {
            var state_array = global.room_states[? room_name];
            
            // Only recreate instances during fresh load
            if (is_fresh_load && is_array(state_array)) {
                show_debug_message("[LEGACY] load_room_state: Loading " + string(array_length(state_array)) + 
                                 " instances for room " + room_name);
                
                for (var i = 0; i < array_length(state_array); i++) {
                    var state = state_array[i];
                    if (!is_struct(state)) continue;
                    
                    // Skip if object name or required properties missing
                    if (!variable_struct_exists(state, "object_index_name")) continue;
                    
                    var obj_index = asset_get_index(state.object_index_name);
                    if (obj_index == -1 || !object_exists(obj_index)) continue;
                    
                    // Skip player, controller, or UI manager
                    if (object_is_ancestor(obj_index, obj_player_base) || 
                        obj_index == obj_controller || 
                        obj_index == obj_ui_manager) {
                        continue;
                    }
                    
                    // Skip follower puffles
                    var is_follower = (obj_index == obj_puffle && 
                                      variable_struct_exists(state, "following_player") && 
                                      state.following_player);
                    if (is_follower) continue;
                    
                    // Create instance and apply properties
                    var inst = instance_create_layer(state.x, state.y, "Instances", obj_index);
                    
                    if (instance_exists(inst)) {
                        inst.is_savable = true;
                        
                        // Apply standard properties if they exist
                        if (variable_struct_exists(state, "image_xscale")) 
                            inst.image_xscale = state.image_xscale;
                        else 
                            inst.image_xscale = 1;
                            
                        if (variable_struct_exists(state, "image_yscale")) 
                            inst.image_yscale = state.image_yscale;
                        else 
                            inst.image_yscale = 1;
                            
                        if (variable_struct_exists(state, "image_blend")) 
                            inst.image_blend = state.image_blend;
                        else
                            inst.image_blend = c_white;
                            
                        if (variable_struct_exists(state, "image_alpha")) 
                            inst.image_alpha = state.image_alpha;
                        else
                            inst.image_alpha = 1;
                            
                        // Apply object-specific properties
                        if (variable_struct_exists(state, "face") && variable_instance_exists(inst, "face"))
                            inst.face = state.face;
                        
                        if (obj_index == obj_icetruck || obj_index == obj_icetruck_broken) {
                            if (variable_struct_exists(state, "icetruck_tint") && 
                                variable_instance_exists(inst, "icetruck_tint"))
                                inst.icetruck_tint = state.icetruck_tint;
                                
                            if (variable_struct_exists(state, "is_driveable") && 
                                variable_instance_exists(inst, "is_driveable"))
                                inst.is_driveable = state.is_driveable;
                        }
                        else if (object_get_parent(inst.object_index) == obj_pickup_item || 
                                inst.object_index == obj_dropped_item) {
                            if (variable_struct_exists(state, "item_name") && 
                                variable_instance_exists(inst, "item_name"))
                                inst.item_name = state.item_name;
                        }
                        else if (obj_index == obj_puffle) {
                            if (variable_struct_exists(state, "puffle_color") && 
                                variable_instance_exists(inst, "color"))
                                inst.color = state.puffle_color;
                                
                            if (variable_struct_exists(state, "puffle_state") && 
                                variable_instance_exists(inst, "state"))
                                inst.state = state.puffle_state;
                        }
                        
                        show_debug_message("[LEGACY] load_room_state: Created " + state.object_index_name + 
                                        " at (" + string(state.x) + "," + string(state.y) + ")");
                    }
                }
                
                show_debug_message("[LEGACY] load_room_state: Finished loading instances for " + room_name);
            } else {
                show_debug_message("[LEGACY] load_room_state: Not recreating instances (normal room entry)");
            }
        } else {
            show_debug_message("[LEGACY] load_room_state: No saved state found for " + room_name);
        }
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\RoomStateManager
File: RoomStateManager.gml
/// @function RoomStateManager_Save()
/// @description Saves the current state of the room.
/// @param {real} room_id - ID of the room to save.
function RoomStateManager_Save(room_id) {
    var room_name = room_get_name(room_id);
    show_debug_message("[INFO] RoomStateManager: Saving state for room: " + room_name);

    if (!ds_exists(global.roomStates, ds_type_map)) {
        global.roomStates = ds_map_create();
    }

    var state_array = [];
    with (all) {
        if (variable_instance_exists(id, "is_savable") && is_savable) {
            var state_data = {
                object_index_name: object_get_name(object_index),
                x: x, y: y
            };
            array_push(state_array, state_data);
        }
    }

    if (ds_map_exists(global.roomStates, room_name)) {
        ds_map_replace(global.roomStates, room_name, state_array);
    } else {
        ds_map_add(global.roomStates, room_name, state_array);
    }

    show_debug_message("[INFO] RoomStateManager: Room state saved for: " + room_name);
    
    // Check if saved state exists for this room
    if (ds_map_exists(global.room_states, room_name)) {
        var state_array = ds_map_find_value(global.room_states, room_name);

        // Check if valid state array exists
        if (is_array(state_array)) {
            show_debug_message("Found state array for " + room_name + ". Size: " + string(array_length(state_array)));

             // --- Create instances from saved state ARRAY ---
             if (is_fresh_load) {
                  show_debug_message("Recreating instances from saved state array (Fresh Load)...");
                  for (var i = 0; i < array_length(state_array); i++) {
                         var state = state_array[i];
                         if (!is_struct(state)) { continue; }
                         if (!variable_struct_exists(state, "object_index_name")) { continue; }
                         var _obj_index_to_load = asset_get_index(state.object_index_name);
                         if (_obj_index_to_load == -1 || !object_exists(_obj_index_to_load)) { continue; }
                         if (object_is_ancestor(_obj_index_to_load, obj_player_base) || _obj_index_to_load == obj_controller || _obj_index_to_load == obj_ui_manager) {
                             show_debug_message("Load State: Skipping creation of reserved object (" + object_get_name(_obj_index_to_load) + ") found in save data.");
                             continue;
                         }

                 // Skip creating follower puffles from save state (they are persistent)
                var is_follower = (_obj_index_to_load == obj_puffle && variable_struct_exists(state, "following_player") && state.following_player);
                if (is_follower) { continue; }

                 // Create instance (Non-followers or other objects)
                        var inst = instance_create_layer(state.x, state.y, "Instances", _obj_index_to_load);
                        show_debug_message("Created instance from saved state: " + object_get_name(_obj_index_to_load));
                        if (instance_exists(inst)) { try {
                        inst.is_savable = true; // Mark loaded instance as savable

                        // Apply common properties if they exist in the struct AND the instance
                        if (variable_struct_exists(state, "face") && variable_instance_exists(inst, "face")) { inst.face = state.face; } else if(variable_instance_exists(inst, "face")) {inst.face = DOWN;} // default face if missing
                        if (variable_struct_exists(state, "image_xscale") && variable_instance_exists(inst, "image_xscale")) inst.image_xscale = state.image_xscale; else inst.image_xscale = 1;
                        if (variable_struct_exists(state, "image_yscale") && variable_instance_exists(inst, "image_yscale")) inst.image_yscale = state.image_yscale; else inst.image_yscale = 1;
                        if (variable_struct_exists(state, "image_blend") && variable_instance_exists(inst, "image_blend")) inst.image_blend = state.image_blend; else inst.image_blend = c_white;
                        if (variable_struct_exists(state, "image_alpha") && variable_instance_exists(inst, "image_alpha")) inst.image_alpha = state.image_alpha; else inst.image_alpha = 1;


                        // Object-specific properties
                        if (_obj_index_to_load == obj_icetruck || _obj_index_to_load == obj_icetruck_broken) {
                            if(variable_struct_exists(state, "icetruck_tint") && variable_instance_exists(inst,"icetruck_tint")) inst.icetruck_tint = state.icetruck_tint;
                            if(variable_struct_exists(state, "is_driveable") && variable_instance_exists(inst,"is_driveable")) inst.is_driveable = state.is_driveable;
                             // Ensure broken truck state aligns correctly
                            if (_obj_index_to_load == obj_icetruck_broken && variable_instance_exists(inst, "repair_required")) inst.repair_required = true;
                            if (_obj_index_to_load == obj_icetruck && variable_instance_exists(inst, "repair_required")) inst.repair_required = false;

                        } else if (object_get_parent(inst.object_index) == obj_pickup_item || inst.object_index == obj_dropped_item) { // General check for pickup items
                             if(variable_struct_exists(state, "item_name") && variable_instance_exists(inst,"item_name")) inst.item_name = state.item_name;
                        } else if (_obj_index_to_load == obj_puffle) { // Non-following puffles
                             if (variable_instance_exists(inst,"following_player")) inst.following_player = false;
                             if (variable_struct_exists(state, "puffle_color") && variable_instance_exists(inst,"color")) inst.color = state.puffle_color; // Apply color NAME
                             if (variable_struct_exists(state, "puffle_state") && variable_instance_exists(inst,"state")) inst.state = state.puffle_state;

                             // Apply blend from saved color name
                             if (variable_instance_exists(inst,"color")) {
                                switch (inst.color) {
                                    // Add color cases here to match names to colors
                                    case "red": inst.image_blend = make_color_rgb(255, 0, 0); break;
                                    // ... other colors ...
                                    default: inst.image_blend = c_white; break;
                                }
                             }
                        } else if (object_is_ancestor(_obj_index_to_load, obj_toboggan) || object_is_ancestor(_obj_index_to_load, obj_tube)) { // For Toboggan/Tube ITEMS
                             if(variable_struct_exists(state, "item_name") && variable_instance_exists(inst,"item_name")) inst.item_name = state.item_name;
                             if(variable_struct_exists(state, "face") && variable_instance_exists(inst,"face")) inst.face = state.face; // Restore item facing
                        }
                        // ... Add checks for other specific objects if needed ...

                         show_debug_message("Loaded " + state.object_index_name + " at (" + string(state.x) + ", " + string(state.y) + ")");

                     } catch (_err) {} }
                  }
                  show_debug_message("Finished creating instances for " + room_name + " (Fresh Load).");
            } else {
                 // If not a fresh load, we don't recreate everything from the save state,
                 // we just keep the instances that already exist in the room.
                                    show_debug_message("Normal Room Entry: Assuming instances persist or were recreated by GM.");
            }
} else {
             show_debug_message("Load State WARNING: Saved state for " + room_name + " is invalid (not an array).");
        }
    } else {
        show_debug_message("No state found for room: " + room_name + " in global.room_states.");
         // If fresh load, room is default empty. If normal entry, existing instances remain.
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\save_room_state
File: save_room_state.gml
/// @function save_room_state(room_id)
/// @description Saves room state (Backward compatibility function)
/// @param {Real} room_id Room ID to save state for
function save_room_state(room_id) {
    var room_name = room_get_name(room_id);
    show_debug_message("[LEGACY] save_room_state: Calling RoomStateManager_SaveState for " + room_name);
    
    // Call our new function if it exists
    if (script_exists(asset_get_index("RoomStateManager_SaveState"))) {
        RoomStateManager_SaveState(room_id);
    } 
    // Otherwise, use the existing room_states logic
    else {
        show_debug_message("[LEGACY] save_room_state: Using fallback implementation");
        
        // Ensure global room_states map exists
        if (!variable_global_exists("room_states") || !ds_exists(global.room_states, ds_type_map)) {
            global.room_states = ds_map_create();
        }
        
        var state_array = [];
        
        with (all) {
            // Skip controller and UI objects
            if (object_index == obj_controller || object_index == obj_ui_manager) continue;
            
            // Determine if instance is savable
            var is_savable = false;
            var parent_index = object_get_parent(object_index);
            
            if (parent_index == obj_pickup_item) {
                is_savable = true;
            } else if (
                object_index == obj_pickup_item || 
                object_index == obj_toboggan || 
                object_index == obj_tube ||
                object_index == obj_icetruck || 
                object_index == obj_icetruck_broken || 
                object_index == obj_puffle
            ) {
                is_savable = true;
            }
            
            // Exclude following puffles
            if (is_savable && object_index == obj_puffle) {
                if (variable_global_exists("following_puffles") && 
                    ds_exists(global.following_puffles, ds_type_list) && 
                    ds_list_find_index(global.following_puffles, id) != -1) {
                    is_savable = false;
                }
            }
            
            // Save state data
            if (is_savable) {
                try {
                    var state_data = {
                        object_index_name: object_get_name(object_index),
                        x: x, y: y,
                        image_xscale: image_xscale ?? 1,
                        image_yscale: image_yscale ?? 1,
                        image_blend: image_blend ?? c_white,
                        image_alpha: image_alpha ?? 1
                    };
                    
                    // Add common object properties
                    if (variable_instance_exists(id, "face")) {
                        state_data.face = face;
                    }
                    
                    // Add object-specific properties
                    if (object_index == obj_icetruck || object_index == obj_icetruck_broken) {
                        if (variable_instance_exists(id, "icetruck_tint")) {
                            state_data.icetruck_tint = icetruck_tint;
                        }
                        if (variable_instance_exists(id, "is_driveable")) {
                            state_data.is_driveable = is_driveable;
                        }
                    }
                    else if (object_get_parent(object_index) == obj_pickup_item || 
                            object_index == obj_dropped_item) {
                        if (variable_instance_exists(id, "item_name")) {
                            state_data.item_name = item_name;
                        }
                    }
                    else if (object_index == obj_puffle) {
                        if (variable_instance_exists(id, "following_player")) {
                            state_data.following_player = following_player;
                        }
                        if (variable_instance_exists(id, "color")) {
                            state_data.puffle_color = color;
                        }
                        if (variable_instance_exists(id, "state")) {
                            state_data.puffle_state = state;
                        }
                    }
                    
                    array_push(state_array, state_data);
                }
                catch (err) {
                    show_debug_message("[ERROR] Error saving state for object: " + 
                                   object_get_name(object_index) + " - " + string(err));
                }
            }
        }
        
        // Update room states
        if (ds_map_exists(global.room_states, room_name)) {
            ds_map_replace(global.room_states, room_name, state_array);
        } else {
            ds_map_add(global.room_states, room_name, state_array);
        }
        
        show_debug_message("[LEGACY] save_room_state: Saved " + string(array_length(state_array)) + 
                         " objects for room " + room_name);
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_array_clone_recursive
File: scr_array_clone_recursive.gml
/// @function array_clone_recursive(source_array)
/// @description Recursively clones an array, including nested structs and arrays.
/// @param {Array} source_array The array to clone.
/// @returns {Array} A deep copy of the array.
function array_clone_recursive(source_array) {
    if (!is_array(source_array)) return source_array; // Return non-arrays as is

    var _new_array = [];
    var _len = array_length(source_array);

    for (var i = 0; i < _len; i++) {
        var _value = source_array[i];

        if (is_struct(_value)) {
            array_push(_new_array, struct_clone_recursive(_value)); // Clone nested struct
        } else if (is_array(_value)) {
            array_push(_new_array, array_clone_recursive(_value)); // Clone nested array
        } else {
            array_push(_new_array, _value); // Copy primitive
        }
    }
    return _new_array;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_array_duplicate_recursive
File: scr_array_duplicate_recursive.gml
/// @function scr_array_duplicate_recursive(source_array)
/// @description Recursively duplicates an array, including nested structs and arrays.
/// @param {Array} source_array The array to duplicate.
/// @returns {Array} A deep copy of the array.
function scr_array_duplicate_recursive(source_array) {
    if (!is_array(source_array)) return source_array; // Return non-arrays as is

    var _new_array = [];
    var _len = array_length(source_array);

    for (var i = 0; i < _len; i++) {
        var _value = source_array[i];

        if (is_struct(_value)) {
            array_push(_new_array, struct_clone(_value)); // Clone nested struct
        } else if (is_array(_value)) {
            array_push(_new_array, scr_array_duplicate_recursive(_value)); // Clone nested array
        } else {
            array_push(_new_array, _value); // Copy primitive
        }
    }
    return _new_array;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_array_to_array_recursive
File: scr_array_to_array_recursive.gml
/// @function array_to_array_recursive(source_array)
/// @description Recursively checks an array for nested DS maps/lists and converts them.
///              Clones nested structs and arrays found within.
/// @param {Array} source_array The source array to process.
/// @returns {Array} A new array with DS structures converted, or a deep clone if none found.
function array_to_array_recursive(source_array) {
	if (!is_array(source_array)) return source_array; // Return non-arrays as is

	var _new_array = [];
	var _len = array_length(source_array);

	for (var i = 0; i < _len; i++) {
		var _value = source_array[i];

        // --- REVISED LOGIC for array_to_array_recursive ---
        if (is_struct(_value)) {
            // Found a struct -> Deep Clone it
            array_push(_new_array, struct_clone_recursive(_value)); // << Clone structs
        }
		else if (is_array(_value)) {
			// Found a nested array -> Recursively process it
			array_push(_new_array, array_to_array_recursive(_value));
		}
        else if (is_real(_value)) { // Check if it *could* be a DS ID
             // Only convert if it's CONFIRMED to be a DS map/list ID
            if (ds_exists(_value, ds_type_map)) {
                 array_push(_new_array, ds_map_to_struct_recursive(_value)); // Convert map ID -> struct
            } else if (ds_exists(_value, ds_type_list)) {
                 array_push(_new_array, ds_list_to_array_recursive(_value)); // Convert list ID -> array
            } else {
                 // Just a number -> Copy it
                 array_push(_new_array, _value);
            }
        }
		else {
             // Primitive (string, bool, etc.) -> Copy it directly
			 if(is_undefined(_value)) { show_debug_message("DEBUG (array->array): Skipping undefined value at index: " + string(i)); }
             else { array_push(_new_array, _value); }
		}
        // --- END REVISED LOGIC ---
	}
	return _new_array;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_array_to_ds_list_recursive
File: scr_array_to_ds_list_recursive.gml
/// @function array_to_ds_list_recursive(array_data)
/// @description Recursively converts an Array (including nested structs/arrays) into a DS List.
/// @param {Array} array_data The Array to convert.
/// @returns {Id.DsList} A DS List representation of the array, or undefined if input is invalid.
function array_to_ds_list_recursive(array_data) {
    if (!is_array(array_data)) {
        show_debug_message("WARNING: array_to_ds_list_recursive called with non-array data: " + string(array_data));
        return undefined;
    }

    var _list = ds_list_create();
    var _len = array_length(array_data);

    for (var i = 0; i < _len; i++) {
        var _value = array_data[i];

        if (is_struct(_value)) {
            // Convert nested struct
            ds_list_add(_list, struct_to_ds_map_recursive(_value));
        } else if (is_array(_value)) {
            // Recursively convert nested array
            ds_list_add(_list, array_to_ds_list_recursive(_value));
        } else {
            // Copy primitive value or simple struct/array
             // Handle potential 'undefined' from JSON parsing
             if (is_undefined(_value)) {
                 show_debug_message("DEBUG (array_to_ds_list): Skipping undefined value at index: " + string(i));
             } else {
                ds_list_add(_list, _value);
             }
        }
    }
    return _list;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_camera_easing
File: scr_camera_easing.gml
/// Easing function for smooth camera transitions
function easing_out_quad(t) {
    return t * (2 - t);
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_convert_gui_to_world
File: scr_convert_gui_to_world.gml
/// scr_convert_gui_to_world()
/// Converts GUI mouse coordinates to world coordinates
var world_x = camera_get_view_x(view_camera[0]) + (mouse_x / display_get_gui_width()) * camera_get_view_width(view_camera[0]);
var world_y = camera_get_view_y(view_camera[0]) + (mouse_y / display_get_gui_height()) * camera_get_view_height(view_camera[0]);

return [world_x, world_y];

Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_ds_list_to_array_recursive
File: scr_ds_list_to_array_recursive.gml
/// @function ds_list_to_array_recursive(list_id)
/// @description Recursively converts a DS List (including nested maps/lists) into an array.
/// @param {Id.DsList} list_id The ID of the DS List to convert.
/// @returns {Array} An array representation of the list, or undefined if input is invalid.
function ds_list_to_array_recursive(list_id) {
    if (!ds_exists(list_id, ds_type_list)) {
         // It's possible this function might be (incorrectly) called with an array already
        if (is_array(list_id)) {
            show_debug_message("WARNING: ds_list_to_array_recursive called with an ARRAY - checking contents instead: " + string(list_id));
            return array_to_array_recursive(list_id); // Process if it's already an array
        }
        show_debug_message("WARNING: ds_list_to_array_recursive called with invalid list ID or non-array: " + string(list_id));
        return undefined;
    }

    var _array = [];
    var _list_size = ds_list_size(list_id);

    for (var i = 0; i < _list_size; i++) {
        var _value = ds_list_find_value(list_id, i);

        // --- REVISED LOGIC ---
        if (is_real(_value)) { // Check if it might be a DS ID
            if (ds_exists(_value, ds_type_map)) {
                 // Value IS a nested DS Map ID -> Convert recursively to STRUCT
                 array_push(_array, ds_map_to_struct_recursive(_value));
            } else if (ds_exists(_value, ds_type_list)) {
                 // Value IS a nested DS List ID -> Convert recursively to ARRAY
                 array_push(_array, ds_list_to_array_recursive(_value));
            } else {
                 // Value is a real number, but not a known DS ID -> Copy directly
                 array_push(_array, _value);
            }
        }
        // *** Check for actual GML struct BEFORE checking for array ***
        else if (is_struct(_value)) {
            // Value is already a struct -> Deep clone it recursively
            array_push(_array, struct_clone_recursive(_value)); // <<< Correct handling
        }
        else if (is_array(_value)) {
             // Value is an array -> Check its contents recursively
             array_push(_array, array_to_array_recursive(_value)); // <<< Ensure THIS helper exists and is correct
        }
        else {
            // Value is a primitive (string, bool, undefined) -> Copy directly
            if(is_undefined(_value)) { show_debug_message("DEBUG (ds_list->array): Skipping undefined at index: " + string(i)); }
            else { array_push(_array, _value); }
        }
         // --- END REVISED LOGIC ---

    }
    return _array;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_ds_map_to_struct_recursive
File: scr_ds_map_to_struct_recursive.gml
/// @function ds_map_to_struct_recursive(map_id)
/// @description Recursively converts a DS Map (including nested maps/lists) into a struct.
/// @param {Id.DsMap} map_id The ID of the DS Map to convert.
/// @returns {Struct} A struct representation of the map, or undefined if input is invalid.
function ds_map_to_struct_recursive(map_id) {
    if (!ds_exists(map_id, ds_type_map)) {
        // It's possible this function might be (incorrectly) called with a struct already
        if (is_struct(map_id)) {
            show_debug_message("WARNING: ds_map_to_struct_recursive called with a STRUCT - cloning instead: " + string(map_id));
            return struct_clone_recursive(map_id); // Clone if it's already a struct
        }
        show_debug_message("WARNING: ds_map_to_struct_recursive called with invalid map ID or non-struct: " + string(map_id));
        return undefined;
    }

    var _struct = {};
    var _key = ds_map_find_first(map_id);

    while (!is_undefined(_key)) {
        var _value = ds_map_find_value(map_id, _key);

        // --- REVISED LOGIC ---
        if (is_real(_value)) { // Check if it *could* be a DS ID
            if (ds_exists(_value, ds_type_map)) {
                 // Value IS a nested DS Map ID -> Convert recursively
                 _struct[$ _key] = ds_map_to_struct_recursive(_value);
            } else if (ds_exists(_value, ds_type_list)) {
                 // Value IS a nested DS List ID -> Convert recursively to ARRAY
                 _struct[$ _key] = ds_list_to_array_recursive(_value); // Correct helper
            } else {
                 // Value is a real number, but not a known DS ID -> Copy directly
                 _struct[$ _key] = _value;
            }
        }
        // *** Check for actual GML array BEFORE checking for struct ***
        else if (is_array(_value)) {
             // Value is an ARRAY -> Recursively check its contents for DS types using array_to_array_recursive
             // We assume the goal is to have a final structure of nested structs and arrays,
             // so we recursively ensure any DS types within the array are converted.
              _struct[$ _key] = array_to_array_recursive(_value); // <<<< Ensure THIS helper function exists and is correct
        }
        else if (is_struct(_value)) {
            // Value is already a struct -> Deep clone it recursively
             _struct[$ _key] = struct_clone_recursive(_value);
        }
        else {
            // Value is a primitive (string, bool, undefined, etc.) -> Copy directly
             if(is_undefined(_value)) { show_debug_message("DEBUG (ds_map->struct): Skipping undefined for key: " + _key); }
             else { _struct[$ _key] = _value; }
        }
        // --- END REVISED LOGIC ---

        _key = ds_map_find_next(map_id, _key);
    }
    return _struct;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_handle_collision
File: scr_handle_collision.gml
// scripts/scr_handle_collision/scr_handle_collision.gml
function handle_collision(axis, speed) {
    var sign_speed = sign(speed);
    var abs_speed = abs(speed);
    var move_dist = 0;
    var step = abs_speed; // Start step size based on absolute speed

    if (abs_speed == 0) return 0; // No speed, no movement needed

    // Iteratively check smaller steps for precision
    while (step > 0.5) {  // Precision threshold (adjust if needed)
        var check_x = x;
        var check_y = y;
        if (axis == "x") {
            check_x += (move_dist + step) * sign_speed;
        } else { // axis == "y"
            check_y += (move_dist + step) * sign_speed;
        }

        if (!place_meeting(check_x, check_y, obj_wall)) {
            // If this step is clear, add it to the distance we can move
            move_dist += step;
        }
        // Halve the step size for the next iteration
        step /= 2;
    }

    // Apply the final calculated movement directly to the instance's coordinates
    if (axis == "x") {
        x += move_dist * sign_speed;
    } else { // axis == "y"
        y += move_dist * sign_speed;
    }

    // Return the actual distance moved (can be useful, but we won't use it for direct position update)
    return move_dist * sign_speed;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_initialize_item_data
File: scr_initialize_item_data.gml
/// @function scr_initialize_item_data()
/// @description Defines all static item properties and populates the lookup maps.
///              Should be called ONLY ONCE at game start.
function scr_initialize_item_data() {

    show_debug_message("--- Running scr_initialize_item_data ---");

    // 1. Define Master Item Data Structure
    //    Using a struct where keys are item names. Each item has its properties.
    //    index: Numerical ID for inventory arrays/saving. MUST BE UNIQUE.
    //    type:  Equipment slot ("head", "face", "body", etc.) or "none" if not equippable.
    //    sprite: Sprite used when EQUIPPED (e.g., spr_player_betahat). Use 'undefined' or a placeholder for non-equippables if needed.
    //    object: Object created when DROPPED (e.g., obj_beta_hat). Use 'undefined' if item cannot be dropped as an object.
    //    inv_sprite: (Optional) Sprite specifically for inventory display (if different from equipped/drop). Defaults to using index on spr_inventory_items.
    //    price: (Optional) Cost in coins for shop system.
    //    description: (Optional) Text description for UI.
    global.item_definitions = {
        // Name             : { index: #, type: "slot/none", sprite: spr_,                object: obj_, /* optional... */ }
        "Beta Hat"          : { index: 0,  type: "head", sprite: spr_player_betahat,     object: obj_beta_hat },
        "Party Hat"         : { index: 1,  type: "head", sprite: spr_player_partyhat,    object: obj_party_hat },
        "Wrench"            : { index: 2,  type: "none", sprite: undefined,              object: obj_wrench_item },
        "Tube"              : { index: 3,  type: "none", sprite: undefined,              object: obj_tube },
        "Toboggan"          : { index: 4,  type: "none", sprite: undefined,              object: obj_toboggan },
        "Battery"           : { index: 5,  type: "none", sprite: undefined,              object: obj_battery },
        "Spy Phone"         : { index: 6,  type: "none", sprite: undefined,              object: obj_spyphone_item },
        "Broken Spy Phone"  : { index: 7,  type: "none", sprite: undefined,              object: obj_broken_spyphone_item },
        "EPF Phone"         : { index: 8,  type: "none", sprite: undefined,              object: obj_epfphone_item },
        "Fishing Rod"       : { index: 9,  type: "none", sprite: undefined,              object: obj_fishing_rod },
        "Jackhammer"        : { index: 10, type: "none", sprite: undefined,              object: obj_Jackhammer_item },
        "Snow Shovel"       : { index: 11, type: "none", sprite: undefined,              object: obj_snowshovel_item },
        "Pizza Slice"       : { index: 12, type: "none", sprite: undefined,              object: obj_pizzaslice_item },
        "Puffle O"          : { index: 13, type: "none", sprite: undefined,              object: obj_puffleo_item },
        "Box Puffle O"      : { index: 14, type: "none", sprite: undefined,              object: obj_boxpuffleo_item },
        "Fish"              : { index: 15, type: "none", sprite: undefined,              object: undefined },
        "Mullet"            : { index: 16, type: "none", sprite: undefined,              object: undefined },
        "Wood"              : { index: 17, type: "none", sprite: undefined,              object: obj_wood_item },
        "Snow"              : { index: 18, type: "none", sprite: undefined,              object: undefined },
        "Snow Blaster"      : { index: 19, type: "none", sprite: undefined,              object: obj_snowblaster_item },
        "Ghost Costume"     : { index: 20, type: "body", sprite: spr_ghostcostume_sheet, object: obj_ghostcostume_item },
        "Black Sun Glasses" : { index: 21, type: "face", sprite: spr_blkglasses_sheet,   object: obj_blacksunglasses_item },
        "Black Hoodie"      : { index: 22, type: "body", sprite: spr_blkhoodie_sheet,    object: obj_blackhoodie_item },
        "Miners Hard Hat"   : { index: 23, type: "head", sprite: spr_minerhat_sheet,     object: obj_minershardhat_item },
        "Tour Hat"          : { index: 24, type: "head", sprite: spr_tourhat_sheet,      object: obj_tourhat_item },
        // Add future items here following the { index: #, type: "", sprite: spr_, object: obj_ } format
    };
    show_debug_message("Defined global.item_definitions struct.");

    // 2. Ensure Helper Lookup Maps Exist (Create if they don't)
    //    These provide faster lookups and are used by existing code.
    if (!variable_global_exists("item_index_map") || !ds_exists(global.item_index_map, ds_type_map)) { global.item_index_map = ds_map_create(); show_debug_message("Created global.item_index_map");}
    if (!variable_global_exists("item_type_map") || !ds_exists(global.item_type_map, ds_type_map)) { global.item_type_map = ds_map_create(); show_debug_message("Created global.item_type_map");}
    if (!variable_global_exists("item_sprite_map") || !ds_exists(global.item_sprite_map, ds_type_map)) { global.item_sprite_map = ds_map_create(); show_debug_message("Created global.item_sprite_map");}
    if (!variable_global_exists("item_object_map") || !ds_exists(global.item_object_map, ds_type_map)) { global.item_object_map = ds_map_create(); show_debug_message("Created global.item_object_map");}
    show_debug_message("Ensured item lookup maps exist.");

    // 3. Clear and Populate Helper Maps from the Master Definition
    ds_map_clear(global.item_index_map);
    ds_map_clear(global.item_type_map);
    ds_map_clear(global.item_sprite_map);
    ds_map_clear(global.item_object_map);

    var item_names = variable_struct_get_names(global.item_definitions);
    for (var i = 0; i < array_length(item_names); i++) {
        var name = item_names[i];
        var data = global.item_definitions[$ name]; // Get the struct for this item

        // Populate index map (Name -> Index)
        // Essential for inventory array which stores indices
        if (variable_struct_exists(data, "index")) {
            ds_map_add(global.item_index_map, name, data.index);
        } else {
            show_debug_message("CRITICAL WARNING: Item '" + name + "' missing 'index' property!");
        }

        // Populate type map (Name -> Slot Type)
        // Used for equipping items to the correct slot
        if (variable_struct_exists(data, "type") && data.type != "none") {
            ds_map_add(global.item_type_map, name, data.type);
        }

        // Populate sprite map (Name -> Sprite Resource for EQUIPPED view)
        // Used by player draw event
        if (variable_struct_exists(data, "sprite") && !is_undefined(data.sprite)) {
            if (sprite_exists(data.sprite)) {
                 ds_map_add(global.item_sprite_map, name, data.sprite);
            } else {
                 show_debug_message("WARNING: Sprite " + string(data.sprite) + " for item '" + name + "' does not exist!");
                 // Maybe add a default/placeholder sprite here?
                 // ds_map_add(global.item_sprite_map, name, spr_placeholder_item);
            }
        }

        // Populate object map (Name -> Object Resource for DROPPED view)
        // Used by inventory_drop_active_item
        if (variable_struct_exists(data, "object") && !is_undefined(data.object)) {
            if (object_exists(data.object)) {
                 ds_map_add(global.item_object_map, name, data.object);
            } else {
                show_debug_message("WARNING: Object " + object_get_name(data.object) + " for item '" + name + "' does not exist!");
                 // Maybe add a default/placeholder object?
                 // ds_map_add(global.item_object_map, name, obj_generic_dropped_item);
            }
        }
    }
    show_debug_message("Populated item lookup maps (Index, Type, Sprite, Object).");
    show_debug_message("--- Finished scr_initialize_item_data ---");
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_init_globals
File: scr_init_globals.gml
/// @function init_globals()
/// @description Initializes global variables and ensures essential DYNAMIC structures exist.
///              Only sets default *game state* values for a new game.
///              Static item data is handled separately by scr_initialize_item_data().
function init_globals() {
    show_debug_message("--- Running init_globals (Refactored) ---");

    // --- Section 1: Ensure Essential Flags/Variables Exist (Run Always) ---
    if (!variable_global_exists("is_loading_game")) { global.is_loading_game = false; }
    if (!variable_global_exists("player_instance")) { global.player_instance = noone; }
    if (!variable_global_exists("inventory_expanded")) { global.inventory_expanded = false; show_debug_message("Ensured global.inventory_expanded exists."); }
    if (!variable_global_exists("game_paused")) { global.game_paused = false; show_debug_message("Ensured global.game_paused exists."); }
    if (!variable_global_exists("is_pause_menu_active")) { global.is_pause_menu_active = false; show_debug_message("Ensured global.is_pause_menu_active exists."); }
    if (!variable_global_exists("player_controls_enabled")) { global.player_controls_enabled = true; show_debug_message("Ensured global.player_controls_enabled exists."); }
    if (!variable_global_exists("colour_picker_active")) { global.colour_picker_active = false; show_debug_message("Ensured global.colour_picker_active exists."); }
    // Keep party_hat_visible/beta_hat_visible for now, but they might be redundant if relying purely on equipped_items
    if (!variable_global_exists("party_hat_visible")) { global.party_hat_visible = false; show_debug_message("Ensured global.party_hat_visible exists."); }
    if (!variable_global_exists("beta_hat_visible")) { global.beta_hat_visible = false; show_debug_message("Ensured global.beta_hat_visible exists."); }
    if (!variable_global_exists("skin_switching")) { global.skin_switching = false; show_debug_message("Ensured global.skin_switching exists."); }

    // --- Section 2: Ensure Core DYNAMIC Data Structures Exist (Run Always) ---
    //                 (Don't clear here if loading, only ensure existence)
    //                 Item lookup maps (item_index_map etc.) are handled by scr_initialize_item_data
    if (!variable_global_exists("following_puffles") || !ds_exists(global.following_puffles, ds_type_list)) { if (variable_global_exists("following_puffles") && ds_exists(global.following_puffles, ds_type_list)) ds_list_destroy(global.following_puffles); global.following_puffles = ds_list_create(); show_debug_message("Ensured global.following_puffles list exists."); }
    if (!variable_global_exists("room_states") || !ds_exists(global.room_states, ds_type_map)) { if (variable_global_exists("room_states") && ds_exists(global.room_states, ds_type_map)) ds_map_destroy(global.room_states); global.room_states = ds_map_create(); show_debug_message("Ensured global.room_states map exists."); }
    if (!variable_global_exists("active_quests") || !ds_exists(global.active_quests, ds_type_list)) { if (variable_global_exists("active_quests") && ds_exists(global.active_quests, ds_type_list)) ds_list_destroy(global.active_quests); global.active_quests = ds_list_create(); show_debug_message("Ensured global.active_quests list exists."); }
    if (!variable_global_exists("completed_quests") || !ds_exists(global.completed_quests, ds_type_list)) { if (variable_global_exists("completed_quests") && ds_exists(global.completed_quests, ds_type_list)) ds_list_destroy(global.completed_quests); global.completed_quests = ds_list_create(); show_debug_message("Ensured global.completed_quests list exists."); }
    // Inventory array (ensure it exists, size might be set here or defaults later)
    if (!variable_global_exists("inventory") || !is_array(global.inventory)) {
	    global.inventory = array_create(INVENTORY_SIZE, -1); // Use macro
	    show_debug_message("Ensured global.inventory array exists (Size " + string(INVENTORY_SIZE) + ").");
	}
    // Equipped items map (ensure it exists with base slots)
    if (!variable_global_exists("equipped_items") || !ds_exists(global.equipped_items, ds_type_map)) { if (variable_global_exists("equipped_items") && ds_exists(global.equipped_items, ds_type_map)) ds_map_destroy(global.equipped_items); global.equipped_items = ds_map_create(); ds_map_add(global.equipped_items, "head", -1); ds_map_add(global.equipped_items, "face", -1); ds_map_add(global.equipped_items, "neck", -1); ds_map_add(global.equipped_items, "body", -1); ds_map_add(global.equipped_items, "hand", -1); ds_map_add(global.equipped_items, "feet", -1); show_debug_message("Ensured global.equipped_items map exists with slots."); }

    // --- Camera Initialization (Run Always) ---
    if (!variable_global_exists("camera") || !is_real(global.camera) || global.camera < 0) {
        if (variable_global_exists("camera")) { show_debug_message("init_globals: global.camera holds invalid value (" + string(global.camera) + "). Recreating camera."); }
        else { show_debug_message("init_globals: global.camera variable does not exist. Creating camera."); }
        global.camera = camera_create();
        view_set_camera(0, global.camera);
        show_debug_message("init_globals: Created new global.camera. ID: " + string(global.camera));
    } else {
        show_debug_message("init_globals: Valid global.camera already exists. ID: " + string(global.camera));
        if (view_get_camera(0) != global.camera) {
            view_set_camera(0, global.camera);
            show_debug_message("init_globals: Ensured view 0 uses existing global.camera.");
        }
    }

    // --- Section 3: Loading Check ---
    if (variable_global_exists("is_loading_game") && global.is_loading_game == true) {
        show_debug_message("init_globals: Skipping NEW GAME default value assignments during game load.");
        exit; // Don't set new game defaults if loading
    }

    // --- Section 4: Default Value Assignments (Only for NEW GAME) ---
    show_debug_message("init_globals: Setting default values for NEW GAME.");
    global.player_x = 170;
    global.player_y = 154;
    global.warp_target_x = undefined;
    global.warp_target_y = undefined;
    global.warp_target_face = undefined;
    global.player_health = 100;
    global.score = 0;
    global.repair_complete = false; // Used by obj_inventory check
    global.player_color = make_color_rgb(7, 167, 163); // Default starting color (Cyan)
	global.inventory = array_create(INVENTORY_SIZE, -1); // Use macro

    // Clear DYNAMIC data structures specifically for a NEW game
    if (ds_exists(global.following_puffles, ds_type_list)) { ds_list_clear(global.following_puffles); }
    // Clear room_states map and destroy any contained lists
    if (ds_exists(global.room_states, ds_type_map)) {
         var _keys = ds_map_keys_to_array(global.room_states);
         for (var i = 0; i < array_length(_keys); i++) {
             var _list = global.room_states[? _keys[i]];
             if (ds_exists(_list, ds_type_list)) { ds_list_destroy(_list); }
         }
         ds_map_clear(global.room_states);
     }
    if (ds_exists(global.active_quests, ds_type_list)) { ds_list_clear(global.active_quests); }
    if (ds_exists(global.completed_quests, ds_type_list)) { ds_list_clear(global.completed_quests); }
    // Reset inventory array
    global.inventory = array_create(42, -1);
    // Reset equipped items map
    if (ds_exists(global.equipped_items, ds_type_map)) {
        ds_map_clear(global.equipped_items);
        ds_map_add(global.equipped_items, "head", -1); ds_map_add(global.equipped_items, "face", -1); ds_map_add(global.equipped_items, "neck", -1); ds_map_add(global.equipped_items, "body", -1); ds_map_add(global.equipped_items, "hand", -1); ds_map_add(global.equipped_items, "feet", -1);
    }

    show_debug_message("Finished setting default values via init_globals.");
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_init_sprites
File: scr_init_sprites.gml
function init_sprites(right, up, left, down, up_right, up_left, down_right, down_left) {
    sprite[RIGHT] = right;
    sprite[UP] = up;
    sprite[LEFT] = left;
    sprite[DOWN] = down;
    sprite[UP_RIGHT] = up_right;
    sprite[UP_LEFT] = up_left;
    sprite[DOWN_RIGHT] = down_right;
    sprite[DOWN_LEFT] = down_left;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_load_game
File: scr_load_game.gml
/// @function load_game()
/// @description Loads the game state from savegame.sav
/// @returns {Bool} True if loading was successful, false otherwise.
function load_game() {
    show_debug_message("[INFO] --- Running load_game ---");
    var _load_successful = false;
    var _load_data = undefined; // Initialize to ensure scope

    // --- 1. Check for and Read Save File ---
    if (!file_exists("savegame.sav")) {
        show_debug_message("[ERROR] Load Game: No save file found.");
        return false;
    }

    var _file = file_text_open_read("savegame.sav");
    if (_file == -1) {
        show_debug_message("[ERROR] Load Game: Failed to open save file.");
        return false;
    }

    var _json_string = "";
    try { // Wrap file reading in try...catch
        while (!file_text_eof(_file)) {
            _json_string += file_text_readln(_file);
        }
    } catch (_err) {
        show_debug_message("[ERROR] Load Game: Exception during file read: " + string(_err));
        file_text_close(_file); // Ensure file is closed on error
        return false;
    } finally {
        if (_file != -1) file_text_close(_file); // Ensure file is closed normally
    }


    if (_json_string == "") {
        show_debug_message("[ERROR] Load Game: Save file is empty or read failed.");
        return false;
    }

    // --- 2. Parse JSON Data (with error check) ---
    try {
         _load_data = json_parse(_json_string);
    } catch (_parse_error) {
         show_debug_message("[ERROR] Load Game: Failed to parse JSON string: " + string(_parse_error));
         try { show_message_async("Failed to load save data:\nInvalid format."); } catch (ex) {}
         return false; // Exit if JSON is invalid
    }

    // --- NEW: Validate _load_data structure ---
    if (!is_struct(_load_data)) {
        show_debug_message("[ERROR] Load Game: Parsed data is not a struct.");
         try { show_message_async("Failed to load save data:\nIncorrect structure."); } catch (ex) {}
        return false; // Exit if not a struct
    }
    // --- END NEW VALIDATION ---


    // --- 3. Validate Save Data Structure and Version ---
    // Use try...catch for the entire loading process for safety
    try {
        // *** CHECK INVENTORY EXISTENCE AND TYPE ***
        // Original crash point validation
        if (!variable_struct_exists(_load_data, "inventory") || !is_array(_load_data.inventory)) {
            // This specific check might now be redundant due to later checks,
            // but kept for clarity on the original crash point.
            // We'll rely on the check within the main game_state section later.
             show_debug_message("Load Game NOTE: Initial check for root-level 'inventory' array (may be outdated format or nested now).");
            // Do NOT throw error here yet, proceed to check game_state
        }
        // *** END CHECK ***


        if (!variable_struct_exists(_load_data, "save_format_version")) throw "Save data missing 'save_format_version'.";
        var _save_version = _load_data.save_format_version;
        show_debug_message("Load Game: Found save version: " + _save_version);
        // ... (version compatibility checks) ...

        if (!variable_struct_exists(_load_data, "game_state")) throw "Save data missing 'game_state' struct.";
        var _game_state = _load_data.game_state;
        if (!is_struct(_game_state)) throw "'game_state' is not a struct.";

        // *** Set Loading Flag ***
        if (!variable_global_exists("is_loading_game") || !global.is_loading_game) {
             show_debug_message("Load Game: Setting global.is_loading_game = true");
             global.is_loading_game = true;
        }

        // --- 4. Ensure Core Global Structures Exist BEFORE loading into them ---
        // (Your existing init checks seem fine here)
        if (!variable_global_exists("inventory") || !is_array(global.inventory)) {
            show_debug_message("Load Game Init: Initializing global.inventory.");
            global.inventory = array_create(INVENTORY_SIZE, -1);
        }
        if (!variable_global_exists("equipped_items") || !ds_exists(global.equipped_items, ds_type_map)) {
             show_debug_message("Load Game Init: Initializing global.equipped_items.");
             if (variable_global_exists("equipped_items") && ds_exists(global.equipped_items, ds_type_map)) ds_map_destroy(global.equipped_items);
             global.equipped_items = ds_map_create();
             ds_map_add(global.equipped_items, "head", -1); ds_map_add(global.equipped_items, "face", -1); ds_map_add(global.equipped_items, "neck", -1);
             ds_map_add(global.equipped_items, "body", -1); ds_map_add(global.equipped_items, "hand", -1); ds_map_add(global.equipped_items, "feet", -1);
        }
         if (!variable_global_exists("room_states") || !ds_exists(global.room_states, ds_type_map)) {
             show_debug_message("Load Game Init: Initializing global.room_states.");
              if (variable_global_exists("room_states") && ds_exists(global.room_states, ds_type_map)) ds_map_destroy(global.room_states);
             global.room_states = ds_map_create();
         }
         // (Add similar checks for active_quests, completed_quests, following_puffles if needed)


        // --- 5. Restore Game State ---

        // -- Restore Player Data --
        if (!variable_struct_exists(_game_state, "player_data")) throw "Game state missing 'player_data'.";
        var _player_data = _game_state.player_data;
        if (!is_struct(_player_data)) throw "'player_data' is not a struct.";
        global.player_x = _player_data.x ?? 100;
        global.player_y = _player_data.y ?? 100;
        global.last_player_face = _player_data.face ?? DOWN;
        global.current_skin = _player_data.skin ?? "player";
        global.player_color = _player_data.color ?? c_white;
        global.last_player_color = global.player_color; // Ensure last_player_color is updated on load
        show_debug_message("Load Game: Restored player data (Pos: " + string(global.player_x) + "," + string(global.player_y) + " Skin: " + global.current_skin + ")");


        // -- Restore Target Room --
        if (!variable_struct_exists(_game_state, "current_room_name")) throw "Game state missing 'current_room_name'.";
        var _room_name = _game_state.current_room_name;
        var _room_id = asset_get_index(_room_name);
        if (room_exists(_room_id)) {
            global.target_room = _room_id;
            show_debug_message("Load Game: Target room set to " + _room_name);
        } else {
            show_debug_message("Load Game WARNING: Saved room '" + _room_name + "' does not exist! Defaulting to Welcome Room.");
            global.target_room = rm_welcome_room; // Choose a safe default
        }

        // -- Restore Inventory --
        // <<< MOVE THE INVENTORY EXISTENCE CHECK HERE >>>
        if (!variable_struct_exists(_game_state, "inventory")) throw "Game state missing 'inventory'.";
        var _loaded_inv = _game_state.inventory;
        // <<< ADD is_array CHECK HERE >>>
        if (!is_array(_loaded_inv)) {
            throw "Invalid 'inventory' data format (not an array).";
        }
        // Now we know _loaded_inv exists and is an array
        var _debug_inv_str = "Load Game DEBUG: Raw loaded inventory array: [";
        for(var i=0; i<min(10, array_length(_loaded_inv)); i++) { _debug_inv_str += string(_loaded_inv[i]) + ","; }
        if(array_length(_loaded_inv) > 10) _debug_inv_str += "...";
        _debug_inv_str += "]";
        show_debug_message(_debug_inv_str);

        var _copy_length = min(array_length(_loaded_inv), INVENTORY_SIZE);
        if (!variable_global_exists("inventory") || !is_array(global.inventory) || array_length(global.inventory) != INVENTORY_SIZE) {
             global.inventory = array_create(INVENTORY_SIZE, -1);
        }
        show_debug_message("Load Game: Copying " + string(_copy_length) + " inventory items from save...");
        for (var i = 0; i < _copy_length; i++) {
             // Sanitize input: Ensure we only store numbers (indices) or -1
             global.inventory[i] = (is_real(_loaded_inv[i]) && _loaded_inv[i] >= -1) ? floor(_loaded_inv[i]) : -1;
        }
        for (var i = _copy_length; i < INVENTORY_SIZE; i++) { // Ensure remaining slots are empty
             global.inventory[i] = -1;
        }
        show_debug_message("Load Game: Inventory array copy complete.");
        // (Verbose log of final global inventory is good for debugging, keep it)
        show_debug_message("Load Game DEBUG: Final Global Inventory Contents:");
        var _inv_string = "";
        for (var i=0; i < INVENTORY_SIZE; i++){
             _inv_string += "["+string(i)+":"+string(global.inventory[i])+"]";
             if ((i+1) % 10 == 0 || i == INVENTORY_SIZE -1) { show_debug_message(_inv_string); _inv_string = ""; }
             else if (i < INVENTORY_SIZE - 1) { _inv_string += ", "; }
         }

        // -- Restore Equipped Items --
        if (!variable_struct_exists(_game_state, "equipped_items")) throw "Game state missing 'equipped_items'.";
        var _loaded_equipped = _game_state.equipped_items;
        if (!is_struct(_loaded_equipped)) throw "Invalid 'equipped_items' data format (not a struct).";
        if (ds_exists(global.equipped_items, ds_type_map)) ds_map_destroy(global.equipped_items);
        global.equipped_items = ds_map_create();
        var _keys = variable_struct_get_names(_loaded_equipped);
        for (var i=0; i<array_length(_keys); i++) {
             var _key = _keys[i];
             ds_map_add(global.equipped_items, _key, _loaded_equipped[$ _key]);
        }
        show_debug_message("Load Game: Restored equipped items map.");


        // -- Restore Room States -- (REVISED logic from your provided code seems okay here)
        if (!variable_struct_exists(_game_state, "room_states")) throw "Game state missing 'room_states'.";
        var _loaded_room_states_struct = _game_state.room_states;
        if (!is_struct(_loaded_room_states_struct)) throw "Invalid 'room_states' data format (not a struct).";

        show_debug_message("Load Game: Reconstructing global.room_states DS Map with *arrays* of state structs...");
        // Destroy old DS map and contained DS lists (if any)
        if (ds_exists(global.room_states, ds_type_map)) {
            var _old_keys = ds_map_keys_to_array(global.room_states);
            for(var i = 0; i < array_length(_old_keys); i++) {
                var _old_item = ds_map_find_value(global.room_states, _old_keys[i]);
                if(ds_exists(_old_item, ds_type_list)) ds_list_destroy(_old_item);
                // Arrays don't need explicit destroy
            }
            ds_map_destroy(global.room_states);
        }
        // Create new map
        global.room_states = ds_map_create();
        if (!ds_exists(global.room_states, ds_type_map)) throw "Failed to create global.room_states DS Map during load!";
        // Populate new map with arrays from loaded struct
        var _room_names = variable_struct_get_names(_loaded_room_states_struct);
        for (var i = 0; i < array_length(_room_names); i++) {
            var _room_name_key = _room_names[i];
            var _loaded_object_array = _loaded_room_states_struct[$ _room_name_key];
            if (is_array(_loaded_object_array)) {
                ds_map_add(global.room_states, _room_name_key, _loaded_object_array); // Add the array directly
                 show_debug_message("  - Stored state *array* for room '" + _room_name_key + "' (Size: " + string(array_length(_loaded_object_array)) + ")");
            } else {
                show_debug_message("Load Game WARNING: Data for room '" + _room_name_key + "' in save file was not an array. Storing empty array.");
                ds_map_add(global.room_states, _room_name_key, []);
            }
        }
         show_debug_message("Load Game: Finished reconstructing global.room_states map (now contains arrays).");


        // -- Restore Quests --
        // (Your existing quest loading logic seems okay, ensure DS lists are created if they don't exist)
         if (variable_struct_exists(_game_state, "active_quests")) { /* ... */ }
         if (variable_struct_exists(_game_state, "completed_quests")) { /* ... */ }

        // -- Restore Other Global Flags --
        global.repair_complete = _game_state.repair_complete_flag ?? false;
         // Add restoration for other saved global flags here...

         _load_successful = true;

    } catch (_error) {
        show_debug_message("Load Game ERROR during data loading: " + string(_error));
         try { show_message_async("Error loading game data:\n" + string(_error)); } catch (ex) {} // Show user feedback if possible
        _load_successful = false;
    }


    // --- 6. Finalization ---
    if (_load_successful) {
        show_debug_message("[DEBUG] Load Game: JSON parsed successfully.");
    } else {
        show_debug_message("[DEBUG] Load Game: JSON parsed failed.");
         global.is_loading_game = false; // Reset flag on failure
    }
    // Clean up parsed data struct if it exists
    // No direct 'delete' for structs, just let it go out of scope or set to noone if needed.
    _load_data = undefined;

    return _load_successful;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_macros
File: scr_macros.gml
#macro RIGHT 0
#macro UP 1
#macro LEFT 2
#macro DOWN 3
#macro UP_RIGHT 4
#macro UP_LEFT 5
#macro DOWN_RIGHT 6
#macro DOWN_LEFT 7

#macro INVENTORY_SIZE 42

#macro PB_DOWN 0
#macro PB_DOWN_LEFT 1
#macro PB_LEFT 2
#macro PB_UP_LEFT 3
#macro PB_UP 4
#macro PB_UP_RIGHT 5
#macro PB_RIGHT 6
#macro PB_DOWN_RIGHT 7

Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_music_function
File: scr_music_function.gml
function set_song_ingame( _song, _fadeOutCurrentSong = 0, _fadeIn = 0 )
{
	//_song = set to any song (including "noone" to stop or fade the track out)
	//_fadeOutCurrentSong = time (in frames) the current song (if playing) will take to fade out
	//_fadeIn = time (in frames) the target song (if not "noone" will take to fade in

	with ( obj_musicmanager )
	{
		targetSongAsset = _song;
		endFadeOutTime = _fadeOutCurrentSong;
		startFadeInTime = _fadeIn;
	}
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_puffle
File: scr_puffle.gml
/// @function get_puffle_sprite_data(direction)
/// @param direction - The facing direction (e.g., DOWN, LEFT)
/// @returns Array [base_subimage, xscale]
function get_puffle_sprite_data(direction) {
    switch (direction) {
        case DOWN: return [0, 1];       // Row 1: Subimages 0-7
        case DOWN_LEFT: return [8, 1];  // Row 2: Subimages 8-15
        case LEFT: return [16, 1];      // Row 3: Subimages 16-23
        case UP_LEFT: return [24, 1];   // Row 4: Subimages 24-31
        case UP: return [32, 1];        // Row 5: Subimages 32-39
        case DOWN_RIGHT: return [8, -1]; // Use Down-Left, flipped
        case RIGHT: return [16, -1];    // Use Left, flipped
        case UP_RIGHT: return [24, -1]; // Use Up-Left, flipped
        default: return [0, 1];         // Default to Down
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_save_game
File: scr_save_game.gml
/// @description Saves the current game state to savegame.sav
function save_game() {
    show_debug_message("--- Running save_game ---");

    // Ensure all necessary global structures exist
    if (!ds_exists(global.room_states, ds_type_map)) global.room_states = ds_map_create();

    var _current_room_name = room_get_name(room);
    var _state_array = [];

    // Collect state from all savable instances
    with (all) {
        if (object_index == obj_controller || object_index == obj_ui_manager) continue;

        if (variable_instance_exists(id, "is_savable") && is_savable) {
            var _state_data = {
                object_index_name: object_get_name(object_index),
                x: x, y: y,
                image_xscale: image_xscale ?? 1,
                image_yscale: image_yscale ?? 1,
                image_blend: image_blend ?? c_white,
                image_alpha: image_alpha ?? 1,
            };
            array_push(_state_array, _state_data);
        }
    }

    // Update global.room_states
    if (ds_map_exists(global.room_states, _current_room_name)) {
        ds_map_replace(global.room_states, _current_room_name, _state_array);
    } else {
        ds_map_add(global.room_states, _current_room_name, _state_array);
    }

    show_debug_message("Saved room state for: " + _current_room_name);


    // --- Prepare Data Structures for Saving ---
    var _equipped_items_struct = ds_map_to_struct_recursive(global.equipped_items);

    show_debug_message("save_game: Manually converting global.room_states map (containing arrays) to struct...");
    var _room_states_struct = {};
    var _map_keys = ds_map_keys_to_array(global.room_states);
    for (var i = 0; i < array_length(_map_keys); i++) {
        var _key = _map_keys[i];
        var _value = ds_map_find_value(global.room_states, _key);
        if (is_array(_value)) {
             _room_states_struct[$ _key] = array_clone_recursive(_value);
        } else {
            show_debug_message("save_game WARNING: Expected array for room '" + _key + "', found " + typeof(_value) + ". Storing empty array.");
            _room_states_struct[$ _key] = [];
        }
    }
    show_debug_message("save_game: Finished manually converting room states.");

    var _following_puffles_array = ds_list_to_array_recursive(global.following_puffles); // Placeholder
    var _active_quests_array = ds_list_to_array_recursive(global.active_quests);
    var _completed_quests_array = ds_list_to_array_recursive(global.completed_quests);

    // --- REMOVED: Intermediate inventory variable assignment ---
    // var _inventory_to_save = global.inventory; // REMOVED

    // --- Prepare Main Save Data Struct ---
		var _save_data = {
        save_format_version: "0.2.3", // Increment version for inventory fix
        save_timestamp: date_current_datetime(),
        game_state: {
        inventory: scr_array_duplicate_recursive(global.inventory), // Use the new function
        room_states: ds_map_to_struct_recursive(global.room_states),
            player_data: {
                x: global.player_instance.x,
                y: global.player_instance.y,
                face: variable_instance_exists(global.player_instance, "face") ? global.player_instance.face : DOWN,
                skin: global.current_skin,
                color: global.player_color,
             },
            current_room_name: _current_room_name,
            // *** CHANGE: Clone the inventory array directly here ***
            equipped_items: _equipped_items_struct,
            following_puffles: _following_puffles_array,
            active_quests: _active_quests_array,
            completed_quests: _completed_quests_array,
            repair_complete_flag: global.repair_complete ?? false,
            // Add other global vars
        }
    };

    // *** ADDED: Debug log to show inventory state *just before* stringify ***
    var _inv_debug_str = "Save Game DEBUG: Inventory state before stringify: [";
    // Ensure global.inventory exists and is an array before trying to access it
    if (variable_global_exists("inventory") && is_array(global.inventory)) {
        for(var i=0; i<min(10, array_length(global.inventory)); i++) {
             _inv_debug_str += string(global.inventory[i]) + ",";
        }
        if(array_length(global.inventory) > 10) { _inv_debug_str += "..."; }
    } else {
        _inv_debug_str += "ERROR: global.inventory is missing or not an array!";
    }
     _inv_debug_str += "]";
     show_debug_message(_inv_debug_str);
     // *** END DEBUG LOG ***


    // --- Convert to JSON and Save ---
    var _json_string = json_stringify(_save_data);

    // File writing and cleanup
    if (_json_string == "") { /* error msg */ return; }
    var _file = file_text_open_write("savegame.sav");
    if (_file != -1) {
	file_text_write_string(_file, _json_string);
	file_text_close(_file);
        show_debug_message("Game saved successfully to savegame.sav (using inv clone)."); // Update log
    } else { /* error msg */ }

    show_debug_message("Game saved successfully.");
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_set_depth
File: scr_set_depth.gml
// scr_set_depth.gml
function set_depth() {
    depth = -bbox_bottom;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_struct_clone_recursive
File: scr_struct_clone_recursive.gml
/// @function struct_clone_recursive(source_struct)
/// @description Recursively clones a struct, including nested structs and arrays.
/// @param {Struct} source_struct The struct to clone.
/// @returns {Struct} A deep copy of the struct.
function struct_clone_recursive(source_struct) {
    if (!is_struct(source_struct)) return source_struct; // Return non-structs as is

    var _new_struct = {};
    var _keys = variable_struct_get_names(source_struct);

    for(var i=0; i < array_length(_keys); i++) {
        var _key = _keys[i];
        var _value = source_struct[$ _key];

        if (is_struct(_value)) {
            _new_struct[$ _key] = struct_clone_recursive(_value); // Clone nested struct
        } else if (is_array(_value)) {
            _new_struct[$ _key] = array_clone_recursive(_value); // Clone nested array
        } else {
            _new_struct[$ _key] = _value; // Copy primitive
        }
    }
    return _new_struct;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_struct_to_ds_map_recursive
File: scr_struct_to_ds_map_recursive.gml
/// @function struct_to_ds_map_recursive(struct_data)
/// @description Recursively converts a Struct (including nested structs/arrays) into a DS Map.
/// @param {Struct} struct_data The Struct to convert.
/// @returns {Id.DsMap} A DS Map representation of the struct, or undefined if input is invalid.
function struct_to_ds_map_recursive(struct_data) {
    if (!is_struct(struct_data)) {
        show_debug_message("WARNING: struct_to_ds_map_recursive called with non-struct data: " + string(struct_data));
        return undefined;
    }

    var _map = ds_map_create();
    var _keys = variable_struct_get_names(struct_data);

    for (var i = 0; i < array_length(_keys); i++) {
        var _key = _keys[i];
        var _value = struct_data[$ _key];

        if (is_struct(_value)) {
            // Recursively convert nested struct
            ds_map_add(_map, _key, struct_to_ds_map_recursive(_value));
        } else if (is_array(_value)) {
            // Convert nested array
            ds_map_add(_map, _key, array_to_ds_list_recursive(_value)); // Call list conversion helper
        } else {
            // Copy primitive value or simple struct/array (no deep copy needed for primitives)
             // Handle potential 'undefined' from JSON parsing if a key existed with null value
             if (is_undefined(_value)) {
                  // Decide how to handle undefined - often skip, add as -1, or add as "undefined" string
                  // Skipping is often safest if the receiving code expects optional values.
                   show_debug_message("DEBUG (struct_to_ds_map): Skipping undefined value for key: " + _key);
             } else {
                 ds_map_add(_map, _key, _value);
             }
        }
    }
    return _map;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\system
File: ErrorLogger.gml
/// @function ErrorLogger_Initialize()
/// @description Sets up the error logging system
function ErrorLogger_Initialize() {
    // Define log levels as a global enum
    global.LogLevel = {
        DEBUG: 0,
        INFO: 1,
        WARNING: 2,
        ERROR: 3,
        CRITICAL: 4
    };
    
    // Initialize log settings
    global.logLevel = global.LogLevel.DEBUG; // Current logging threshold
    global.logToFile = true;
    global.logFilePath = "game_log.txt";
    
    show_debug_message("[INFO] ErrorLogger initialized");
}

/// @function LogMessage(level, message, [context])
/// @param {Real} level The severity level of the message
/// @param {String} message The message to log
/// @param {Any} [context] Optional context data
function LogMessage(_level, _message, _context = undefined) {
    if (_level < global.logLevel) return;
    
    var _levelString = "";
    switch(_level) {
        case global.LogLevel.DEBUG: _levelString = "DEBUG"; break;
        case global.LogLevel.INFO: _levelString = "INFO"; break;
        case global.LogLevel.WARNING: _levelString = "WARNING"; break;
        case global.LogLevel.ERROR: _levelString = "ERROR"; break;
        case global.LogLevel.CRITICAL: _levelString = "CRITICAL"; break;
    }
    
    var _timestamp = string(current_year) + "-" + 
                     string(current_month) + "-" + 
                     string(current_day) + " " +
                     string(current_hour) + ":" + 
                     string(current_minute) + ":" + 
                     string(current_second);
                     
    var _logString = "[" + _timestamp + "] [" + _levelString + "] " + _message;
    if (_context != undefined) {
        _logString += "\nContext: " + string(_context);
    }
    
    show_debug_message(_logString);
    
    if (global.logToFile) {
        var _file = file_text_open_append(global.logFilePath);
        file_text_write_string(_file, _logString + "\n");
        file_text_close(_file);
    }
    
    // Return structured log entry
    return {
        timestamp: _timestamp,
        level: _level,
        levelString: _levelString,
        message: _message,
        context: _context
    };
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\system
File: GlobalStateManager.gml
/// @function GlobalStateManager_Initialize()
/// @description Initializes the global state manager with default values
function GlobalStateManager_Initialize() {
    global.gameState = {
        // Player state
        player: {
            instance: noone,
            position: { x: 0, y: 0 },
            skin: "player",
            color: c_white,
            face: DOWN,
            controls_enabled: true
        },
        
        // Game state
        game: {
            is_paused: false,
            is_loading: false,
            inventory_expanded: false,
            repair_complete: false
        },
        
        // UI state
        ui: {
            pause_menu_active: false,
            colour_picker_active: false,
            inventory_visible: false
        },
        
        // Room state
        room: {
            current: noone,
            target: noone,
            states: ds_map_create()
        }
    };
    
    LogMessage(global.LogLevel.INFO, "GlobalStateManager initialized");
}

/// @function GlobalState_Get(path)
/// @param {String} path Dot-notation path to the desired value
/// @returns {Any} The value at the specified path, or undefined if not found
function GlobalState_Get(_path) {
    try {
        var _parts = string_split(_path, ".");
        var _current = global.gameState;
        
        for (var i = 0; i < array_length(_parts); i++) {
            if (!variable_struct_exists(_current, _parts[i])) {
                LogMessage(global.LogLevel.WARNING, "Path not found in global state", _path);
                return undefined;
            }
            _current = variable_struct_get(_current, _parts[i]);
        }
        
        return _current;
    } catch(_error) {
        LogMessage(global.LogLevel.ERROR, "Error accessing global state", {
            path: _path,
            error: _error
        });
        return undefined;
    }
}

/// @function GlobalState_Set(path, value)
/// @param {String} path Dot-notation path to set
/// @param {Any} value Value to set at the path
function GlobalState_Set(_path, _value) {
    try {
        var _parts = string_split(_path, ".");
        var _current = global.gameState;
        
        // Navigate to the parent of our target
        for (var i = 0; i < array_length(_parts) - 1; i++) {
            if (!variable_struct_exists(_current, _parts[i])) {
                _current[$ _parts[i]] = {};
            }
            _current = variable_struct_get(_current, _parts[i]);
        }
        
        // Set the value
        _current[$ _parts[array_length(_parts) - 1]] = _value;
        
        LogMessage(global.LogLevel.DEBUG, "Global state updated", {
            path: _path,
            value: _value
        });
        
        return true;
    } catch(_error) {
        LogMessage(global.LogLevel.ERROR, "Error setting global state", {
            path: _path,
            value: _value,
            error: _error
        });
        return false;
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\system
File: InventoryManager.gml
/// @function InventoryManager_Initialize()
/// @description Initializes the inventory management system
function InventoryManager_Initialize() {
    global.gameState.inventory = {
        slots: array_create(INVENTORY_SIZE, -1),
        equipped: ds_map_create(),
        activeSlot: 0,
        isExpanded: false,
        
        // Equipment slots configuration
        equipmentSlots: {
            head: -1,
            face: -1,
            neck: -1,
            body: -1,
            hand: -1,
            feet: -1
        }
    };
    
    // Initialize equipment slots
    var _slots = variable_struct_get_names(global.gameState.inventory.equipmentSlots);
    for (var i = 0; i < array_length(_slots); i++) {
        ds_map_add(global.gameState.inventory.equipped, _slots[i], -1);
    }
    
    LogMessage(global.LogLevel.INFO, "InventoryManager initialized");
}

/// @function InventoryManager_AddItem(itemName)
/// @param {String} itemName Name of the item to add
/// @returns {Bool} True if item was added successfully
function InventoryManager_AddItem(_itemName) {
    try {
        var _inventory = global.gameState.inventory.slots;
        
        // Find first empty slot
        for (var i = 0; i < array_length(_inventory); i++) {
            if (_inventory[i] == -1) {
                _inventory[i] = _itemName;
                
                LogMessage(global.LogLevel.INFO, "Item added to inventory", {
                    item: _itemName,
                    slot: i
                });
                
                return true;
            }
        }
        
        LogMessage(global.LogLevel.WARNING, "Inventory full - couldn't add item", _itemName);
        return false;
    } catch(_error) {
        LogMessage(global.LogLevel.ERROR, "Error adding item to inventory", {
            item: _itemName,
            error: _error
        });
        return false;
    }
}

/// @function InventoryManager_EquipItem(slot, itemName)
/// @param {String} slot Equipment slot to use
/// @param {String} itemName Item to equip
/// @returns {Bool} True if item was equipped successfully
function InventoryManager_EquipItem(_slot, _itemName) {
    try {
        var _equipped = global.gameState.inventory.equipped;
        
        // Validate slot exists
        if (!ds_map_exists(_equipped, _slot)) {
            LogMessage(global.LogLevel.ERROR, "Invalid equipment slot", _slot);
            return false;
        }
        
        // Check if something is already equipped
        var _currentItem = _equipped[? _slot];
        if (_currentItem != -1) {
            // Try to move current item to inventory
            if (!InventoryManager_AddItem(_currentItem)) {
                LogMessage(global.LogLevel.WARNING, "Cannot unequip item - inventory full", _currentItem);
                return false;
            }
        }
        
        // Equip new item
        _equipped[? _slot] = _itemName;
        
        LogMessage(global.LogLevel.INFO, "Item equipped", {
            slot: _slot,
            item: _itemName
        });
        
        return true;
    } catch(_error) {
        LogMessage(global.LogLevel.ERROR, "Error equipping item", {
            slot: _slot,
            item: _itemName,
            error: _error
        });
        return false;
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\system
File: PlayerManager.gml
/// @function PlayerManager_Initialize()
/// @description Initializes the player management system
function PlayerManager_Initialize() {
    global.gameState.player = {
        // Core properties
        instance: noone,
        position: { x: 0, y: 0 },
        movement: { xspd: 0, yspd: 0, move_spd: 1 },
        face: DOWN,
        
        // Visual state
        skin: "player",
        color: c_white,
        last_color: c_white,
        
        // Action state
        action: {
            current: "none",
            timer: 0,
            duration: 0,
            has_spawned_projectile: false
        },
        
        // Animation data
        animation: {
            frame_index: 0,
            speed: 0,
            frame_data: undefined,
            sprite_body: undefined,
            sprite_color: undefined
        },
        
        // State flags
        flags: {
            controls_enabled: true,
            is_sliding: false,
            is_driving: false,
            can_interact: true
        }
    };
    
    // Initialize animation frame data
    PlayerManager_InitializeAnimations();
    
    LogMessage(global.LogLevel.INFO, "PlayerManager initialized");
}

/// @function PlayerManager_InitializeAnimations()
/// @description Sets up animation data for the player
function PlayerManager_InitializeAnimations() {
    var _player = global.gameState.player;
    
    // Frame data for walking (8 directions, 3 frames each)
    _player.animation.frame_data = {
        walking: array_create(8),
        actions: ds_map_create()
    };
    
    // Walking animation frames
    _player.animation.frame_data.walking[DOWN] = [0, 0, 24, 24, 0, 24, 24, 24, 0, 48, 24, 24];
    _player.animation.frame_data.walking[UP] = [24, 0, 24, 24, 24, 24, 24, 24, 24, 48, 24, 24];
    _player.animation.frame_data.walking[DOWN_LEFT] = [48, 0, 24, 24, 48, 24, 24, 24, 48, 48, 24, 24];
    _player.animation.frame_data.walking[DOWN_RIGHT] = [72, 0, 24, 24, 72, 24, 24, 24, 72, 48, 24, 24];
    _player.animation.frame_data.walking[LEFT] = [96, 0, 24, 24, 96, 24, 24, 24, 96, 48, 24, 24];
    _player.animation.frame_data.walking[RIGHT] = [120, 0, 24, 24, 120, 24, 24, 24, 120, 48, 24, 24];
    _player.animation.frame_data.walking[UP_RIGHT] = [144, 0, 24, 24, 144, 24, 24, 24, 144, 48, 24, 24];
    _player.animation.frame_data.walking[UP_LEFT] = [168, 0, 24, 24, 168, 24, 24, 24, 168, 48, 24, 24];
    
    // Action animations
    var _actions = _player.animation.frame_data.actions;
    
    // Sit animation
    ds_map_add(_actions, "sit", {
        frames: [
            [0, 72, 24, 24], [24, 72, 24, 24], [48, 72, 24, 24], [72, 72, 24, 24],
            [96, 72, 24, 24], [120, 72, 24, 24], [144, 72, 24, 24], [168, 72, 24, 24]
        ],
        speed: 0,
        loop: false,
        sprite_body: "spr_player_body",
        sprite_color: "spr_player_colour"
    });
    
    // Wave animation
    ds_map_add(_actions, "wave", {
        frames: [
            [0, 96, 24, 24], [24, 96, 24, 24], [48, 96, 24, 24], [72, 96, 24, 24],
            [96, 96, 24, 24], [120, 96, 24, 24], [144, 96, 24, 24], [168, 96, 24, 24]
        ],
        speed: 0.1,
        loop: true,
        sprite_body: "spr_player_body",
        sprite_color: "spr_player_colour"
    });
    
    // Add other action animations similarly...
}

/// @function PlayerManager_Update()
/// @description Updates player state and animations
function PlayerManager_Update() {
    var _player = global.gameState.player;
    if (!instance_exists(_player.instance)) return;
    
    var _inst = _player.instance;
    
    // Update position
    _player.position.x = _inst.x;
    _player.position.y = _inst.y;
    
    // Handle movement if not in action
    if (_player.action.current == "none" && _player.flags.controls_enabled) {
        PlayerManager_HandleMovement();
    }
    
    // Update action state
    if (_player.action.current != "none") {
        PlayerManager_UpdateAction();
    }
    
    // Update animation
    PlayerManager_UpdateAnimation();
}

/// @function PlayerManager_HandleMovement()
/// @description Handles player movement input and physics
function PlayerManager_HandleMovement() {
    var _player = global.gameState.player;
    var _inst = _player.instance;
    
    // Get input
    var _right = keyboard_check(ord("D")) || keyboard_check(vk_right);
    var _left = keyboard_check(ord("A")) || keyboard_check(vk_left);
    var _up = keyboard_check(ord("W")) || keyboard_check(vk_up);
    var _down = keyboard_check(ord("S")) || keyboard_check(vk_down);
    
    // Calculate movement
    var _move_x = (_right - _left) * _player.movement.move_spd;
    var _move_y = (_down - _up) * _player.movement.move_spd;
    
    // Apply sliding if active
    if (_player.flags.is_sliding) {
        // Sliding physics calculation here
    }
    
    // Update facing direction
    if (_move_x != 0 || _move_y != 0) {
        _player.face = PlayerManager_CalculateFacing(_move_x, _move_y);
    }
    
    // Apply movement with collision
    _inst.xspd = _move_x;
    _inst.yspd = _move_y;
    
    // Store movement state
    _player.movement.xspd = _move_x;
    _player.movement.yspd = _move_y;
}

/// @function PlayerManager_StartAction(action_name)
/// @param {String} action_name Name of the action to start
/// @returns {Bool} True if action started successfully
function PlayerManager_StartAction(_action_name) {
    var _player = global.gameState.player;
    
    // Check if action exists
    if (!ds_map_exists(_player.animation.frame_data.actions, _action_name)) {
        LogMessage(global.LogLevel.ERROR, "Invalid action name", _action_name);
        return false;
    }
    
    // Check if action is allowed
    if (!_player.flags.controls_enabled) return false;
    
    // Get action data
    var _action_data = _player.animation.frame_data.actions[? _action_name];
    
    // Start action
    _player.action.current = _action_name;
    _player.action.timer = 0;
    _player.action.has_spawned_projectile = false;
    _player.animation.frame_index = 0;
    _player.animation.speed = _action_data.speed;
    
    LogMessage(global.LogLevel.INFO, "Started player action", _action_name);
    return true;
}

/// @function PlayerManager_UpdateAction()
/// @description Updates current player action state
function PlayerManager_UpdateAction() {
    var _player = global.gameState.player;
    var _action_data = _player.animation.frame_data.actions[? _player.action.current];
    
    // Update action timer
    _player.action.timer++;
    
    // Check for action completion
    if (_action_data.loop == false) {
        if (_player.animation.frame_index >= array_length(_action_data.frames)) {
            PlayerManager_EndAction();
        }
    }
}

/// @function PlayerManager_EndAction()
/// @description Ends the current player action
function PlayerManager_EndAction() {
    var _player = global.gameState.player;
    
    _player.action.current = "none";
    _player.action.timer = 0;
    _player.action.has_spawned_projectile = false;
    _player.animation.frame_index = 0;
    _player.animation.speed = 0;
}

/// @function PlayerManager_CalculateFacing(move_x, move_y)
/// @param {Real} move_x Horizontal movement
/// @param {Real} move_y Vertical movement
/// @returns {Real} The calculated facing direction
function PlayerManager_CalculateFacing(_move_x, _move_y) {
    if (_move_y < 0) {
        if (_move_x < 0) return UP_LEFT;
        if (_move_x > 0) return UP_RIGHT;
        return UP;
    }
    if (_move_y > 0) {
        if (_move_x < 0) return DOWN_LEFT;
        if (_move_x > 0) return DOWN_RIGHT;
        return DOWN;
    }
    if (_move_x > 0) return RIGHT;
    if (_move_x < 0) return LEFT;
    
    return global.gameState.player.face;
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\system
File: QuestManager.gml
/// @function QuestManager_Initialize()
/// @description Initializes the quest management system
function QuestManager_Initialize() {
    global.gameState.quests = {
        active: ds_list_create(),
        completed: ds_list_create(),
        available: ds_list_create(),
        
        // Quest definitions
        definitions: {},
        
        // Quest progress tracking
        progress: {},
        
        // Quest flags
        flags: {},
        
        // Current tracked quest
        tracked: undefined
    };
    
    // Initialize quest definitions
    QuestManager_InitializeQuests();
    
    LogMessage(global.LogLevel.INFO, "QuestManager initialized");
}

/// @function QuestManager_InitializeQuests()
/// @description Defines all available quests
function QuestManager_InitializeQuests() {
    var _quests = global.gameState.quests.definitions;
    
    // Tour Guide Mystery Quest Line
    _quests.FIND_TOUR_GUIDE = {
        id: "FIND_TOUR_GUIDE",
        title: "The Missing Tour Guide",
        description: "The island's Tour Guide has mysteriously disappeared. Find clues about their whereabouts.",
        type: "main",
        stages: [
            {
                id: "TALK_TO_WITNESSES",
                description: "Talk to penguins around the Town Center",
                required: 3,
                progress: 0
            },
            {
                id: "FIND_GUIDE_HAT",
                description: "Look for the Tour Guide's hat",
                required: 1,
                progress: 0
            },
            {
                id: "REPORT_TO_MANAGER",
                description: "Report your findings to the Manager",
                required: 1,
                progress: 0
            }
        ],
        rewards: {
            coins: 100,
            items: ["Tour Hat"],
            unlocks: ["INVESTIGATE_BOTS"]
        },
        prerequisites: []
    };
    
    _quests.INVESTIGATE_BOTS = {
        id: "INVESTIGATE_BOTS",
        title: "Suspicious Bots",
        description: "Strange bots have been spreading misinformation. Investigate their behavior.",
        type: "main",
        stages: [
            {
                id: "OBSERVE_BOTS",
                description: "Observe bot behavior in different locations",
                required: 4,
                progress: 0
            },
            {
                id: "COLLECT_EVIDENCE",
                description: "Collect evidence of bot tampering",
                required: 3,
                progress: 0
            }
        ],
        rewards: {
            coins: 150,
            items: ["EPF Phone"],
            unlocks: ["TRACK_BOT_SIGNAL"]
        },
        prerequisites: ["FIND_TOUR_GUIDE"]
    };
    
    // Add to available quests if prerequisites met
    QuestManager_UpdateAvailableQuests();
}

/// @function QuestManager_UpdateAvailableQuests()
/// @description Updates the list of available quests based on prerequisites
function QuestManager_UpdateAvailableQuests() {
    var _quests = global.gameState.quests;
    var _definitions = _quests.definitions;
    ds_list_clear(_quests.available);
    
    var _quest_ids = variable_struct_get_names(_definitions);
    for (var i = 0; i < array_length(_quest_ids); i++) {
        var _quest = _definitions[$ _quest_ids[i]];
        
        // Skip if already active or completed
        if (ds_list_find_index(_quests.active, _quest.id) != -1) continue;
        if (ds_list_find_index(_quests.completed, _quest.id) != -1) continue;
        
        // Check prerequisites
        var _prerequisites_met = true;
        for (var j = 0; j < array_length(_quest.prerequisites); j++) {
            if (ds_list_find_index(_quests.completed, _quest.prerequisites[j]) == -1) {
                _prerequisites_met = false;
                break;
            }
        }
        
        if (_prerequisites_met) {
            ds_list_add(_quests.available, _quest.id);
        }
    }
}

/// @function QuestManager_StartQuest(quest_id)
/// @param {String} quest_id ID of the quest to start
/// @returns {Bool} True if quest started successfully
function QuestManager_StartQuest(_quest_id) {
    var _quests = global.gameState.quests;
    
    // Validate quest exists
    if (!variable_struct_exists(_quests.definitions, _quest_id)) {
        LogMessage(global.LogLevel.ERROR, "Invalid quest ID", _quest_id);
        return false;
    }
    
    // Check if quest is available
    if (ds_list_find_index(_quests.available, _quest_id) == -1) {
        LogMessage(global.LogLevel.WARNING, "Quest not available", _quest_id);
        return false;
    }
    
    // Initialize quest progress
    _quests.progress[$ _quest_id] = {
        started_time: date_current_datetime(),
        current_stage: 0,
        stages: array_create(array_length(_quests.definitions[$ _quest_id].stages))
    };
    
    // Add to active quests
    ds_list_add(_quests.active, _quest_id);
    
    // Remove from available quests
    ds_list_delete(_quests.available, ds_list_find_index(_quests.available, _quest_id));
    
    // Set as tracked quest if none is tracked
    if (_quests.tracked == undefined) {
        _quests.tracked = _quest_id;
    }
    
    LogMessage(global.LogLevel.INFO, "Quest started", {
        quest: _quest_id,
        time: _quests.progress[$ _quest_id].started_time
    });
    
    return true;
}

/// @function QuestManager_UpdateProgress(quest_id, stage_id, amount)
/// @param {String} quest_id ID of the quest to update
/// @param {String} stage_id ID of the stage to update
/// @param {Real} amount Amount to progress by
/// @returns {Bool} True if stage completed
function QuestManager_UpdateProgress(_quest_id, _stage_id, _amount = 1) {
    var _quests = global.gameState.quests;
    var _quest = _quests.definitions[$ _quest_id];
    var _progress = _quests.progress[$ _quest_id];
    
    if (_progress == undefined) return false;
    
    var _current_stage = _quest.stages[_progress.current_stage];
    if (_current_stage.id != _stage_id) return false;
    
    _progress.stages[_progress.current_stage] += _amount;
    
    // Check if stage is complete
    if (_progress.stages[_progress.current_stage] >= _current_stage.required) {
        return QuestManager_AdvanceStage(_quest_id);
    }
    
    return false;
}

/// @function QuestManager_AdvanceStage(quest_id)
/// @param {String} quest_id ID of the quest to advance
/// @returns {Bool} True if quest completed
function QuestManager_AdvanceStage(_quest_id) {
    var _quests = global.gameState.quests;
    var _quest = _quests.definitions[$ _quest_id];
    var _progress = _quests.progress[$ _quest_id];
    
    _progress.current_stage++;
    
    // Check if quest is complete
    if (_progress.current_stage >= array_length(_quest.stages)) {
        return QuestManager_CompleteQuest(_quest_id);
    }
    
    LogMessage(global.LogLevel.INFO, "Quest stage advanced", {
        quest: _quest_id,
        stage: _progress.current_stage
    });
    
    return false;
}

/// @function QuestManager_CompleteQuest(quest_id)
/// @param {String} quest_id ID of the quest to complete
/// @returns {Bool} True if quest completed successfully
function QuestManager_CompleteQuest(_quest_id) {
    var _quests = global.gameState.quests;
    var _quest = _quests.definitions[$ _quest_id];
    
    // Remove from active quests
    var _active_index = ds_list_find_index(_quests.active, _quest_id);
    if (_active_index != -1) {
        ds_list_delete(_quests.active, _active_index);
    }
    
    // Add to completed quests
    ds_list_add(_quests.completed, _quest_id);
    
    // Grant rewards
    if (variable_struct_exists(_quest, "rewards")) {
        // Add coins
        if (variable_struct_exists(_quest.rewards, "coins")) {
            // Assuming we have a function to add coins
            // AddCoins(_quest.rewards.coins);
        }
        
        // Add items
        if (variable_struct_exists(_quest.rewards, "items")) {
            for (var i = 0; i < array_length(_quest.rewards.items); i++) {
                InventoryManager_AddItem(_quest.rewards.items[i]);
            }
        }
        
        // Unlock new quests
        if (variable_struct_exists(_quest.rewards, "unlocks")) {
            for (var i = 0; i < array_length(_quest.rewards.unlocks); i++) {
                _quests.flags[$ _quest.rewards.unlocks[i]] = true;
            }
        }
    }
    
    // Update available quests
    QuestManager_UpdateAvailableQuests();
    
    // Update tracked quest if needed
    if (_quests.tracked == _quest_id) {
        _quests.tracked = undefined;
    }
    
    LogMessage(global.LogLevel.INFO, "Quest completed", {
        quest: _quest_id,
        rewards: _quest.rewards
    });
    
    return true;
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\system
File: RoomStateManager.gml
/// @function RoomStateManager_Initialize()
/// @description Initializes the room state management system
function RoomStateManager_Initialize() {
    // Make sure we use the existing room_states data structure
    if (!variable_global_exists("room_states") || !ds_exists(global.room_states, ds_type_map)) {
        global.room_states = ds_map_create();
    }
    
    show_debug_message("[INFO] RoomStateManager initialized");
}

/// @function RoomStateManager_SaveState(roomId)
/// @param {Real} roomId The room ID to save state for
function RoomStateManager_SaveState(_roomId) {
    var _roomName = room_get_name(_roomId);
    
    show_debug_message("[INFO] RoomStateManager: Saving state for room: " + _roomName);
    
    if (!ds_exists(global.room_states, ds_type_map)) {
        show_debug_message("[ERROR] RoomStateManager: global.room_states map does not exist");
        global.room_states = ds_map_create();
    }
    
    var _stateArray = [];
    
    with (all) {
        // Skip controller and UI objects
        if (object_index == obj_controller || object_index == obj_ui_manager) continue;
        
        if (variable_instance_exists(id, "is_savable") && is_savable) {
            var _stateData = {
                object_index_name: object_get_name(object_index),
                x: x,
                y: y,
                image_xscale: image_xscale ?? 1,
                image_yscale: image_yscale ?? 1,
                image_blend: image_blend ?? c_white,
                image_alpha: image_alpha ?? 1
            };
            
            // Store common variables if they exist
            if (variable_instance_exists(id, "face")) {
                _stateData.face = face;
            }
            
            // Store object-specific properties
            if (object_index == obj_icetruck || object_index == obj_icetruck_broken) {
                if (variable_instance_exists(id, "icetruck_tint")) {
                    _stateData.icetruck_tint = icetruck_tint;
                }
                
                if (variable_instance_exists(id, "is_driveable")) {
                    _stateData.is_driveable = is_driveable;
                }
            }
            else if (object_get_parent(object_index) == obj_pickup_item || 
                     object_index == obj_dropped_item) {
                if (variable_instance_exists(id, "item_name")) {
                    _stateData.item_name = item_name;
                }
            }
            else if (object_index == obj_puffle) {
                if (variable_instance_exists(id, "following_player")) {
                    _stateData.following_player = following_player;
                }
                
                if (variable_instance_exists(id, "color")) {
                    _stateData.puffle_color = color;
                }
                
                if (variable_instance_exists(id, "state")) {
                    _stateData.puffle_state = state;
                }
            }
            
            array_push(_stateArray, _stateData);
        }
    }
    
    // Add or replace the state
    if (ds_map_exists(global.room_states, _roomName)) {
        ds_map_replace(global.room_states, _roomName, _stateArray);
    } else {
        ds_map_add(global.room_states, _roomName, _stateArray);
    }
    
    show_debug_message("[INFO] RoomStateManager: Saved state for room: " + _roomName + 
                     " with " + string(array_length(_stateArray)) + " objects");
                     
    return true;
}

/// @function RoomStateManager_LoadState(roomName, isFreshLoad)
/// @param {String} roomName The name of the room to load state for
/// @param {Bool} isFreshLoad Whether this is a fresh game load
function RoomStateManager_LoadState(_roomName, _isFreshLoad) {
    show_debug_message("[INFO] RoomStateManager_LoadState called for: " + _roomName);
    
    if (!ds_exists(global.room_states, ds_type_map)) {
        show_debug_message("[ERROR] RoomStateManager: global.room_states map does not exist");
        return false;
    }
    
    if (!ds_map_exists(global.room_states, _roomName)) {
        show_debug_message("[INFO] RoomStateManager: No saved state found for room: " + _roomName);
        return false;
    }
    
    var _stateArray = global.room_states[? _roomName];
    if (!is_array(_stateArray)) {
        show_debug_message("[ERROR] RoomStateManager: Invalid room state format for: " + _roomName);
        return false;
    }
    
    show_debug_message("[INFO] RoomStateManager: Found state for room: " + _roomName + 
                      " with " + string(array_length(_stateArray)) + " objects");
    
    if (_isFreshLoad) {
        show_debug_message("[INFO] RoomStateManager: Fresh load - recreating instances");
        
        for (var i = 0; i < array_length(_stateArray); i++) {
            var _state = _stateArray[i];
            
            if (!is_struct(_state)) {
                show_debug_message("[WARNING] RoomStateManager: State entry " + string(i) + " is not a struct");
                continue;
            }
            
            if (!variable_struct_exists(_state, "object_index_name")) {
                show_debug_message("[WARNING] RoomStateManager: State entry " + string(i) + " missing object_index_name");
                continue;
            }
            
            var _objIndex = asset_get_index(_state.object_index_name);
            if (_objIndex == -1 || !object_exists(_objIndex)) {
                show_debug_message("[WARNING] RoomStateManager: Object does not exist: " + _state.object_index_name);
                continue;
            }
            
            // Skip certain objects
            if (object_is_ancestor(_objIndex, obj_player_base) || 
                _objIndex == obj_controller || 
                _objIndex == obj_ui_manager) {
                show_debug_message("[INFO] RoomStateManager: Skipping reserved object: " + _state.object_index_name);
                continue;
            }
            
            // Skip follower puffles
            var _isFollower = (_objIndex == obj_puffle && 
                              variable_struct_exists(_state, "following_player") && 
                              _state.following_player);
            if (_isFollower) {
                show_debug_message("[INFO] RoomStateManager: Skipping follower puffle");
                continue;
            }
            
            // Create instance
            var _inst = instance_create_layer(_state.x, _state.y, "Instances", _objIndex);
            
            if (instance_exists(_inst)) {
                _inst.is_savable = true;
                
                // Apply common properties
                if (variable_struct_exists(_state, "face") && variable_instance_exists(_inst, "face")) {
                    _inst.face = _state.face;
                } else if (variable_instance_exists(_inst, "face")) {
                    _inst.face = DOWN;
                }
                
                if (variable_struct_exists(_state, "image_xscale")) _inst.image_xscale = _state.image_xscale;
                else _inst.image_xscale = 1;
                
                if (variable_struct_exists(_state, "image_yscale")) _inst.image_yscale = _state.image_yscale;
                else _inst.image_yscale = 1;
                
                if (variable_struct_exists(_state, "image_blend")) _inst.image_blend = _state.image_blend;
                else _inst.image_blend = c_white;
                
                if (variable_struct_exists(_state, "image_alpha")) _inst.image_alpha = _state.image_alpha;
                else _inst.image_alpha = 1;
                
                // Apply object-specific properties
                if (_objIndex == obj_icetruck || _objIndex == obj_icetruck_broken) {
                    if (variable_struct_exists(_state, "icetruck_tint") && 
                        variable_instance_exists(_inst,"icetruck_tint")) {
                        _inst.icetruck_tint = _state.icetruck_tint;
                    }
                    
                    if (variable_struct_exists(_state, "is_driveable") && 
                        variable_instance_exists(_inst,"is_driveable")) {
                        _inst.is_driveable = _state.is_driveable;
                    }
                    
                    if (_objIndex == obj_icetruck_broken && 
                        variable_instance_exists(_inst, "repair_required")) {
                        _inst.repair_required = true;
                    }
                    
                    if (_objIndex == obj_icetruck && 
                        variable_instance_exists(_inst, "repair_required")) {
                        _inst.repair_required = false;
                    }
                }
                else if (object_get_parent(_inst.object_index) == obj_pickup_item || 
                         _inst.object_index == obj_dropped_item) {
                    if (variable_struct_exists(_state, "item_name") && 
                        variable_instance_exists(_inst,"item_name")) {
                        _inst.item_name = _state.item_name;
                    }
                }
                else if (_objIndex == obj_puffle) {
                    if (variable_instance_exists(_inst,"following_player")) {
                        _inst.following_player = false;
                    }
                    
                    if (variable_struct_exists(_state, "puffle_color") && 
                        variable_instance_exists(_inst,"color")) {
                        _inst.color = _state.puffle_color;
                    }
                    
                    if (variable_struct_exists(_state, "puffle_state") && 
                        variable_instance_exists(_inst,"state")) {
                        _inst.state = _state.puffle_state;
                    }
                }
                
                show_debug_message("[INFO] RoomStateManager: Created " + _state.object_index_name + 
                                 " at (" + string(_state.x) + "," + string(_state.y) + ")");
            }
        }
        
        show_debug_message("[INFO] RoomStateManager: Finished creating instances for " + _roomName);
    } else {
        show_debug_message("[INFO] RoomStateManager: Normal room entry - not creating instances");
    }
    
    return true;
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\system
File: SaveLoadManager.gml
/// @function SaveLoadManager_Initialize()
/// @description Initializes the save/load system
function SaveLoadManager_Initialize() {
    global.gameState.saveSystem = {
        version: "1.0.0",
        lastSaveTime: undefined,
        autoSaveEnabled: true,
        autoSaveInterval: 300, // 5 minutes in seconds
        saveFilePath: "savegame.sav"
    };
    
    LogMessage(global.LogLevel.INFO, "SaveLoadManager initialized");
}

/// @function SaveLoadManager_SaveGame()
/// @description Saves the current game state to file
/// @returns {Bool} True if save was successful
function SaveLoadManager_SaveGame() {
    try {
        var _saveData = {
            // Save metadata
            version: global.gameState.saveSystem.version,
            timestamp: date_current_datetime(),
            
            // Game state
            player: {
                x: GlobalState_Get("player.position.x"),
                y: GlobalState_Get("player.position.y"),
                skin: GlobalState_Get("player.skin"),
                color: GlobalState_Get("player.color"),
                face: GlobalState_Get("player.face")
            },
            
            // Room state
            currentRoom: room_get_name(room),
            roomStates: {},
            
            // Inventory state
            inventory: {
                slots: GlobalState_Get("inventory.slots"),
                equipped: SaveLoadManager_ConvertDsMapToStruct(
                    GlobalState_Get("inventory.equipped")
                ),
                activeSlot: GlobalState_Get("inventory.activeSlot")
            },
            
            // Quest and progress state
            gameProgress: {
                activeQuests: ds_list_to_array_recursive(global.active_quests),
                completedQuests: ds_list_to_array_recursive(global.completed_quests),
                flags: global.gameFlags ?? {}
            }
        };
        
        // Convert room states from ds_map to struct
        var _roomStates = GlobalState_Get("room.states");
        var _roomKeys = ds_map_keys_to_array(_roomStates);
        for (var i = 0; i < array_length(_roomKeys); i++) {
            var _key = _roomKeys[i];
            _saveData.roomStates[$ _key] = ds_map_find_value(_roomStates, _key);
        }
        
        // Convert save data to JSON
        var _jsonString = json_stringify(_saveData);
        if (_jsonString == "") {
            LogMessage(global.LogLevel.ERROR, "Failed to stringify save data");
            return false;
        }
        
        // Write to file
        var _file = file_text_open_write(global.gameState.saveSystem.saveFilePath);
        if (_file == -1) {
            LogMessage(global.LogLevel.ERROR, "Failed to open save file for writing");
            return false;
        }
        
        file_text_write_string(_file, _jsonString);
        file_text_close(_file);
        
        // Update last save time
        global.gameState.saveSystem.lastSaveTime = date_current_datetime();
        
        LogMessage(global.LogLevel.INFO, "Game saved successfully", {
            timestamp: _saveData.timestamp,
            room: _saveData.currentRoom
        });
        
        return true;
    } catch(_error) {
        LogMessage(global.LogLevel.ERROR, "Error saving game", _error);
        return false;
    }
}

/// @function SaveLoadManager_LoadGame()
/// @description Loads game state from file
/// @returns {Bool} True if load was successful
function SaveLoadManager_LoadGame() {
    try {
        if (!file_exists(global.gameState.saveSystem.saveFilePath)) {
            LogMessage(global.LogLevel.ERROR, "Save file does not exist");
            return false;
        }
        
        // Read save file
        var _file = file_text_open_read(global.gameState.saveSystem.saveFilePath);
        if (_file == -1) {
            LogMessage(global.LogLevel.ERROR, "Failed to open save file for reading");
            return false;
        }
        
        var _jsonString = "";
        while (!file_text_eof(_file)) {
            _jsonString += file_text_readln(_file);
        }
        file_text_close(_file);
        
        // Parse save data
        var _saveData = json_parse(_jsonString);
        if (!is_struct(_saveData)) {
            LogMessage(global.LogLevel.ERROR, "Invalid save data format");
            return false;
        }
        
        // Version check
        if (_saveData.version != global.gameState.saveSystem.version) {
            LogMessage(global.LogLevel.WARNING, "Save version mismatch", {
                save: _saveData.version,
                current: global.gameState.saveSystem.version
            });
        }
        
        // Set loading flag
        GlobalState_Set("game.is_loading", true);
        
        // Restore player state
        GlobalState_Set("player.position.x", _saveData.player.x);
        GlobalState_Set("player.position.y", _saveData.player.y);
        GlobalState_Set("player.skin", _saveData.player.skin);
        GlobalState_Set("player.color", _saveData.player.color);
        GlobalState_Set("player.face", _saveData.player.face);
        
        // Restore inventory
        GlobalState_Set("inventory.slots", _saveData.inventory.slots);
        SaveLoadManager_ConvertStructToDsMap(
            _saveData.inventory.equipped,
            GlobalState_Get("inventory.equipped")
        );
        GlobalState_Set("inventory.activeSlot", _saveData.inventory.activeSlot);
        
        // Restore room states
        var _roomStates = GlobalState_Get("room.states");
        ds_map_clear(_roomStates);
        var _roomNames = variable_struct_get_names(_saveData.roomStates);
        for (var i = 0; i < array_length(_roomNames); i++) {
            var _key = _roomNames[i];
            ds_map_add(_roomStates, _key, _saveData.roomStates[$ _key]);
        }
        
        // Set target room
        GlobalState_Set("room.target", asset_get_index(_saveData.currentRoom));
        
        // Restore quest state
        ds_list_clear(global.active_quests);
        ds_list_clear(global.completed_quests);
        array_copy_to_list(_saveData.gameProgress.activeQuests, global.active_quests);
        array_copy_to_list(_saveData.gameProgress.completedQuests, global.completed_quests);
        
        // Restore game flags
        global.gameFlags = _saveData.gameProgress.flags;
        
        LogMessage(global.LogLevel.INFO, "Game loaded successfully", {
            timestamp: _saveData.timestamp,
            room: _saveData.currentRoom
        });
        
        return true;
    } catch(_error) {
        LogMessage(global.LogLevel.ERROR, "Error loading game", _error);
        GlobalState_Set("game.is_loading", false);
        return false;
    }
}

/// @function SaveLoadManager_ConvertDsMapToStruct(map)
/// @param {Id.DsMap} map The ds_map to convert
/// @returns {Struct} A struct representation of the map
function SaveLoadManager_ConvertDsMapToStruct(_map) {
    var _struct = {};
    var _keys = ds_map_keys_to_array(_map);
    
    for (var i = 0; i < array_length(_keys); i++) {
        var _key = _keys[i];
        _struct[$ _key] = ds_map_find_value(_map, _key);
    }
    
    return _struct;
}

/// @function SaveLoadManager_ConvertStructToDsMap(struct, map)
/// @param {Struct} struct The struct to convert
/// @param {Id.DsMap} map The ds_map to populate
function SaveLoadManager_ConvertStructToDsMap(_struct, _map) {
    ds_map_clear(_map);
    var _keys = variable_struct_get_names(_struct);
    
    for (var i = 0; i < array_length(_keys); i++) {
        var _key = _keys[i];
        ds_map_add(_map, _key, _struct[$ _key]);
    }
}

/// @function SaveLoadManager_AutoSave()
/// @description Handles auto-saving if enabled
function SaveLoadManager_AutoSave() {
    if (!global.gameState.saveSystem.autoSaveEnabled) return;
    
    var _currentTime = date_current_datetime();
    var _lastSaveTime = global.gameState.saveSystem.lastSaveTime;
    
    if (_lastSaveTime == undefined || 
        date_second_span(_lastSaveTime, _currentTime) >= global.gameState.saveSystem.autoSaveInterval) {
        SaveLoadManager_SaveGame();
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\system
File: SystemInitializer.gml
/// @function SystemInitializer_Initialize()
/// @description Initializes all game systems in the correct order
function SystemInitializer_Initialize() {
    // Initialize core systems first
    ErrorLogger_Initialize();
    GlobalStateManager_Initialize();
    
    // Initialize gameplay systems
    RoomStateManager_Initialize();
    InventoryManager_Initialize();
    
    // Initialize UI systems last
    UIStateManager_Initialize();
    
    LogMessage(global.LogLevel.INFO, "All systems initialized");
}

/// @function SystemInitializer_Cleanup()
/// @description Cleans up all systems properly
function SystemInitializer_Cleanup() {
    // Clean up UI systems first
    var _activeElements = global.gameState.ui.activeElements;
    if (ds_exists(_activeElements, ds_type_list)) {
        ds_list_destroy(_activeElements);
    }
    
    // Clean up gameplay systems
    var _roomStates = global.gameState.room.states;
    if (ds_exists(_roomStates, ds_type_map)) {
        ds_map_destroy(_roomStates);
    }
    
    var _equipped = global.gameState.inventory.equipped;
    if (ds_exists(_equipped, ds_type_map)) {
        ds_map_destroy(_equipped);
    }
    
    LogMessage(global.LogLevel.INFO, "All systems cleaned up");
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\system
File: UIStateManager.gml
/// @function UIStateManager_Initialize()
/// @description Initializes the UI state management system
function UIStateManager_Initialize() {
    global.gameState.ui = {
        // Menu states
        menus: {
            pause: false,
            inventory: false,
            colorPicker: false,
            shop: false,
            dialog: false
        },
        
        // Active UI elements
        activeElements: ds_list_create(),
        
        // UI settings
        settings: {
            scale: 2.2,
            showHUD: true,
            showDebug: false
        },
        
        // Dialog system state
        dialog: {
            active: false,
            text: "",
            speaker: "",
            options: [],
            callback: undefined
        }
    };
    
    LogMessage(global.LogLevel.INFO, "UIStateManager initialized");
}

/// @function UIStateManager_ShowMenu(menuName)
/// @param {String} menuName Name of the menu to show
/// @returns {Bool} True if menu was shown successfully
function UIStateManager_ShowMenu(_menuName) {
    try {
        if (!variable_struct_exists(global.gameState.ui.menus, _menuName)) {
            LogMessage(global.LogLevel.ERROR, "Invalid menu name", _menuName);
            return false;
        }
        
        // Close other menus first
        UIStateManager_CloseAllMenus();
        
        // Show requested menu
        global.gameState.ui.menus[$ _menuName] = true;
        
        // Update game state
        GlobalState_Set("game.is_paused", true);
        
        LogMessage(global.LogLevel.INFO, "Menu shown", _menuName);
        return true;
    } catch(_error) {
        LogMessage(global.LogLevel.ERROR, "Error showing menu", {
            menu: _menuName,
            error: _error
        });
        return false;
    }
}

/// @function UIStateManager_CloseAllMenus()
function UIStateManager_CloseAllMenus() {
    var _menus = variable_struct_get_names(global.gameState.ui.menus);
    for (var i = 0; i < array_length(_menus); i++) {
        global.gameState.ui.menus[$ _menus[i]] = false;
    }
    
    // Resume game
    GlobalState_Set("game.is_paused", false);
    
    LogMessage(global.LogLevel.INFO, "All menus closed");
}

/// @function UIStateManager_ShowDialog(text, [speaker], [options], [callback])
/// @param {String} text Dialog text to display
/// @param {String} [speaker] Optional speaker name
/// @param {Array} [options] Optional dialog options
/// @param {Function} [callback] Optional callback when dialog completes
function UIStateManager_ShowDialog(_text, _speaker = "", _options = [], _callback = undefined) {
    try {
        global.gameState.ui.dialog = {
            active: true,
            text: _text,
            speaker: _speaker,
            options: _options,
            callback: _callback
        };
        
        // Add dialog to active UI elements
        ds_list_add(global.gameState.ui.activeElements, "dialog");
        
        LogMessage(global.LogLevel.INFO, "Dialog shown", {
            speaker: _speaker,
            text: _text
        });
        
        return true;
    } catch(_error) {
        LogMessage(global.LogLevel.ERROR, "Error showing dialog", {
            text: _text,
            error: _error
        });
        return false;
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\unequip_item
File: unequip_item.gml
/// @function unequip_item(slot)
/// @param {string} slot The name of the slot to unequip the item from
function unequip_item(slot) {
    // Ensure the global map exists
    if (!ds_exists(global.equipped_items, ds_type_map)) {
        show_debug_message("ERROR: global.equipped_items map does not exist!");
        return;
    }

    // Ensure the slot key exists in the map
    if (ds_map_exists(global.equipped_items, slot)) {
        var current_item = global.equipped_items[? slot];
        if (current_item != -1 && !is_undefined(current_item)) {
            global.equipped_items[? slot] = -1; // Set slot to empty (-1)
            show_debug_message("Unequipped item from slot '" + slot + "'.");
            // Display the current state of the map for debugging
            // show_debug_message("Current global.equipped_items: " + ds_map_write(global.equipped_items));

             // NOTE: Removed call to apply_equipped_items();
             // The player object's Draw event handles the visual update.

        } else {
            show_debug_message("Slot '" + slot + "' was already empty.");
        }
    } else {
        show_debug_message("ERROR: Invalid equipment slot specified: '" + slot + "'");
    }
}
