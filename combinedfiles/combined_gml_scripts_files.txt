Folder: D:\PenguinIsleProject\Penguin Isles\scripts\draw_equipped_items
File: draw_equipped_items.gml
/// @function update_equipped_items_display()
/// @description Draws equipped items in their respective slots on the HUD.
function update_equipped_items_display() {
    if (!ds_exists(global.equipped_items, ds_type_map) || !ds_exists(global.item_sprite_map, ds_type_map)) {
        show_debug_message("Error: Required global maps not initialized.");
        return;
    }

    var gui_width = display_get_gui_width();
    var gui_height = display_get_gui_height();
    var slot_size = 32; // Size of each slot in pixels
    var start_x = gui_width - (6 * slot_size) - 10; // Right side, 6 slots
    var start_y = gui_height / 2 - (3 * slot_size); // Centered vertically

    var slots = ["head", "face", "neck", "body", "hand", "feet"];
    for (var i = 0; i < array_length(slots); i++) {
        var slot = slots[i];
        var item_name = ds_map_find_value(global.equipped_items, slot);
        var slot_x = start_x + (i mod 3) * slot_size;
        var slot_y = start_y + (i div 3) * slot_size;

	}
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\draw_item_card
File: draw_item_card.gml
/// @function draw_item_card(item, x, y)
/// @description Draws an item card with sprite, name, price,
/// @param {struct} item The item data to draw
/// @param {real} x The x position to draw at
/// @param {real} y The y position to draw at

function draw_item_card(item, card_x, card_y) {
    // Draw card background
    draw_set_color(c_dkgray);
    draw_rectangle(card_x, card_y, card_x + item_width, card_y + item_height, false);

    // Draw item sprite
    var sprite_scale = min((item_width - 20) / sprite_get_width(item.sprite),
                           (item_height * 0.6) / sprite_get_height(item.sprite));
    var sprite_x = card_x + item_width/2;
    var sprite_y = card_y + (item_height * 0.3);
    draw_sprite_ext(item.sprite, 0,
                    sprite_x, sprite_y,
                    sprite_scale, sprite_scale,
                    0, c_white, 1);

    // Draw item name
    draw_set_color(c_white);
    draw_set_halign(fa_center);
    draw_set_valign(fa_top);
    draw_set_font(fnt_shop_item);
    draw_text(card_x + item_width/2, card_y + item_height * 0.65, item.name);

    // Draw price
    var price_color = global.player_coins >= item.price ? c_lime : c_red;
    draw_set_color(price_color);
    draw_text(card_x + item_width/2, card_y + item_height * 0.8,
              string(item.price) + " coins");

    // Draw stock info if limited
    if (variable_struct_exists(item, "stock") && item.stock >= 0) {
        draw_set_color(c_yellow);
        draw_text(card_x + item_width/2, card_y + item_height * 0.9,
                  "Stock: " + string(item.stock));
    }

    // Draw seasonal tag if applicable
    if (variable_struct_exists(item, "seasonal") && item.seasonal) {
        draw_set_color(c_aqua);
        draw_text(card_x + item_width/2, card_y + 10, "Seasonal!");
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\equip_item
File: equip_item.gml
/// @function equip_item(slot, item_name)
/// @param {string} slot The name of the slot to equip the item to (e.g., "head", "body").
/// @param {string} item_name The name of the item to equip.
function equip_item(slot, item_name) {
    show_debug_message("Attempting to equip item: '" + item_name + "' to slot: '" + slot + "'");

    // Ensure the global map exists
    if (!ds_exists(global.equipped_items, ds_type_map)) {
        show_debug_message("ERROR: global.equipped_items map does not exist!");
        // Optionally re-initialize it here if needed, but it should be done in obj_initializer
        return;
    }

    // Ensure the slot key exists in the map
    if (ds_map_exists(global.equipped_items, slot)) {
        // Update the map with the item name
        global.equipped_items[? slot] = item_name;
        show_debug_message("Equipped '" + item_name + "' to slot '" + slot + "'.");
        // Display the current state of the map for debugging
        // show_debug_message("Current global.equipped_items: " + ds_map_write(global.equipped_items));

        // NOTE: Removed call to apply_equipped_items();
        // The player object's Draw event handles the visual update.

    } else {
        show_debug_message("ERROR: Invalid equipment slot specified: '" + slot + "'");
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_camera_easing
File: scr_camera_easing.gml
/// Easing function for smooth camera transitions
function easing_out_quad(t) {
    return t * (2 - t);
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_convert_gui_to_world
File: scr_convert_gui_to_world.gml
/// scr_convert_gui_to_world()
/// Converts GUI mouse coordinates to world coordinates
var world_x = camera_get_view_x(view_camera[0]) + (mouse_x / display_get_gui_width()) * camera_get_view_width(view_camera[0]);
var world_y = camera_get_view_y(view_camera[0]) + (mouse_y / display_get_gui_height()) * camera_get_view_height(view_camera[0]);

return [world_x, world_y];

Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_handle_collision
File: scr_handle_collision.gml
// scripts/scr_handle_collision/scr_handle_collision.gml
function handle_collision(axis, speed) {
    var sign_speed = sign(speed);
    var abs_speed = abs(speed);
    var move_dist = 0;
    var step = abs_speed; // Start step size based on absolute speed

    if (abs_speed == 0) return 0; // No speed, no movement needed

    // Iteratively check smaller steps for precision
    while (step > 0.5) {  // Precision threshold (adjust if needed)
        var check_x = x;
        var check_y = y;
        if (axis == "x") {
            check_x += (move_dist + step) * sign_speed;
        } else { // axis == "y"
            check_y += (move_dist + step) * sign_speed;
        }

        if (!place_meeting(check_x, check_y, obj_wall)) {
            // If this step is clear, add it to the distance we can move
            move_dist += step;
        }
        // Halve the step size for the next iteration
        step /= 2;
    }

    // Apply the final calculated movement directly to the instance's coordinates
    if (axis == "x") {
        x += move_dist * sign_speed;
    } else { // axis == "y"
        y += move_dist * sign_speed;
    }

    // Return the actual distance moved (can be useful, but we won't use it for direct position update)
    return move_dist * sign_speed;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_initialize_item_data
File: scr_initialize_item_data.gml
/// @function scr_initialize_item_data()
/// @description Defines all static item properties and populates the lookup maps.
///              Should be called ONLY ONCE at game start.
function scr_initialize_item_data() {

    show_debug_message("--- Running scr_initialize_item_data ---");

    // 1. Define Master Item Data Structure
    //    Using a struct where keys are item names. Each item has its properties.
    //    index: Numerical ID for inventory arrays/saving. MUST BE UNIQUE.
    //    type:  Equipment slot ("head", "face", "body", etc.) or "none" if not equippable.
    //    sprite: Sprite used when EQUIPPED (e.g., spr_player_betahat). Use 'undefined' or a placeholder for non-equippables if needed.
    //    object: Object created when DROPPED (e.g., obj_beta_hat). Use 'undefined' if item cannot be dropped as an object.
    //    inv_sprite: (Optional) Sprite specifically for inventory display (if different from equipped/drop). Defaults to using index on spr_inventory_items.
    //    price: (Optional) Cost in coins for shop system.
    //    description: (Optional) Text description for UI.
    global.item_definitions = {
        // Name             : { index: #, type: "slot/none", sprite: spr_,                object: obj_, /* optional... */ }
        "Beta Hat"          : { index: 0,  type: "head", sprite: spr_player_betahat,     object: obj_beta_hat },
        "Party Hat"         : { index: 1,  type: "head", sprite: spr_player_partyhat,    object: obj_party_hat },
        "Wrench"            : { index: 2,  type: "none", sprite: undefined,              object: obj_wrench_item },
        "Tube"              : { index: 3,  type: "none", sprite: undefined,              object: obj_tube },
        "Toboggan"          : { index: 4,  type: "none", sprite: undefined,              object: obj_toboggan },
        "Battery"           : { index: 5,  type: "none", sprite: undefined,              object: obj_battery },
        "Spy Phone"         : { index: 6,  type: "none", sprite: undefined,              object: obj_spyphone_item },
        "Broken Spy Phone"  : { index: 7,  type: "none", sprite: undefined,              object: obj_broken_spyphone_item },
        "EPF Phone"         : { index: 8,  type: "none", sprite: undefined,              object: obj_epfphone_item },
        "Fishing Rod"       : { index: 9,  type: "none", sprite: undefined,              object: obj_fishing_rod },
        "Jackhammer"        : { index: 10, type: "none", sprite: undefined,              object: obj_Jackhammer_item },
        "Snow Shovel"       : { index: 11, type: "none", sprite: undefined,              object: obj_snowshovel_item },
        "Pizza Slice"       : { index: 12, type: "none", sprite: undefined,              object: obj_pizzaslice_item },
        "Puffle O"          : { index: 13, type: "none", sprite: undefined,              object: obj_puffleo_item },
        "Box Puffle O"      : { index: 14, type: "none", sprite: undefined,              object: obj_boxpuffleo_item },
        "Fish"              : { index: 15, type: "none", sprite: undefined,              object: undefined },
        "Mullet"            : { index: 16, type: "none", sprite: undefined,              object: undefined },
        "Wood"              : { index: 17, type: "none", sprite: undefined,              object: obj_wood_item },
        "Snow"              : { index: 18, type: "none", sprite: undefined,              object: undefined },
        "Snow Blaster"      : { index: 19, type: "none", sprite: undefined,              object: obj_snowblaster_item },
        "Ghost Costume"     : { index: 20, type: "body", sprite: spr_ghostcostume_sheet, object: obj_ghostcostume_item },
        "Black Sun Glasses" : { index: 21, type: "face", sprite: spr_blkglasses_sheet,   object: obj_blacksunglasses_item },
        "Black Hoodie"      : { index: 22, type: "body", sprite: spr_blkhoodie_sheet,    object: obj_blackhoodie_item },
        "Miners Hard Hat"   : { index: 23, type: "head", sprite: spr_minerhat_sheet,     object: obj_minershardhat_item },
        "Tour Hat"          : { index: 24, type: "head", sprite: spr_tourhat_sheet,      object: obj_tourhat_item },
        // Add future items here following the { index: #, type: "", sprite: spr_, object: obj_ } format
    };
    show_debug_message("Defined global.item_definitions struct.");

    // 2. Ensure Helper Lookup Maps Exist (Create if they don't)
    //    These provide faster lookups and are used by existing code.
    if (!variable_global_exists("item_index_map") || !ds_exists(global.item_index_map, ds_type_map)) { global.item_index_map = ds_map_create(); show_debug_message("Created global.item_index_map");}
    if (!variable_global_exists("item_type_map") || !ds_exists(global.item_type_map, ds_type_map)) { global.item_type_map = ds_map_create(); show_debug_message("Created global.item_type_map");}
    if (!variable_global_exists("item_sprite_map") || !ds_exists(global.item_sprite_map, ds_type_map)) { global.item_sprite_map = ds_map_create(); show_debug_message("Created global.item_sprite_map");}
    if (!variable_global_exists("item_object_map") || !ds_exists(global.item_object_map, ds_type_map)) { global.item_object_map = ds_map_create(); show_debug_message("Created global.item_object_map");}
    show_debug_message("Ensured item lookup maps exist.");

    // 3. Clear and Populate Helper Maps from the Master Definition
    ds_map_clear(global.item_index_map);
    ds_map_clear(global.item_type_map);
    ds_map_clear(global.item_sprite_map);
    ds_map_clear(global.item_object_map);

    var item_names = variable_struct_get_names(global.item_definitions);
    for (var i = 0; i < array_length(item_names); i++) {
        var name = item_names[i];
        var data = global.item_definitions[$ name]; // Get the struct for this item

        // Populate index map (Name -> Index)
        // Essential for inventory array which stores indices
        if (variable_struct_exists(data, "index")) {
            ds_map_add(global.item_index_map, name, data.index);
        } else {
            show_debug_message("CRITICAL WARNING: Item '" + name + "' missing 'index' property!");
        }

        // Populate type map (Name -> Slot Type)
        // Used for equipping items to the correct slot
        if (variable_struct_exists(data, "type") && data.type != "none") {
            ds_map_add(global.item_type_map, name, data.type);
        }

        // Populate sprite map (Name -> Sprite Resource for EQUIPPED view)
        // Used by player draw event
        if (variable_struct_exists(data, "sprite") && !is_undefined(data.sprite)) {
            if (sprite_exists(data.sprite)) {
                 ds_map_add(global.item_sprite_map, name, data.sprite);
            } else {
                 show_debug_message("WARNING: Sprite " + string(data.sprite) + " for item '" + name + "' does not exist!");
                 // Maybe add a default/placeholder sprite here?
                 // ds_map_add(global.item_sprite_map, name, spr_placeholder_item);
            }
        }

        // Populate object map (Name -> Object Resource for DROPPED view)
        // Used by inventory_drop_active_item
        if (variable_struct_exists(data, "object") && !is_undefined(data.object)) {
            if (object_exists(data.object)) {
                 ds_map_add(global.item_object_map, name, data.object);
            } else {
                show_debug_message("WARNING: Object " + object_get_name(data.object) + " for item '" + name + "' does not exist!");
                 // Maybe add a default/placeholder object?
                 // ds_map_add(global.item_object_map, name, obj_generic_dropped_item);
            }
        }
    }
    show_debug_message("Populated item lookup maps (Index, Type, Sprite, Object).");
    show_debug_message("--- Finished scr_initialize_item_data ---");
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_init_globals
File: scr_init_globals.gml
/// @function init_globals()
/// @description Initializes global variables and ensures essential DYNAMIC structures exist.
///              Only sets default *game state* values for a new game.
///              Static item data is handled separately by scr_initialize_item_data().
function init_globals() {
    show_debug_message("--- Running init_globals (Refactored) ---");

    // --- Section 1: Ensure Essential Flags/Variables Exist (Run Always) ---
    if (!variable_global_exists("is_loading_game")) { global.is_loading_game = false; }
    if (!variable_global_exists("player_instance")) { global.player_instance = noone; }
    if (!variable_global_exists("inventory_expanded")) { global.inventory_expanded = false; show_debug_message("Ensured global.inventory_expanded exists."); }
    if (!variable_global_exists("game_paused")) { global.game_paused = false; show_debug_message("Ensured global.game_paused exists."); }
    if (!variable_global_exists("is_pause_menu_active")) { global.is_pause_menu_active = false; show_debug_message("Ensured global.is_pause_menu_active exists."); }
    if (!variable_global_exists("player_controls_enabled")) { global.player_controls_enabled = true; show_debug_message("Ensured global.player_controls_enabled exists."); }
    if (!variable_global_exists("colour_picker_active")) { global.colour_picker_active = false; show_debug_message("Ensured global.colour_picker_active exists."); }
    // Keep party_hat_visible/beta_hat_visible for now, but they might be redundant if relying purely on equipped_items
    if (!variable_global_exists("party_hat_visible")) { global.party_hat_visible = false; show_debug_message("Ensured global.party_hat_visible exists."); }
    if (!variable_global_exists("beta_hat_visible")) { global.beta_hat_visible = false; show_debug_message("Ensured global.beta_hat_visible exists."); }
    if (!variable_global_exists("skin_switching")) { global.skin_switching = false; show_debug_message("Ensured global.skin_switching exists."); }

    // --- Section 2: Ensure Core DYNAMIC Data Structures Exist (Run Always) ---
    //                 (Don't clear here if loading, only ensure existence)
    //                 Item lookup maps (item_index_map etc.) are handled by scr_initialize_item_data
    if (!variable_global_exists("following_puffles") || !ds_exists(global.following_puffles, ds_type_list)) { if (variable_global_exists("following_puffles") && ds_exists(global.following_puffles, ds_type_list)) ds_list_destroy(global.following_puffles); global.following_puffles = ds_list_create(); show_debug_message("Ensured global.following_puffles list exists."); }
    if (!variable_global_exists("room_states") || !ds_exists(global.room_states, ds_type_map)) { if (variable_global_exists("room_states") && ds_exists(global.room_states, ds_type_map)) ds_map_destroy(global.room_states); global.room_states = ds_map_create(); show_debug_message("Ensured global.room_states map exists."); }
    if (!variable_global_exists("active_quests") || !ds_exists(global.active_quests, ds_type_list)) { if (variable_global_exists("active_quests") && ds_exists(global.active_quests, ds_type_list)) ds_list_destroy(global.active_quests); global.active_quests = ds_list_create(); show_debug_message("Ensured global.active_quests list exists."); }
    if (!variable_global_exists("completed_quests") || !ds_exists(global.completed_quests, ds_type_list)) { if (variable_global_exists("completed_quests") && ds_exists(global.completed_quests, ds_type_list)) ds_list_destroy(global.completed_quests); global.completed_quests = ds_list_create(); show_debug_message("Ensured global.completed_quests list exists."); }
    // Inventory array (ensure it exists, size might be set here or defaults later)
    if (!variable_global_exists("inventory") || !is_array(global.inventory)) {
	    global.inventory = array_create(INVENTORY_SIZE, -1); // Use macro
	    show_debug_message("Ensured global.inventory array exists (Size " + string(INVENTORY_SIZE) + ").");
	}
    // Equipped items map (ensure it exists with base slots)
    if (!variable_global_exists("equipped_items") || !ds_exists(global.equipped_items, ds_type_map)) { if (variable_global_exists("equipped_items") && ds_exists(global.equipped_items, ds_type_map)) ds_map_destroy(global.equipped_items); global.equipped_items = ds_map_create(); ds_map_add(global.equipped_items, "head", -1); ds_map_add(global.equipped_items, "face", -1); ds_map_add(global.equipped_items, "neck", -1); ds_map_add(global.equipped_items, "body", -1); ds_map_add(global.equipped_items, "hand", -1); ds_map_add(global.equipped_items, "feet", -1); show_debug_message("Ensured global.equipped_items map exists with slots."); }

    // --- Camera Initialization (Run Always) ---
    if (!variable_global_exists("camera") || !is_real(global.camera) || global.camera < 0) {
        if (variable_global_exists("camera")) { show_debug_message("init_globals: global.camera holds invalid value (" + string(global.camera) + "). Recreating camera."); }
        else { show_debug_message("init_globals: global.camera variable does not exist. Creating camera."); }
        global.camera = camera_create();
        view_set_camera(0, global.camera);
        show_debug_message("init_globals: Created new global.camera. ID: " + string(global.camera));
    } else {
        show_debug_message("init_globals: Valid global.camera already exists. ID: " + string(global.camera));
        if (view_get_camera(0) != global.camera) {
            view_set_camera(0, global.camera);
            show_debug_message("init_globals: Ensured view 0 uses existing global.camera.");
        }
    }

    // --- Section 3: Loading Check ---
    if (variable_global_exists("is_loading_game") && global.is_loading_game == true) {
        show_debug_message("init_globals: Skipping NEW GAME default value assignments during game load.");
        exit; // Don't set new game defaults if loading
    }

    // --- Section 4: Default Value Assignments (Only for NEW GAME) ---
    show_debug_message("init_globals: Setting default values for NEW GAME.");
    global.player_x = 170;
    global.player_y = 154;
    global.warp_target_x = undefined;
    global.warp_target_y = undefined;
    global.warp_target_face = undefined;
    global.player_health = 100;
    global.score = 0;
    global.repair_complete = false; // Used by obj_inventory check
    global.player_color = make_color_rgb(7, 167, 163); // Default starting color (Cyan)
	global.inventory = array_create(INVENTORY_SIZE, -1); // Use macro

    // Clear DYNAMIC data structures specifically for a NEW game
    if (ds_exists(global.following_puffles, ds_type_list)) { ds_list_clear(global.following_puffles); }
    // Clear room_states map and destroy any contained lists
    if (ds_exists(global.room_states, ds_type_map)) {
         var _keys = ds_map_keys_to_array(global.room_states);
         for (var i = 0; i < array_length(_keys); i++) {
             var _list = global.room_states[? _keys[i]];
             if (ds_exists(_list, ds_type_list)) { ds_list_destroy(_list); }
         }
         ds_map_clear(global.room_states);
     }
    if (ds_exists(global.active_quests, ds_type_list)) { ds_list_clear(global.active_quests); }
    if (ds_exists(global.completed_quests, ds_type_list)) { ds_list_clear(global.completed_quests); }
    // Reset inventory array
    global.inventory = array_create(42, -1);
    // Reset equipped items map
    if (ds_exists(global.equipped_items, ds_type_map)) {
        ds_map_clear(global.equipped_items);
        ds_map_add(global.equipped_items, "head", -1); ds_map_add(global.equipped_items, "face", -1); ds_map_add(global.equipped_items, "neck", -1); ds_map_add(global.equipped_items, "body", -1); ds_map_add(global.equipped_items, "hand", -1); ds_map_add(global.equipped_items, "feet", -1);
    }

    show_debug_message("Finished setting default values via init_globals.");
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_init_sprites
File: scr_init_sprites.gml
function init_sprites(right, up, left, down, up_right, up_left, down_right, down_left) {
    sprite[RIGHT] = right;
    sprite[UP] = up;
    sprite[LEFT] = left;
    sprite[DOWN] = down;
    sprite[UP_RIGHT] = up_right;
    sprite[UP_LEFT] = up_left;
    sprite[DOWN_RIGHT] = down_right;
    sprite[DOWN_LEFT] = down_left;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_load_game
File: scr_load_game.gml
/// @function load_game()
/// @description Loads the game state from savegame.sav
function load_game() {
    show_debug_message("--- Running load_game ---");

    // Check for save file
    if (!file_exists("savegame.sav")) {
        show_debug_message("Load Game: No save file found.");
        return false;
    }

    // Read save file
    var file = file_text_open_read("savegame.sav");
    if (file == -1) {
        show_debug_message("Load Game ERROR: Failed to open save file.");
        return false;
    }
    var json_string = file_text_read_string(file);
    file_text_close(file);

    var save_data = noone; // Initialize save_data

    // --- Attempt to Parse JSON ---
    try {
        save_data = json_parse(json_string);
        if (!is_struct(save_data)) {
             throw "Parsed data is not a struct.";
        }
    } catch (_error) {
        show_debug_message("Load Game FATAL ERROR: Failed to parse save file JSON: " + string(_error));
        // Optionally attempt backup load here
        return false; // Stop loading
    }

    // --- Load Data within Try/Catch for robustness ---
    try {
        // Validate save data version
        if (!variable_struct_exists(save_data, "version")) {
            throw "Save file missing version information";
        }
        if (save_data.version != "1.0.0") {
            show_debug_message("Load Game WARNING: Save file version mismatch. Attempting to load anyway.");
            // Add version migration logic here in the future if needed
        }

        // *** Set Loading Flag ***
        global.is_loading_game = true;
        show_debug_message("Load Game: Set global.is_loading_game = true");

        // --- Ensure Global Structures Exist (Crucial before loading into them) ---
        // (These should ideally also be checked/created in init_globals, but good safety here)
        if (!variable_global_exists("room_states") || !ds_exists(global.room_states, ds_type_map)) { global.room_states = ds_map_create(); }
        if (!variable_global_exists("active_quests") || !ds_exists(global.active_quests, ds_type_list)) { global.active_quests = ds_list_create(); }
        if (!variable_global_exists("completed_quests") || !ds_exists(global.completed_quests, ds_type_list)) { global.completed_quests = ds_list_create(); }
        if (!variable_global_exists("equipped_items") || !ds_exists(global.equipped_items, ds_type_map)) { global.equipped_items = ds_map_create(); /* Add default empty slots */ }
        if (!variable_global_exists("inventory") || !is_array(global.inventory)) { global.inventory = array_create(42, -1); }

        // Default target room if loading fails partially
        global.target_room = rm_welcome_room;

        // --- Load Game State ---
        if (variable_struct_exists(save_data, "game_state")) {
            var game_state = save_data.game_state;

            // Load target room
            if (variable_struct_exists(game_state, "current_room")) {
                var loaded_room = game_state.current_room;
                if (room_exists(loaded_room)) {
                    global.target_room = loaded_room;
                    show_debug_message("Load Game: Target room set to " + room_get_name(global.target_room));
                } else {
                    show_debug_message("Load Game WARNING: Saved room ID " + string(loaded_room) + " does not exist! Defaulting to Welcome Room.");
                    global.target_room = rm_welcome_room;
                }
            }

            // --- Load Inventory ---
            if (variable_struct_exists(game_state, "inventory")) {
                var loaded_inv = game_state.inventory;
                if (is_array(loaded_inv)) {
                    global.inventory = array_clone(loaded_inv); // Clone loaded data
                } else {
                    show_debug_message("WARNING: Invalid inventory data format. Initializing empty inventory.");
                    global.inventory = array_create(42, -1); // Initialize empty inventory
                }
            }

            // --- Deserialize Room States ---
            if (variable_struct_exists(game_state, "room_states")) {
                var loaded_room_states = game_state.room_states;
                if (is_struct(loaded_room_states)) {
                    global.room_states = ds_map_create();
                    for (var k = ds_map_find_first(loaded_room_states); k != noone; k = ds_map_find_next(loaded_room_states, k)) {
                        var room_name = k;
                        var room_data = loaded_room_states[room_name];
                        if (is_array(room_data)) {
                            for (var j = 0; j < array_length(room_data); j++) {
                                var obj_data = room_data[j];
                                var inst = instance_create_layer(obj_data.x, obj_data.y, "Instances", obj_data.object_index);
                                ds_map_to_struct(inst, obj_data.properties);
                            }
                        }
                    }
                } else {
                    show_debug_message("WARNING: Invalid room state data format.");
                }
            }
        }
    } catch (_error) {
        show_debug_message("Load Game ERROR during data loading: " + string(_error));
    }

    global.is_loading_game = false;
    show_debug_message("--- Finished load_game ---");
    return true;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_macros
File: scr_macros.gml
#macro RIGHT 0
#macro UP 1
#macro LEFT 2
#macro DOWN 3
#macro UP_RIGHT 4
#macro UP_LEFT 5
#macro DOWN_RIGHT 6
#macro DOWN_LEFT 7

#macro INVENTORY_SIZE 42
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_music_function
File: scr_music_function.gml
function set_song_ingame( _song, _fadeOutCurrentSong = 0, _fadeIn = 0 )
{
	//_song = set to any song (including "noone" to stop or fade the track out)
	//_fadeOutCurrentSong = time (in frames) the current song (if playing) will take to fade out
	//_fadeIn = time (in frames) the target song (if not "noone" will take to fade in

	with ( obj_musicmanager )
	{
		targetSongAsset = _song;
		endFadeOutTime = _fadeOutCurrentSong;
		startFadeInTime = _fadeIn;
	}
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_puffle
File: scr_puffle.gml
/// @function get_puffle_sprite_data(direction)
/// @param direction - The facing direction (e.g., DOWN, LEFT)
/// @returns Array [base_subimage, xscale]
function get_puffle_sprite_data(direction) {
    switch (direction) {
        case DOWN: return [0, 1];       // Row 1: Subimages 0-7
        case DOWN_LEFT: return [8, 1];  // Row 2: Subimages 8-15
        case LEFT: return [16, 1];      // Row 3: Subimages 16-23
        case UP_LEFT: return [24, 1];   // Row 4: Subimages 24-31
        case UP: return [32, 1];        // Row 5: Subimages 32-39
        case DOWN_RIGHT: return [8, -1]; // Use Down-Left, flipped
        case RIGHT: return [16, -1];    // Use Left, flipped
        case UP_RIGHT: return [24, -1]; // Use Up-Left, flipped
        default: return [0, 1];         // Default to Down
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_room_state
File: scr_room_state.gml
function save_room_state(room_id) {
    var room_name = room_get_name(room_id);
    show_debug_message("Saving state for room: " + room_name);
    if (ds_map_exists(global.room_states, room_name)) {
        var old_list = ds_map_find_value(global.room_states, room_name);
        if (ds_exists(old_list, ds_type_list)) {
            ds_list_destroy(old_list);
        }
    }
    var state_list = ds_list_create();
    ds_map_replace(global.room_states, room_name, state_list);

    with (all) {
        if (variable_instance_exists(id, "is_savable") && is_savable && object_index != obj_player && object_index != obj_player_tube) {
            if (object_index == obj_puffle && variable_instance_get(id, "following_player") == true) {
                continue;
            }
            var state = {
                object_index: object_index,
                x: x,
                y: y,
                direction: variable_instance_exists(id, "face") ? variable_instance_get(id, "face") : 0
            };
            if (object_index == obj_icetruck || object_index == obj_icetruck_broken) {
                state.repair_required = variable_instance_exists(id, "repair_required") ? variable_instance_get(id, "repair_required") : false;
                state.is_driveable = variable_instance_exists(id, "is_driveable") ? variable_instance_get(id, "is_driveable") : false;
            } else if (object_index == obj_dropped_item) {
                var item_type = variable_instance_get(id, "item_type");
                state.item_type = (item_type != undefined) ? item_type : "";
            } else if (object_index == obj_puffle) {
                state.following_player = variable_instance_exists(id, "following_player") ? variable_instance_get(id, "following_player") : false;
                var color = variable_instance_get(id, "color");
                state.color = (color != undefined) ? color : "";
                var puffle_state = variable_instance_get(id, "state");
                state.state = (puffle_state != undefined) ? puffle_state : "";
            }
            ds_list_add(state_list, state);
        }
    }
    show_debug_message("Saved state for room: " + room_name + " with " + string(ds_list_size(state_list)) + " objects.");
}

function load_room_state(room_id) {
    var room_name = room_get_name(room_id);
    show_debug_message("Attempting to load state for room: " + room_name);

    // Check if saved state exists for this room
    if (ds_map_exists(global.room_states, room_name)) {
        var state_list = ds_map_find_value(global.room_states, room_name);

        if (ds_exists(state_list, ds_type_list)) {
            show_debug_message("Found state list for " + room_name + ". Size: " + string(ds_list_size(state_list)));

            // --- Destroy existing savable instances CAREFULLY ---
            show_debug_message("Destroying existing savable instances in " + room_name + "...");
            with (all) {
                // Check if instance is savable AND not the current player instance AND not a globally managed following puffle
                if (variable_instance_exists(id, "is_savable") && is_savable &&
                    id != global.player_instance && // Don't destroy the current player <<<--- THIS IS THE KEY CHECK
                    (object_index != obj_puffle || ds_list_find_index(global.following_puffles, id) == -1)) // Don't destroy globally tracked puffles
                {
                    show_debug_message("Destroying instance " + string(id) + " (" + object_get_name(object_index) + ")");
                    instance_destroy();
                }
            }
            show_debug_message("Finished destroying old instances.");

            // --- Create instances from saved state ---
            show_debug_message("Creating instances from saved state...");
            for (var i = 0; i < ds_list_size(state_list); i++) {
                var state = state_list[| i];
                var inst = noone; // Initialize inst

                // Validate object index before creating
                if (!object_exists(state.object_index)) {
                     show_debug_message("Load State WARNING: Saved object index " + string(state.object_index) + " does not exist! Skipping instance.");
                     continue; // Skip this state entry
                }

                // Special handling for puffles that should be following vs. room-specific ones
                if (state.object_index == obj_puffle) {
                    if (variable_struct_exists(state, "following_player") && state.following_player) {
                         // This state represents a puffle that *should* be following.
                         // Don't recreate it here; it should persist or be managed globally.
                         // Check if it's *already* in the global list - if not, maybe add it? (Complex case)
                         show_debug_message("Load State: Skipping creation of following puffle state - should be persistent.");
                         continue; // Skip creating this puffle from room state
                    } else {
                        // This is a puffle that was *not* following, create it normally
                        inst = instance_create_layer(state.x, state.y, "Instances", state.object_index);
                    }
                } else {
                     // Create non-puffle instances normally
                     inst = instance_create_layer(state.x, state.y, "Instances", state.object_index);
                }

                // Apply common state if instance was created
                if (instance_exists(inst)) {
                    if (variable_instance_exists(inst, "face")) {
                        inst.face = state.direction ?? DOWN; // Default to DOWN if direction missing
                    }

                    // Apply specific object states
                     if (state.object_index == obj_icetruck || state.object_index == obj_icetruck_broken) {
                         if (variable_instance_exists(inst,"repair_required")) inst.repair_required = state.repair_required ?? true; // Default to requiring repair if missing
                         if (variable_instance_exists(inst,"is_driveable")) inst.is_driveable = state.is_driveable ?? false; // Default to not driveable
                     } else if (state.object_index == obj_dropped_item) {
                         if (variable_instance_exists(inst,"item_type")) inst.item_type = state.item_type ?? "Unknown";
                     } else if (state.object_index == obj_puffle) { // This applies to non-following puffles created above
                         if (variable_instance_exists(inst,"following_player")) inst.following_player = false; // Ensure it's false
                         if (variable_instance_exists(inst,"color")) inst.color = state.color ?? "white";
                         if (variable_instance_exists(inst,"state")) inst.state = state.state ?? PuffleState.IDLE;
                         // Apply color blend based on state.color
                         switch (inst.color) {
                             case "red": inst.image_blend = make_color_rgb(255, 0, 0); break;
                             case "blue": inst.image_blend = make_color_rgb(0, 0, 255); break;
                             case "green": inst.image_blend = make_color_rgb(0, 255, 0); break;
                             case "yellow": inst.image_blend = make_color_rgb(255, 255, 0); break;
                             default: inst.image_blend = c_white;
                         }
                     }
                     show_debug_message("Loaded " + object_get_name(state.object_index) + " at (" + string(state.x) + ", " + string(state.y) + ")");
                } // end if instance_exists(inst)
            } // end for loop
            show_debug_message("Finished creating instances for " + room_name);
        } else {
            show_debug_message("Saved state list for " + room_name + " is invalid or empty.");
        }
    } else {
        show_debug_message("No saved state found for room: " + room_name);
        // Destroy existing savable items even if no save state is found, to ensure a clean room? (Optional)
        // with(all) { /* ... destroy logic ... */ }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_save_game
File: scr_save_game.gml
/// @function save_game()
/// @description Saves the game state to savegame.sav
function save_game() {
    show_debug_message("--- Running save_game ---");

    // --- Pre-checks (Good practice) ---
    if (!instance_exists(global.player_instance)) {
        show_debug_message("Error: Cannot save - player instance not found.");
        return;
    }
    if (!variable_global_exists("inventory")) {
        show_debug_message("Warning: global.inventory not initialized before save. Creating empty.");
        global.inventory = array_create(42, -1); // Or your defined size
    }
    if (!ds_exists(global.equipped_items, ds_type_map)) {
        show_debug_message("ERROR: global.equipped_items map does not exist before save. Creating empty map.");
        global.equipped_items = ds_map_create();
        // Add default empty slots
        ds_map_add(global.equipped_items, "head", -1);
        ds_map_add(global.equipped_items, "face", -1);
        ds_map_add(global.equipped_items, "neck", -1);
        ds_map_add(global.equipped_items, "body", -1);
        ds_map_add(global.equipped_items, "hand", -1);
        ds_map_add(global.equipped_items, "feet", -1);
    }
    if (!ds_exists(global.room_states, ds_type_map)) {
        show_debug_message("Warning: global.room_states map does not exist before save. Creating empty.");
        global.room_states = ds_map_create();
    }
    if (!ds_exists(global.active_quests, ds_type_list)) {
        show_debug_message("Warning: global.active_quests list does not exist before save. Creating empty.");
        global.active_quests = ds_list_create();
    }

    // --- Serialize Room States ---
    global.room_states = ds_map_create();
    for (var i = 0; i < room_instance_count; i++) {
        var inst = room_instance_find(room, i);
        if (instance_exists(inst) && inst.is_savable) {
            var room_name = room_get_name(room);
            if (!ds_map_exists(global.room_states, room_name)) {
                global.room_states[room_name] = [];
            }
            array_push(global.room_states[room_name], {
                object_index: inst.object_index,
                x: inst.x,
                y: inst.y,
                properties: ds_map_to_struct(inst)
            });
        }
    }

    // --- Save Data ---
    var save_data = {
        version: "1.0.0",
        game_state: {
            inventory: global.inventory,
            room_states: global.room_states,
            current_room: room
        }
    };

    // --- Convert to JSON and Save ---
    var json = json_stringify(save_data);
    var file = file_text_open_write("savegame.sav");
    if (file != -1) {
        file_text_write_string(file, json);
        file_text_close(file);
        show_debug_message("Game saved successfully.");
    } else {
        show_debug_message("Error: Failed to open savegame.sav for writing.");
    }

    show_debug_message("--- Finished save_game ---");
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_set_depth
File: scr_set_depth.gml
// scr_set_depth.gml
function set_depth() {
    depth = -bbox_bottom;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\unequip_item
File: unequip_item.gml
/// @function unequip_item(slot)
/// @param {string} slot The name of the slot to unequip the item from
function unequip_item(slot) {
    // Ensure the global map exists
    if (!ds_exists(global.equipped_items, ds_type_map)) {
        show_debug_message("ERROR: global.equipped_items map does not exist!");
        return;
    }

    // Ensure the slot key exists in the map
    if (ds_map_exists(global.equipped_items, slot)) {
        var current_item = global.equipped_items[? slot];
        if (current_item != -1 && !is_undefined(current_item)) {
            global.equipped_items[? slot] = -1; // Set slot to empty (-1)
            show_debug_message("Unequipped item from slot '" + slot + "'.");
            // Display the current state of the map for debugging
            // show_debug_message("Current global.equipped_items: " + ds_map_write(global.equipped_items));

             // NOTE: Removed call to apply_equipped_items();
             // The player object's Draw event handles the visual update.

        } else {
            show_debug_message("Slot '" + slot + "' was already empty.");
        }
    } else {
        show_debug_message("ERROR: Invalid equipment slot specified: '" + slot + "'");
    }
}
